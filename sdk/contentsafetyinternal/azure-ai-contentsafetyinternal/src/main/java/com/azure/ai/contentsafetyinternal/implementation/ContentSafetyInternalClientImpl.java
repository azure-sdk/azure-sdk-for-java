// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.contentsafetyinternal.implementation;

import com.azure.ai.contentsafetyinternal.ContentSafetyInternalServiceVersion;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.HttpPipeline;
import com.azure.core.http.HttpPipelineBuilder;
import com.azure.core.http.policy.RetryPolicy;
import com.azure.core.http.policy.UserAgentPolicy;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.serializer.JacksonAdapter;
import com.azure.core.util.serializer.SerializerAdapter;
import java.time.OffsetDateTime;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;

/** Initializes a new instance of the ContentSafetyInternalClient type. */
public final class ContentSafetyInternalClientImpl {
    /** The proxy service used to perform REST calls. */
    private final ContentSafetyInternalClientService service;

    /**
     * Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     */
    private final String endpoint;

    /**
     * Gets Supported Cognitive Services endpoints (protocol and hostname, for example:
     * https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     *
     * @return the endpoint value.
     */
    public String getEndpoint() {
        return this.endpoint;
    }

    /** Service version. */
    private final ContentSafetyInternalServiceVersion serviceVersion;

    /**
     * Gets Service version.
     *
     * @return the serviceVersion value.
     */
    public ContentSafetyInternalServiceVersion getServiceVersion() {
        return this.serviceVersion;
    }

    /** The HTTP pipeline to send requests through. */
    private final HttpPipeline httpPipeline;

    /**
     * Gets The HTTP pipeline to send requests through.
     *
     * @return the httpPipeline value.
     */
    public HttpPipeline getHttpPipeline() {
        return this.httpPipeline;
    }

    /** The serializer to serialize an object into a string. */
    private final SerializerAdapter serializerAdapter;

    /**
     * Gets The serializer to serialize an object into a string.
     *
     * @return the serializerAdapter value.
     */
    public SerializerAdapter getSerializerAdapter() {
        return this.serializerAdapter;
    }

    /**
     * Initializes an instance of ContentSafetyInternalClient client.
     *
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     * @param serviceVersion Service version.
     */
    public ContentSafetyInternalClientImpl(String endpoint, ContentSafetyInternalServiceVersion serviceVersion) {
        this(
                new HttpPipelineBuilder().policies(new UserAgentPolicy(), new RetryPolicy()).build(),
                JacksonAdapter.createDefaultSerializerAdapter(),
                endpoint,
                serviceVersion);
    }

    /**
     * Initializes an instance of ContentSafetyInternalClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     * @param serviceVersion Service version.
     */
    public ContentSafetyInternalClientImpl(
            HttpPipeline httpPipeline, String endpoint, ContentSafetyInternalServiceVersion serviceVersion) {
        this(httpPipeline, JacksonAdapter.createDefaultSerializerAdapter(), endpoint, serviceVersion);
    }

    /**
     * Initializes an instance of ContentSafetyInternalClient client.
     *
     * @param httpPipeline The HTTP pipeline to send requests through.
     * @param serializerAdapter The serializer to serialize an object into a string.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *     https://&lt;resource-name&gt;.cognitiveservices.azure.com).
     * @param serviceVersion Service version.
     */
    public ContentSafetyInternalClientImpl(
            HttpPipeline httpPipeline,
            SerializerAdapter serializerAdapter,
            String endpoint,
            ContentSafetyInternalServiceVersion serviceVersion) {
        this.httpPipeline = httpPipeline;
        this.serializerAdapter = serializerAdapter;
        this.endpoint = endpoint;
        this.serviceVersion = serviceVersion;
        this.service =
                RestProxy.create(
                        ContentSafetyInternalClientService.class, this.httpPipeline, this.getSerializerAdapter());
    }

    /**
     * The interface defining all the services for ContentSafetyInternalClient to be used by the proxy service to
     * perform REST calls.
     */
    @Host("{endpoint}/contentsafety/internal")
    @ServiceInterface(name = "ContentSafetyInterna")
    public interface ContentSafetyInternalClientService {
        @Get("/whitelist/features")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listWritelistFeatures(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/whitelist/features")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listWritelistFeaturesSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/metrics/requestCounts")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listRequestCounts(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @QueryParam("start") OffsetDateTime start,
                @QueryParam("end") OffsetDateTime end,
                @QueryParam("granularity") String granularity,
                @QueryParam("contentSafetyVersion") String contentSafetyVersion,
                @QueryParam("contentSafetyOperation") String contentSafetyOperation,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/metrics/requestCounts")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listRequestCountsSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @QueryParam("start") OffsetDateTime start,
                @QueryParam("end") OffsetDateTime end,
                @QueryParam("granularity") String granularity,
                @QueryParam("contentSafetyVersion") String contentSafetyVersion,
                @QueryParam("contentSafetyOperation") String contentSafetyOperation,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/metrics/requestLatencies")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listRequestLatencies(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @QueryParam("start") OffsetDateTime start,
                @QueryParam("end") OffsetDateTime end,
                @QueryParam("granularity") String granularity,
                @QueryParam("contentSafetyVersion") String contentSafetyVersion,
                @QueryParam("contentSafetyOperation") String contentSafetyOperation,
                @QueryParam("aggregation") String aggregation,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/metrics/requestLatencies")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listRequestLatenciesSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @QueryParam("start") OffsetDateTime start,
                @QueryParam("end") OffsetDateTime end,
                @QueryParam("granularity") String granularity,
                @QueryParam("contentSafetyVersion") String contentSafetyVersion,
                @QueryParam("contentSafetyOperation") String contentSafetyOperation,
                @QueryParam("aggregation") String aggregation,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/metrics/categories/{category}/requestCounts")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listRequestCountsByCategoryAndSeverity(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("category") String category,
                @QueryParam("start") OffsetDateTime start,
                @QueryParam("end") OffsetDateTime end,
                @QueryParam("granularity") String granularity,
                @QueryParam("contentSafetyVersion") String contentSafetyVersion,
                @QueryParam("modality") String modality,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/metrics/categories/{category}/requestCounts")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listRequestCountsByCategoryAndSeveritySync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @PathParam("category") String category,
                @QueryParam("start") OffsetDateTime start,
                @QueryParam("end") OffsetDateTime end,
                @QueryParam("granularity") String granularity,
                @QueryParam("contentSafetyVersion") String contentSafetyVersion,
                @QueryParam("modality") String modality,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/metrics/blocklistTopTerms")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listBlocklistTopTerms(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @QueryParam("top") int top,
                @QueryParam("start") OffsetDateTime start,
                @QueryParam("end") OffsetDateTime end,
                @QueryParam("contentSafetyVersion") String contentSafetyVersion,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/metrics/blocklistTopTerms")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listBlocklistTopTermsSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @QueryParam("top") int top,
                @QueryParam("start") OffsetDateTime start,
                @QueryParam("end") OffsetDateTime end,
                @QueryParam("contentSafetyVersion") String contentSafetyVersion,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/metrics/blocklistHitCalls")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listBlocklistHitCalls(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @QueryParam("start") OffsetDateTime start,
                @QueryParam("end") OffsetDateTime end,
                @QueryParam("granularity") String granularity,
                @QueryParam("contentSafetyVersion") String contentSafetyVersion,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("/metrics/blocklistHitCalls")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listBlocklistHitCallsSync(
                @HostParam("endpoint") String endpoint,
                @QueryParam("api-version") String apiVersion,
                @QueryParam("start") OffsetDateTime start,
                @QueryParam("end") OffsetDateTime end,
                @QueryParam("granularity") String granularity,
                @QueryParam("contentSafetyVersion") String contentSafetyVersion,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listRequestCountsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listRequestCountsNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listRequestLatenciesNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listRequestLatenciesNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listRequestCountsByCategoryAndSeverityNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listRequestCountsByCategoryAndSeverityNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> listBlocklistHitCallsNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> listBlocklistHitCallsNextSync(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                @HeaderParam("accept") String accept,
                RequestOptions requestOptions,
                Context context);
    }

    /**
     * List Whitelist Features.
     *
     * <p>Get whitelist features.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             featureName: String (Required)
     *             properties (Required): {
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return whitelist features along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> listWritelistFeaturesWithResponseAsync(RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                context ->
                        service.listWritelistFeatures(
                                this.getEndpoint(),
                                this.getServiceVersion().getVersion(),
                                accept,
                                requestOptions,
                                context));
    }

    /**
     * List Whitelist Features.
     *
     * <p>Get whitelist features.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             featureName: String (Required)
     *             properties (Required): {
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return whitelist features along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> listWritelistFeaturesWithResponse(RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.listWritelistFeaturesSync(
                this.getEndpoint(), this.getServiceVersion().getVersion(), accept, requestOptions, Context.NONE);
    }

    /**
     * List API Request Counts At Different Timestamps Given A Time Range.
     *
     * <p>List API request counts at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'. Allowed
     *     values: "AnalyzeText", "AnalyzeImage", "AnalyzeImageWithText".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of CountPerTimestamp items along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listRequestCountsSinglePageAsync(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String contentSafetyOperation,
            RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listRequestCounts(
                                        this.getEndpoint(),
                                        this.getServiceVersion().getVersion(),
                                        start,
                                        end,
                                        granularity,
                                        contentSafetyVersion,
                                        contentSafetyOperation,
                                        accept,
                                        requestOptions,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * List API Request Counts At Different Timestamps Given A Time Range.
     *
     * <p>List API request counts at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'. Allowed
     *     values: "AnalyzeText", "AnalyzeImage", "AnalyzeImageWithText".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of CountPerTimestamp items as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listRequestCountsAsync(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String contentSafetyOperation,
            RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedFlux<>(
                () ->
                        listRequestCountsSinglePageAsync(
                                start, end, granularity, contentSafetyVersion, contentSafetyOperation, requestOptions),
                nextLink -> listRequestCountsNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * List API Request Counts At Different Timestamps Given A Time Range.
     *
     * <p>List API request counts at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'. Allowed
     *     values: "AnalyzeText", "AnalyzeImage", "AnalyzeImageWithText".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of CountPerTimestamp items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listRequestCountsSinglePage(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String contentSafetyOperation,
            RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listRequestCountsSync(
                        this.getEndpoint(),
                        this.getServiceVersion().getVersion(),
                        start,
                        end,
                        granularity,
                        contentSafetyVersion,
                        contentSafetyOperation,
                        accept,
                        requestOptions,
                        Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                getNextLink(res.getValue(), "nextLink"),
                null);
    }

    /**
     * List API Request Counts At Different Timestamps Given A Time Range.
     *
     * <p>List API request counts at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'. Allowed
     *     values: "AnalyzeText", "AnalyzeImage", "AnalyzeImageWithText".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of CountPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listRequestCounts(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String contentSafetyOperation,
            RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedIterable<>(
                () ->
                        listRequestCountsSinglePage(
                                start, end, granularity, contentSafetyVersion, contentSafetyOperation, requestOptions),
                nextLink -> listRequestCountsNextSinglePage(nextLink, requestOptionsForNextPage));
    }

    /**
     * List API Request Latencies At Different Timestamps Given A Time Range.
     *
     * <p>List API request latencies at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     latency: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'. Allowed
     *     values: "AnalyzeText", "AnalyzeImage", "AnalyzeImageWithText".
     * @param aggregation Aggregation method of the latency, the value could be 'Percentile99', 'Percentile95',
     *     'Average'. Allowed values: "P99", "P95", "Avg".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of LatencyPerTimestamp items along with {@link PagedResponse} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listRequestLatenciesSinglePageAsync(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String contentSafetyOperation,
            String aggregation,
            RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listRequestLatencies(
                                        this.getEndpoint(),
                                        this.getServiceVersion().getVersion(),
                                        start,
                                        end,
                                        granularity,
                                        contentSafetyVersion,
                                        contentSafetyOperation,
                                        aggregation,
                                        accept,
                                        requestOptions,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * List API Request Latencies At Different Timestamps Given A Time Range.
     *
     * <p>List API request latencies at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     latency: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'. Allowed
     *     values: "AnalyzeText", "AnalyzeImage", "AnalyzeImageWithText".
     * @param aggregation Aggregation method of the latency, the value could be 'Percentile99', 'Percentile95',
     *     'Average'. Allowed values: "P99", "P95", "Avg".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of LatencyPerTimestamp items as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listRequestLatenciesAsync(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String contentSafetyOperation,
            String aggregation,
            RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedFlux<>(
                () ->
                        listRequestLatenciesSinglePageAsync(
                                start,
                                end,
                                granularity,
                                contentSafetyVersion,
                                contentSafetyOperation,
                                aggregation,
                                requestOptions),
                nextLink -> listRequestLatenciesNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * List API Request Latencies At Different Timestamps Given A Time Range.
     *
     * <p>List API request latencies at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     latency: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'. Allowed
     *     values: "AnalyzeText", "AnalyzeImage", "AnalyzeImageWithText".
     * @param aggregation Aggregation method of the latency, the value could be 'Percentile99', 'Percentile95',
     *     'Average'. Allowed values: "P99", "P95", "Avg".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of LatencyPerTimestamp items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listRequestLatenciesSinglePage(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String contentSafetyOperation,
            String aggregation,
            RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listRequestLatenciesSync(
                        this.getEndpoint(),
                        this.getServiceVersion().getVersion(),
                        start,
                        end,
                        granularity,
                        contentSafetyVersion,
                        contentSafetyOperation,
                        aggregation,
                        accept,
                        requestOptions,
                        Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                getNextLink(res.getValue(), "nextLink"),
                null);
    }

    /**
     * List API Request Latencies At Different Timestamps Given A Time Range.
     *
     * <p>List API request latencies at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     latency: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'. Allowed
     *     values: "AnalyzeText", "AnalyzeImage", "AnalyzeImageWithText".
     * @param aggregation Aggregation method of the latency, the value could be 'Percentile99', 'Percentile95',
     *     'Average'. Allowed values: "P99", "P95", "Avg".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of LatencyPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listRequestLatencies(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String contentSafetyOperation,
            String aggregation,
            RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedIterable<>(
                () ->
                        listRequestLatenciesSinglePage(
                                start,
                                end,
                                granularity,
                                contentSafetyVersion,
                                contentSafetyOperation,
                                aggregation,
                                requestOptions),
                nextLink -> listRequestLatenciesNextSinglePage(nextLink, requestOptionsForNextPage));
    }

    /**
     * List API Request Count At Different Timestamps Of A Specific Category Given A Time Range.
     *
     * <p>List API request count at different timestamps of a specific category given a time range.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count (Required): [
     *          (Required){
     *             severity: String(0/2/4/6) (Required)
     *             severityCount: int (Required)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param category The category of the API. The value could be Hate, Sexual, Violence, Self-Harm. Allowed values:
     *     "Hate", "Sexual", "Violence", "SelfHarm".
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param modality Modality type, the value could be 'Text', 'Image'. Allowed values: "Text", "Image",
     *     "ImageWithText".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of RequestCountsPerTimestamp items along with {@link PagedResponse} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listRequestCountsByCategoryAndSeveritySinglePageAsync(
            String category,
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String modality,
            RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listRequestCountsByCategoryAndSeverity(
                                        this.getEndpoint(),
                                        this.getServiceVersion().getVersion(),
                                        category,
                                        start,
                                        end,
                                        granularity,
                                        contentSafetyVersion,
                                        modality,
                                        accept,
                                        requestOptions,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * List API Request Count At Different Timestamps Of A Specific Category Given A Time Range.
     *
     * <p>List API request count at different timestamps of a specific category given a time range.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count (Required): [
     *          (Required){
     *             severity: String(0/2/4/6) (Required)
     *             severityCount: int (Required)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param category The category of the API. The value could be Hate, Sexual, Violence, Self-Harm. Allowed values:
     *     "Hate", "Sexual", "Violence", "SelfHarm".
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param modality Modality type, the value could be 'Text', 'Image'. Allowed values: "Text", "Image",
     *     "ImageWithText".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of RequestCountsPerTimestamp items as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listRequestCountsByCategoryAndSeverityAsync(
            String category,
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String modality,
            RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedFlux<>(
                () ->
                        listRequestCountsByCategoryAndSeveritySinglePageAsync(
                                category, start, end, granularity, contentSafetyVersion, modality, requestOptions),
                nextLink ->
                        listRequestCountsByCategoryAndSeverityNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * List API Request Count At Different Timestamps Of A Specific Category Given A Time Range.
     *
     * <p>List API request count at different timestamps of a specific category given a time range.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count (Required): [
     *          (Required){
     *             severity: String(0/2/4/6) (Required)
     *             severityCount: int (Required)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param category The category of the API. The value could be Hate, Sexual, Violence, Self-Harm. Allowed values:
     *     "Hate", "Sexual", "Violence", "SelfHarm".
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param modality Modality type, the value could be 'Text', 'Image'. Allowed values: "Text", "Image",
     *     "ImageWithText".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of RequestCountsPerTimestamp items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listRequestCountsByCategoryAndSeveritySinglePage(
            String category,
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String modality,
            RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listRequestCountsByCategoryAndSeveritySync(
                        this.getEndpoint(),
                        this.getServiceVersion().getVersion(),
                        category,
                        start,
                        end,
                        granularity,
                        contentSafetyVersion,
                        modality,
                        accept,
                        requestOptions,
                        Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                getNextLink(res.getValue(), "nextLink"),
                null);
    }

    /**
     * List API Request Count At Different Timestamps Of A Specific Category Given A Time Range.
     *
     * <p>List API request count at different timestamps of a specific category given a time range.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count (Required): [
     *          (Required){
     *             severity: String(0/2/4/6) (Required)
     *             severityCount: int (Required)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param category The category of the API. The value could be Hate, Sexual, Violence, Self-Harm. Allowed values:
     *     "Hate", "Sexual", "Violence", "SelfHarm".
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param modality Modality type, the value could be 'Text', 'Image'. Allowed values: "Text", "Image",
     *     "ImageWithText".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of RequestCountsPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listRequestCountsByCategoryAndSeverity(
            String category,
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String modality,
            RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedIterable<>(
                () ->
                        listRequestCountsByCategoryAndSeveritySinglePage(
                                category, start, end, granularity, contentSafetyVersion, modality, requestOptions),
                nextLink -> listRequestCountsByCategoryAndSeverityNextSinglePage(nextLink, requestOptionsForNextPage));
    }

    /**
     * List Top Terms Hit In Blocklist At Different Timestamps.
     *
     * <p>List top terms hit in blocklist at different timestamps.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     term: String (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param top The number of result items to return.
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of listing hit terms along with {@link PagedResponse} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listBlocklistTopTermsSinglePageAsync(
            int top,
            OffsetDateTime start,
            OffsetDateTime end,
            String contentSafetyVersion,
            RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listBlocklistTopTerms(
                                        this.getEndpoint(),
                                        this.getServiceVersion().getVersion(),
                                        top,
                                        start,
                                        end,
                                        contentSafetyVersion,
                                        accept,
                                        requestOptions,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        null,
                                        null));
    }

    /**
     * List Top Terms Hit In Blocklist At Different Timestamps.
     *
     * <p>List top terms hit in blocklist at different timestamps.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     term: String (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param top The number of result items to return.
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of listing hit terms as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listBlocklistTopTermsAsync(
            int top,
            OffsetDateTime start,
            OffsetDateTime end,
            String contentSafetyVersion,
            RequestOptions requestOptions) {
        return new PagedFlux<>(
                () -> listBlocklistTopTermsSinglePageAsync(top, start, end, contentSafetyVersion, requestOptions));
    }

    /**
     * List Top Terms Hit In Blocklist At Different Timestamps.
     *
     * <p>List top terms hit in blocklist at different timestamps.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     term: String (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param top The number of result items to return.
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of listing hit terms along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listBlocklistTopTermsSinglePage(
            int top,
            OffsetDateTime start,
            OffsetDateTime end,
            String contentSafetyVersion,
            RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listBlocklistTopTermsSync(
                        this.getEndpoint(),
                        this.getServiceVersion().getVersion(),
                        top,
                        start,
                        end,
                        contentSafetyVersion,
                        accept,
                        requestOptions,
                        Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                null,
                null);
    }

    /**
     * List Top Terms Hit In Blocklist At Different Timestamps.
     *
     * <p>List top terms hit in blocklist at different timestamps.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     term: String (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param top The number of result items to return.
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of listing hit terms as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listBlocklistTopTerms(
            int top,
            OffsetDateTime start,
            OffsetDateTime end,
            String contentSafetyVersion,
            RequestOptions requestOptions) {
        return new PagedIterable<>(
                () -> listBlocklistTopTermsSinglePage(top, start, end, contentSafetyVersion, requestOptions));
    }

    /**
     * Show Blocklist Hit Request Count At Different Timestamps.
     *
     * <p>Show blocklist hit request count at different timestamps.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of BlockListHitCallsPerTimestamp items along with {@link PagedResponse} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listBlocklistHitCallsSinglePageAsync(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listBlocklistHitCalls(
                                        this.getEndpoint(),
                                        this.getServiceVersion().getVersion(),
                                        start,
                                        end,
                                        granularity,
                                        contentSafetyVersion,
                                        accept,
                                        requestOptions,
                                        context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * Show Blocklist Hit Request Count At Different Timestamps.
     *
     * <p>Show blocklist hit request count at different timestamps.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of BlockListHitCallsPerTimestamp items as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> listBlocklistHitCallsAsync(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedFlux<>(
                () ->
                        listBlocklistHitCallsSinglePageAsync(
                                start, end, granularity, contentSafetyVersion, requestOptions),
                nextLink -> listBlocklistHitCallsNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * Show Blocklist Hit Request Count At Different Timestamps.
     *
     * <p>Show blocklist hit request count at different timestamps.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of BlockListHitCallsPerTimestamp items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listBlocklistHitCallsSinglePage(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listBlocklistHitCallsSync(
                        this.getEndpoint(),
                        this.getServiceVersion().getVersion(),
                        start,
                        end,
                        granularity,
                        contentSafetyVersion,
                        accept,
                        requestOptions,
                        Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                getNextLink(res.getValue(), "nextLink"),
                null);
    }

    /**
     * Show Blocklist Hit Request Count At Different Timestamps.
     *
     * <p>Show blocklist hit request count at different timestamps.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of BlockListHitCallsPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listBlocklistHitCalls(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedIterable<>(
                () -> listBlocklistHitCallsSinglePage(start, end, granularity, contentSafetyVersion, requestOptions),
                nextLink -> listBlocklistHitCallsNextSinglePage(nextLink, requestOptionsForNextPage));
    }

    /**
     * List API Request Counts At Different Timestamps Given A Time Range.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of CountPerTimestamp items along with {@link PagedResponse} on successful completion of
     *     {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listRequestCountsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listRequestCountsNext(
                                        nextLink, this.getEndpoint(), accept, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * List API Request Counts At Different Timestamps Given A Time Range.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of CountPerTimestamp items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listRequestCountsNextSinglePage(String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listRequestCountsNextSync(nextLink, this.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                getNextLink(res.getValue(), "nextLink"),
                null);
    }

    /**
     * List API Request Latencies At Different Timestamps Given A Time Range.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     latency: int (Required)
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of LatencyPerTimestamp items along with {@link PagedResponse} on successful completion
     *     of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listRequestLatenciesNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listRequestLatenciesNext(
                                        nextLink, this.getEndpoint(), accept, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * List API Request Latencies At Different Timestamps Given A Time Range.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     latency: int (Required)
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of LatencyPerTimestamp items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listRequestLatenciesNextSinglePage(
            String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listRequestLatenciesNextSync(
                        nextLink, this.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                getNextLink(res.getValue(), "nextLink"),
                null);
    }

    /**
     * List API Request Count At Different Timestamps Of A Specific Category Given A Time Range.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count (Required): [
     *          (Required){
     *             severity: String(0/2/4/6) (Required)
     *             severityCount: int (Required)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of RequestCountsPerTimestamp items along with {@link PagedResponse} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listRequestCountsByCategoryAndSeverityNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listRequestCountsByCategoryAndSeverityNext(
                                        nextLink, this.getEndpoint(), accept, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * List API Request Count At Different Timestamps Of A Specific Category Given A Time Range.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count (Required): [
     *          (Required){
     *             severity: String(0/2/4/6) (Required)
     *             severityCount: int (Required)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of RequestCountsPerTimestamp items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listRequestCountsByCategoryAndSeverityNextSinglePage(
            String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listRequestCountsByCategoryAndSeverityNextSync(
                        nextLink, this.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                getNextLink(res.getValue(), "nextLink"),
                null);
    }

    /**
     * Show Blocklist Hit Request Count At Different Timestamps.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of BlockListHitCallsPerTimestamp items along with {@link PagedResponse} on successful
     *     completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private Mono<PagedResponse<BinaryData>> listBlocklistHitCallsNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
                        context ->
                                service.listBlocklistHitCallsNext(
                                        nextLink, this.getEndpoint(), accept, requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "nextLink"),
                                        null));
    }

    /**
     * Show Blocklist Hit Request Count At Different Timestamps.
     *
     * <p>Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param nextLink The URL to get the next list of items
     *     <p>The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of BlockListHitCallsPerTimestamp items along with {@link PagedResponse}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    private PagedResponse<BinaryData> listBlocklistHitCallsNextSinglePage(
            String nextLink, RequestOptions requestOptions) {
        final String accept = "application/json";
        Response<BinaryData> res =
                service.listBlocklistHitCallsNextSync(
                        nextLink, this.getEndpoint(), accept, requestOptions, Context.NONE);
        return new PagedResponseBase<>(
                res.getRequest(),
                res.getStatusCode(),
                res.getHeaders(),
                getValues(res.getValue(), "value"),
                getNextLink(res.getValue(), "nextLink"),
                null);
    }

    private List<BinaryData> getValues(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            List<?> values = (List<?>) obj.get(path);
            return values.stream().map(BinaryData::fromObject).collect(Collectors.toList());
        } catch (RuntimeException e) {
            return null;
        }
    }

    private String getNextLink(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            return (String) obj.get(path);
        } catch (RuntimeException e) {
            return null;
        }
    }
}
