// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.ai.contentsafetyinternal;

import com.azure.ai.contentsafetyinternal.implementation.ContentSafetyInternalClientImpl;
import com.azure.ai.contentsafetyinternal.models.Aggregation;
import com.azure.ai.contentsafetyinternal.models.BlockListHitCallsPerTimestamp;
import com.azure.ai.contentsafetyinternal.models.CategoryEnum;
import com.azure.ai.contentsafetyinternal.models.ContentModality;
import com.azure.ai.contentsafetyinternal.models.ContentSafetyOperation;
import com.azure.ai.contentsafetyinternal.models.ContentSafetyVersion;
import com.azure.ai.contentsafetyinternal.models.CountPerTimestamp;
import com.azure.ai.contentsafetyinternal.models.FeatureList;
import com.azure.ai.contentsafetyinternal.models.Granularity;
import com.azure.ai.contentsafetyinternal.models.LatencyPerTimestamp;
import com.azure.ai.contentsafetyinternal.models.RequestCountsPerTimestamp;
import com.azure.ai.contentsafetyinternal.models.TopTermCount;
import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import java.time.OffsetDateTime;

/** Initializes a new instance of the synchronous ContentSafetyInternalClient type. */
@ServiceClient(builder = ContentSafetyInternalClientBuilder.class)
public final class ContentSafetyInternalClient {
    @Generated private final ContentSafetyInternalClientImpl serviceClient;

    /**
     * Initializes an instance of ContentSafetyInternalClient class.
     *
     * @param serviceClient the service client implementation.
     */
    @Generated
    ContentSafetyInternalClient(ContentSafetyInternalClientImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * List Whitelist Features.
     *
     * <p>Get whitelist features.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value (Required): [
     *          (Required){
     *             featureName: String (Required)
     *             properties (Required): {
     *             }
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return whitelist features along with {@link Response}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> listWritelistFeaturesWithResponse(RequestOptions requestOptions) {
        return this.serviceClient.listWritelistFeaturesWithResponse(requestOptions);
    }

    /**
     * List API Request Counts At Different Timestamps Given A Time Range.
     *
     * <p>List API request counts at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'. Allowed
     *     values: "AnalyzeText", "AnalyzeImage", "AnalyzeImageWithText".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of CountPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listRequestCounts(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String contentSafetyOperation,
            RequestOptions requestOptions) {
        return this.serviceClient.listRequestCounts(
                start, end, granularity, contentSafetyVersion, contentSafetyOperation, requestOptions);
    }

    /**
     * List API Request Latencies At Different Timestamps Given A Time Range.
     *
     * <p>List API request latencies at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     latency: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'. Allowed
     *     values: "AnalyzeText", "AnalyzeImage", "AnalyzeImageWithText".
     * @param aggregation Aggregation method of the latency, the value could be 'Percentile99', 'Percentile95',
     *     'Average'. Allowed values: "P99", "P95", "Avg".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of LatencyPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listRequestLatencies(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String contentSafetyOperation,
            String aggregation,
            RequestOptions requestOptions) {
        return this.serviceClient.listRequestLatencies(
                start, end, granularity, contentSafetyVersion, contentSafetyOperation, aggregation, requestOptions);
    }

    /**
     * List API Request Count At Different Timestamps Of A Specific Category Given A Time Range.
     *
     * <p>List API request count at different timestamps of a specific category given a time range.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count (Required): [
     *          (Required){
     *             severity: String(0/2/4/6) (Required)
     *             severityCount: int (Required)
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param category The category of the API. The value could be Hate, Sexual, Violence, Self-Harm. Allowed values:
     *     "Hate", "Sexual", "Violence", "SelfHarm".
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param modality Modality type, the value could be 'Text', 'Image'. Allowed values: "Text", "Image",
     *     "ImageWithText".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of RequestCountsPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listRequestCountsByCategoryAndSeverity(
            String category,
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            String modality,
            RequestOptions requestOptions) {
        return this.serviceClient.listRequestCountsByCategoryAndSeverity(
                category, start, end, granularity, contentSafetyVersion, modality, requestOptions);
    }

    /**
     * List Top Terms Hit In Blocklist At Different Timestamps.
     *
     * <p>List top terms hit in blocklist at different timestamps.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     term: String (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param top The number of result items to return.
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response of listing hit terms as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listBlocklistTopTerms(
            int top,
            OffsetDateTime start,
            OffsetDateTime end,
            String contentSafetyVersion,
            RequestOptions requestOptions) {
        return this.serviceClient.listBlocklistTopTerms(top, start, end, contentSafetyVersion, requestOptions);
    }

    /**
     * Show Blocklist Hit Request Count At Different Timestamps.
     *
     * <p>Show blocklist hit request count at different timestamps.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>skip</td><td>Integer</td><td>No</td><td>The number of result items to skip.</td></tr>
     *     <tr><td>top</td><td>Integer</td><td>No</td><td>The number of result items to return.</td></tr>
     *     <tr><td>maxpagesize</td><td>Integer</td><td>No</td><td>The maximum number of result items per page.</td></tr>
     * </table>
     *
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     dateTime: OffsetDateTime (Required)
     *     count: int (Required)
     * }
     * }</pre>
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'. Allowed values: "Hourly", "Daily".
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'. Allowed values:
     *     "2023-04-30-preview", "2023-05-30-preview", "2023-10-01".
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return paged collection of BlockListHitCallsPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> listBlocklistHitCalls(
            OffsetDateTime start,
            OffsetDateTime end,
            String granularity,
            String contentSafetyVersion,
            RequestOptions requestOptions) {
        return this.serviceClient.listBlocklistHitCalls(start, end, granularity, contentSafetyVersion, requestOptions);
    }

    /**
     * List Whitelist Features.
     *
     * <p>Get whitelist features.
     *
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return whitelist features.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public FeatureList listWritelistFeatures() {
        // Generated convenience method for listWritelistFeaturesWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return listWritelistFeaturesWithResponse(requestOptions).getValue().toObject(FeatureList.class);
    }

    /**
     * List API Request Counts At Different Timestamps Given A Time Range.
     *
     * <p>List API request counts at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'.
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'.
     * @param skip The number of result items to skip.
     * @param top The number of result items to return.
     * @param maxPageSize The maximum number of result items per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of CountPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<CountPerTimestamp> listRequestCounts(
            OffsetDateTime start,
            OffsetDateTime end,
            Granularity granularity,
            ContentSafetyVersion contentSafetyVersion,
            ContentSafetyOperation contentSafetyOperation,
            Integer skip,
            Integer top,
            Integer maxPageSize) {
        // Generated convenience method for listRequestCounts
        RequestOptions requestOptions = new RequestOptions();
        if (skip != null) {
            requestOptions.addQueryParam("skip", String.valueOf(skip), false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        if (maxPageSize != null) {
            requestOptions.addQueryParam("maxpagesize", String.valueOf(maxPageSize), false);
        }
        return serviceClient
                .listRequestCounts(
                        start,
                        end,
                        granularity.toString(),
                        contentSafetyVersion.toString(),
                        contentSafetyOperation.toString(),
                        requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(CountPerTimestamp.class));
    }

    /**
     * List API Request Counts At Different Timestamps Given A Time Range.
     *
     * <p>List API request counts at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'.
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of CountPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<CountPerTimestamp> listRequestCounts(
            OffsetDateTime start,
            OffsetDateTime end,
            Granularity granularity,
            ContentSafetyVersion contentSafetyVersion,
            ContentSafetyOperation contentSafetyOperation) {
        // Generated convenience method for listRequestCounts
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient
                .listRequestCounts(
                        start,
                        end,
                        granularity.toString(),
                        contentSafetyVersion.toString(),
                        contentSafetyOperation.toString(),
                        requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(CountPerTimestamp.class));
    }

    /**
     * List API Request Latencies At Different Timestamps Given A Time Range.
     *
     * <p>List API request latencies at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'.
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'.
     * @param aggregation Aggregation method of the latency, the value could be 'Percentile99', 'Percentile95',
     *     'Average'.
     * @param skip The number of result items to skip.
     * @param top The number of result items to return.
     * @param maxPageSize The maximum number of result items per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of LatencyPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<LatencyPerTimestamp> listRequestLatencies(
            OffsetDateTime start,
            OffsetDateTime end,
            Granularity granularity,
            ContentSafetyVersion contentSafetyVersion,
            ContentSafetyOperation contentSafetyOperation,
            Aggregation aggregation,
            Integer skip,
            Integer top,
            Integer maxPageSize) {
        // Generated convenience method for listRequestLatencies
        RequestOptions requestOptions = new RequestOptions();
        if (skip != null) {
            requestOptions.addQueryParam("skip", String.valueOf(skip), false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        if (maxPageSize != null) {
            requestOptions.addQueryParam("maxpagesize", String.valueOf(maxPageSize), false);
        }
        return serviceClient
                .listRequestLatencies(
                        start,
                        end,
                        granularity.toString(),
                        contentSafetyVersion.toString(),
                        contentSafetyOperation.toString(),
                        aggregation.toString(),
                        requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(LatencyPerTimestamp.class));
    }

    /**
     * List API Request Latencies At Different Timestamps Given A Time Range.
     *
     * <p>List API request latencies at different timestamps given a time range. Default maxpagesize is 1000.
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'.
     * @param contentSafetyOperation Content safety operation, the value could be 'AnalyzeText', 'AnalyzeImage'.
     * @param aggregation Aggregation method of the latency, the value could be 'Percentile99', 'Percentile95',
     *     'Average'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of LatencyPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<LatencyPerTimestamp> listRequestLatencies(
            OffsetDateTime start,
            OffsetDateTime end,
            Granularity granularity,
            ContentSafetyVersion contentSafetyVersion,
            ContentSafetyOperation contentSafetyOperation,
            Aggregation aggregation) {
        // Generated convenience method for listRequestLatencies
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient
                .listRequestLatencies(
                        start,
                        end,
                        granularity.toString(),
                        contentSafetyVersion.toString(),
                        contentSafetyOperation.toString(),
                        aggregation.toString(),
                        requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(LatencyPerTimestamp.class));
    }

    /**
     * List API Request Count At Different Timestamps Of A Specific Category Given A Time Range.
     *
     * <p>List API request count at different timestamps of a specific category given a time range.
     *
     * @param category The category of the API. The value could be Hate, Sexual, Violence, Self-Harm.
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'.
     * @param modality Modality type, the value could be 'Text', 'Image'.
     * @param top The number of result items to return.
     * @param skip The number of result items to skip.
     * @param maxPageSize The maximum number of result items per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of RequestCountsPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RequestCountsPerTimestamp> listRequestCountsByCategoryAndSeverity(
            CategoryEnum category,
            OffsetDateTime start,
            OffsetDateTime end,
            Granularity granularity,
            ContentSafetyVersion contentSafetyVersion,
            ContentModality modality,
            Integer top,
            Integer skip,
            Integer maxPageSize) {
        // Generated convenience method for listRequestCountsByCategoryAndSeverity
        RequestOptions requestOptions = new RequestOptions();
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        if (skip != null) {
            requestOptions.addQueryParam("skip", String.valueOf(skip), false);
        }
        if (maxPageSize != null) {
            requestOptions.addQueryParam("maxpagesize", String.valueOf(maxPageSize), false);
        }
        return serviceClient
                .listRequestCountsByCategoryAndSeverity(
                        category.toString(),
                        start,
                        end,
                        granularity.toString(),
                        contentSafetyVersion.toString(),
                        modality.toString(),
                        requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(RequestCountsPerTimestamp.class));
    }

    /**
     * List API Request Count At Different Timestamps Of A Specific Category Given A Time Range.
     *
     * <p>List API request count at different timestamps of a specific category given a time range.
     *
     * @param category The category of the API. The value could be Hate, Sexual, Violence, Self-Harm.
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'.
     * @param modality Modality type, the value could be 'Text', 'Image'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of RequestCountsPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<RequestCountsPerTimestamp> listRequestCountsByCategoryAndSeverity(
            CategoryEnum category,
            OffsetDateTime start,
            OffsetDateTime end,
            Granularity granularity,
            ContentSafetyVersion contentSafetyVersion,
            ContentModality modality) {
        // Generated convenience method for listRequestCountsByCategoryAndSeverity
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient
                .listRequestCountsByCategoryAndSeverity(
                        category.toString(),
                        start,
                        end,
                        granularity.toString(),
                        contentSafetyVersion.toString(),
                        modality.toString(),
                        requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(RequestCountsPerTimestamp.class));
    }

    /**
     * List Top Terms Hit In Blocklist At Different Timestamps.
     *
     * <p>List top terms hit in blocklist at different timestamps.
     *
     * @param top The number of result items to return.
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response of listing hit terms as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<TopTermCount> listBlocklistTopTerms(
            int top, OffsetDateTime start, OffsetDateTime end, ContentSafetyVersion contentSafetyVersion) {
        // Generated convenience method for listBlocklistTopTerms
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient
                .listBlocklistTopTerms(top, start, end, contentSafetyVersion.toString(), requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(TopTermCount.class));
    }

    /**
     * Show Blocklist Hit Request Count At Different Timestamps.
     *
     * <p>Show blocklist hit request count at different timestamps.
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'.
     * @param skip The number of result items to skip.
     * @param top The number of result items to return.
     * @param maxPageSize The maximum number of result items per page.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of BlockListHitCallsPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BlockListHitCallsPerTimestamp> listBlocklistHitCalls(
            OffsetDateTime start,
            OffsetDateTime end,
            Granularity granularity,
            ContentSafetyVersion contentSafetyVersion,
            Integer skip,
            Integer top,
            Integer maxPageSize) {
        // Generated convenience method for listBlocklistHitCalls
        RequestOptions requestOptions = new RequestOptions();
        if (skip != null) {
            requestOptions.addQueryParam("skip", String.valueOf(skip), false);
        }
        if (top != null) {
            requestOptions.addQueryParam("top", String.valueOf(top), false);
        }
        if (maxPageSize != null) {
            requestOptions.addQueryParam("maxpagesize", String.valueOf(maxPageSize), false);
        }
        return serviceClient
                .listBlocklistHitCalls(
                        start, end, granularity.toString(), contentSafetyVersion.toString(), requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(BlockListHitCallsPerTimestamp.class));
    }

    /**
     * Show Blocklist Hit Request Count At Different Timestamps.
     *
     * <p>Show blocklist hit request count at different timestamps.
     *
     * @param start Start date time inclusive.
     * @param end End date time inclusive.
     * @param granularity Granularity, the value could be 'Hourly', 'Daily'.
     * @param contentSafetyVersion API version of the call, the value could be '2023-04-30-preview'.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return paged collection of BlockListHitCallsPerTimestamp items as paginated response with {@link PagedIterable}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BlockListHitCallsPerTimestamp> listBlocklistHitCalls(
            OffsetDateTime start,
            OffsetDateTime end,
            Granularity granularity,
            ContentSafetyVersion contentSafetyVersion) {
        // Generated convenience method for listBlocklistHitCalls
        RequestOptions requestOptions = new RequestOptions();
        return serviceClient
                .listBlocklistHitCalls(
                        start, end, granularity.toString(), contentSafetyVersion.toString(), requestOptions)
                .mapPage(bodyItemValue -> bodyItemValue.toObject(BlockListHitCallsPerTimestamp.class));
    }
}
