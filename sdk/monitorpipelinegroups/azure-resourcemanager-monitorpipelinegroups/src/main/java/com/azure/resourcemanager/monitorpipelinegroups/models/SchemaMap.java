// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.monitorpipelinegroups.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Schema map for azure monitor for logs.
 */
@Fluent
public final class SchemaMap implements JsonSerializable<SchemaMap> {
    /*
     * Record Map.
     */
    private List<RecordMap> recordMap;

    /*
     * Resource Map captures information about the entity for which telemetry is recorded. For example, metrics exposed
     * by a Kubernetes container can be linked to a resource that specifies the cluster, namespace, pod, and container
     * name.Resource may capture an entire hierarchy of entity identification. It may describe the host in the cloud and
     * specific container or an application running in the process.
     */
    private List<ResourceMap> resourceMap;

    /*
     * A scope map is a logical unit of the application code with which the emitted telemetry can be associated.
     */
    private List<ScopeMap> scopeMap;

    /**
     * Creates an instance of SchemaMap class.
     */
    public SchemaMap() {
    }

    /**
     * Get the recordMap property: Record Map.
     * 
     * @return the recordMap value.
     */
    public List<RecordMap> recordMap() {
        return this.recordMap;
    }

    /**
     * Set the recordMap property: Record Map.
     * 
     * @param recordMap the recordMap value to set.
     * @return the SchemaMap object itself.
     */
    public SchemaMap withRecordMap(List<RecordMap> recordMap) {
        this.recordMap = recordMap;
        return this;
    }

    /**
     * Get the resourceMap property: Resource Map captures information about the entity for which telemetry is recorded.
     * For example, metrics exposed by a Kubernetes container can be linked to a resource that specifies the cluster,
     * namespace, pod, and container name.Resource may capture an entire hierarchy of entity identification. It may
     * describe the host in the cloud and specific container or an application running in the process.
     * 
     * @return the resourceMap value.
     */
    public List<ResourceMap> resourceMap() {
        return this.resourceMap;
    }

    /**
     * Set the resourceMap property: Resource Map captures information about the entity for which telemetry is recorded.
     * For example, metrics exposed by a Kubernetes container can be linked to a resource that specifies the cluster,
     * namespace, pod, and container name.Resource may capture an entire hierarchy of entity identification. It may
     * describe the host in the cloud and specific container or an application running in the process.
     * 
     * @param resourceMap the resourceMap value to set.
     * @return the SchemaMap object itself.
     */
    public SchemaMap withResourceMap(List<ResourceMap> resourceMap) {
        this.resourceMap = resourceMap;
        return this;
    }

    /**
     * Get the scopeMap property: A scope map is a logical unit of the application code with which the emitted telemetry
     * can be associated.
     * 
     * @return the scopeMap value.
     */
    public List<ScopeMap> scopeMap() {
        return this.scopeMap;
    }

    /**
     * Set the scopeMap property: A scope map is a logical unit of the application code with which the emitted telemetry
     * can be associated.
     * 
     * @param scopeMap the scopeMap value to set.
     * @return the SchemaMap object itself.
     */
    public SchemaMap withScopeMap(List<ScopeMap> scopeMap) {
        this.scopeMap = scopeMap;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (recordMap() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property recordMap in model SchemaMap"));
        } else {
            recordMap().forEach(e -> e.validate());
        }
        if (resourceMap() != null) {
            resourceMap().forEach(e -> e.validate());
        }
        if (scopeMap() != null) {
            scopeMap().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(SchemaMap.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("recordMap", this.recordMap, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("resourceMap", this.resourceMap, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("scopeMap", this.scopeMap, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SchemaMap from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SchemaMap if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the SchemaMap.
     */
    public static SchemaMap fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SchemaMap deserializedSchemaMap = new SchemaMap();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("recordMap".equals(fieldName)) {
                    List<RecordMap> recordMap = reader.readArray(reader1 -> RecordMap.fromJson(reader1));
                    deserializedSchemaMap.recordMap = recordMap;
                } else if ("resourceMap".equals(fieldName)) {
                    List<ResourceMap> resourceMap = reader.readArray(reader1 -> ResourceMap.fromJson(reader1));
                    deserializedSchemaMap.resourceMap = resourceMap;
                } else if ("scopeMap".equals(fieldName)) {
                    List<ScopeMap> scopeMap = reader.readArray(reader1 -> ScopeMap.fromJson(reader1));
                    deserializedSchemaMap.scopeMap = scopeMap;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSchemaMap;
        });
    }
}
