// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.oracledatabase.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.List;

/**
 * Autonomous Database Cross Region Disaster Recovery resource model.
 */
@Fluent
public final class AutonomousDatabaseCrossRegionDisasterRecoveryProperties extends AutonomousDatabaseBaseProperties {
    /*
     * Database type to be created.
     */
    private DataBaseType dataBaseType = DataBaseType.CROSS_REGION_DISASTER_RECOVERY;

    /*
     * The source of the database.
     */
    private final String source = "CrossRegionDisasterRecovery";

    /*
     * The Azure resource ID of the source Autonomous Database that will be used to create a new peer database for the
     * DR association.
     */
    private String sourceId;

    /*
     * The name of the region where source Autonomous Database exists.
     */
    private String sourceLocation;

    /*
     * The source database ocid
     */
    private String sourceOcid;

    /*
     * Indicates the cross-region disaster recovery (DR) type of the standby Autonomous Database Serverless instance.
     * Autonomous Data Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO)
     * during failover or switchover. Backup-based DR type provides lower cost DR with a slower RTO during failover or
     * switchover.
     */
    private DisasterRecoveryType remoteDisasterRecoveryType;

    /*
     * If true, 7 days worth of backups are replicated across regions for Cross-Region ADB or Backup-Based DR between
     * Primary and Standby. If false, the backups taken on the Primary are not replicated to the Standby database.
     */
    private Boolean isReplicateAutomaticBackups;

    /*
     * Database ocid
     */
    private String ocid;

    /*
     * The amount of storage that has been used, in terabytes.
     */
    private Integer usedDataStorageSizeInTbs;

    /*
     * The storage space consumed by Autonomous Database in GBs.
     */
    private Integer usedDataStorageSizeInGbs;

    /*
     * The date and time the Always Free database will be stopped because of inactivity.
     */
    private String timeReclamationOfFreeAutonomousDatabase;

    /*
     * The timestamp of the last switchover operation for the Autonomous Database.
     */
    private String timeOfLastSwitchover;

    /*
     * The refresh point timestamp (UTC).
     */
    private String timeOfLastRefreshPoint;

    /*
     * The date and time when last refresh happened.
     */
    private String timeOfLastRefresh;

    /*
     * The timestamp of the last failover operation.
     */
    private String timeOfLastFailover;

    /*
     * The date and time that Autonomous Data Guard was enabled for an Autonomous Database where the standby was
     * provisioned in the same region as the primary database.
     */
    private String timeLocalDataGuardEnabled;

    /*
     * The date and time the Always Free database will be automatically deleted because of inactivity.
     */
    private String timeDeletionOfFreeAutonomousDatabase;

    /*
     * The date and time the Autonomous Data Guard role was switched for the Autonomous Database.
     */
    private String timeDataGuardRoleChanged;

    /*
     * The list of regions that support the creation of an Autonomous Database clone or an Autonomous Data Guard standby
     * database.
     */
    private List<String> supportedRegionsToCloneTo;

    /*
     * The SQL Web Developer URL for the Oracle Autonomous Database.
     */
    private String sqlWebDeveloperUrl;

    /*
     * The URL of the Service Console for the Autonomous Database.
     */
    private String serviceConsoleUrl;

    /*
     * An array of CPU values that an Autonomous Database can be scaled to.
     */
    private List<Integer> provisionableCpus;

    /*
     * The private endpoint for the resource.
     */
    private String privateEndpoint;

    /*
     * Status of Operations Insights for this Autonomous Database.
     */
    private OperationsInsightsStatusType operationsInsightsStatus;

    /*
     * The amount of memory (in GBs) enabled per ECPU or OCPU.
     */
    private Integer memoryPerOracleComputeUnitInGbs;

    /*
     * Indicates if the Autonomous Database version is a preview version.
     */
    private Boolean isPreview;

    /*
     * The date and time when the next long-term backup would be created.
     */
    private OffsetDateTime nextLongTermBackupTimestamp;

    /*
     * The area assigned to In-Memory tables in Autonomous Database.
     */
    private Integer inMemoryAreaInGbs;

    /*
     * Status of the Data Safe registration for this Autonomous Database.
     */
    private DataSafeStatusType dataSafeStatus;

    /*
     * The URLs for accessing Oracle Application Express (APEX) and SQL Developer Web with a browser from a Compute
     * instance within your VCN or that has a direct connection to your VCN.
     */
    private ConnectionUrlType connectionUrls;

    /*
     * The connection string used to connect to the Autonomous Database.
     */
    private ConnectionStringType connectionStrings;

    /*
     * List of Oracle Database versions available for a database upgrade. If there are no version upgrades available,
     * this list is empty.
     */
    private List<String> availableUpgradeVersions;

    /*
     * Information about Oracle APEX Application Development.
     */
    private ApexDetailsType apexDetails;

    /*
     * The amount of storage currently allocated for the database tables and billed for, rounded up.
     */
    private Double allocatedStorageSizeInTbs;

    /*
     * The current amount of storage in use for user and system data, in terabytes (TB).
     */
    private Double actualUsedDataStorageSizeInTbs;

    /*
     * The date and time when maintenance will end.
     */
    private OffsetDateTime timeMaintenanceEnd;

    /*
     * The date and time when maintenance will begin.
     */
    private OffsetDateTime timeMaintenanceBegin;

    /*
     * The date and time that the database was created.
     */
    private OffsetDateTime timeCreated;

    /*
     * HTTPS link to OCI resources exposed to Azure Customer via Azure Interface.
     */
    private String ociUrl;

    /*
     * Views lifecycleState
     */
    private AutonomousDatabaseLifecycleState lifecycleState;

    /*
     * Azure resource provisioning state.
     */
    private AzureResourceProvisioningState provisioningState;

    /*
     * Additional information about the current lifecycle state.
     */
    private String lifecycleDetails;

    /*
     * Indicates the number of seconds of data loss for a Data Guard failover.
     */
    private Integer failedDataRecoveryInSeconds;

    /*
     * Local Autonomous Disaster Recovery standby database details.
     */
    private AutonomousDatabaseStandbySummary localStandbyDb;

    /*
     * Indicates remote disaster recovery configuration
     */
    private DisasterRecoveryConfigurationDetails remoteDisasterRecoveryConfiguration;

    /*
     * The date and time the Disaster Recovery role was switched for the standby Autonomous Database.
     */
    private OffsetDateTime timeDisasterRecoveryRoleChanged;

    /*
     * Indicates the local disaster recovery (DR) type of the Autonomous Database Serverless instance.Autonomous Data
     * Guard (ADG) DR type provides business critical DR with a faster recovery time objective (RTO) during failover or
     * switchover.Backup-based DR type provides lower cost DR with a slower RTO during failover or switchover.
     */
    private DisasterRecoveryType localDisasterRecoveryType;

    /*
     * Indicates whether the Autonomous Database has Cross Region Data Guard enabled.
     */
    private Boolean isRemoteDataGuardEnabled;

    /*
     * The list of Azure resource IDs of standby databases located in Autonomous Data Guard remote regions that are
     * associated with the source database. Note that for Autonomous Database Serverless instances, standby databases
     * located in the same region as the source primary database do not have Azure IDs.
     */
    private List<String> peerDbIds;

    /**
     * Creates an instance of AutonomousDatabaseCrossRegionDisasterRecoveryProperties class.
     */
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties() {
    }

    /**
     * Get the dataBaseType property: Database type to be created.
     * 
     * @return the dataBaseType value.
     */
    @Override
    public DataBaseType dataBaseType() {
        return this.dataBaseType;
    }

    /**
     * Get the source property: The source of the database.
     * 
     * @return the source value.
     */
    public String source() {
        return this.source;
    }

    /**
     * Get the sourceId property: The Azure resource ID of the source Autonomous Database that will be used to create a
     * new peer database for the DR association.
     * 
     * @return the sourceId value.
     */
    public String sourceId() {
        return this.sourceId;
    }

    /**
     * Set the sourceId property: The Azure resource ID of the source Autonomous Database that will be used to create a
     * new peer database for the DR association.
     * 
     * @param sourceId the sourceId value to set.
     * @return the AutonomousDatabaseCrossRegionDisasterRecoveryProperties object itself.
     */
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withSourceId(String sourceId) {
        this.sourceId = sourceId;
        return this;
    }

    /**
     * Get the sourceLocation property: The name of the region where source Autonomous Database exists.
     * 
     * @return the sourceLocation value.
     */
    public String sourceLocation() {
        return this.sourceLocation;
    }

    /**
     * Set the sourceLocation property: The name of the region where source Autonomous Database exists.
     * 
     * @param sourceLocation the sourceLocation value to set.
     * @return the AutonomousDatabaseCrossRegionDisasterRecoveryProperties object itself.
     */
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withSourceLocation(String sourceLocation) {
        this.sourceLocation = sourceLocation;
        return this;
    }

    /**
     * Get the sourceOcid property: The source database ocid.
     * 
     * @return the sourceOcid value.
     */
    public String sourceOcid() {
        return this.sourceOcid;
    }

    /**
     * Set the sourceOcid property: The source database ocid.
     * 
     * @param sourceOcid the sourceOcid value to set.
     * @return the AutonomousDatabaseCrossRegionDisasterRecoveryProperties object itself.
     */
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withSourceOcid(String sourceOcid) {
        this.sourceOcid = sourceOcid;
        return this;
    }

    /**
     * Get the remoteDisasterRecoveryType property: Indicates the cross-region disaster recovery (DR) type of the
     * standby Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical
     * DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower
     * cost DR with a slower RTO during failover or switchover.
     * 
     * @return the remoteDisasterRecoveryType value.
     */
    public DisasterRecoveryType remoteDisasterRecoveryType() {
        return this.remoteDisasterRecoveryType;
    }

    /**
     * Set the remoteDisasterRecoveryType property: Indicates the cross-region disaster recovery (DR) type of the
     * standby Autonomous Database Serverless instance. Autonomous Data Guard (ADG) DR type provides business critical
     * DR with a faster recovery time objective (RTO) during failover or switchover. Backup-based DR type provides lower
     * cost DR with a slower RTO during failover or switchover.
     * 
     * @param remoteDisasterRecoveryType the remoteDisasterRecoveryType value to set.
     * @return the AutonomousDatabaseCrossRegionDisasterRecoveryProperties object itself.
     */
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withRemoteDisasterRecoveryType(DisasterRecoveryType remoteDisasterRecoveryType) {
        this.remoteDisasterRecoveryType = remoteDisasterRecoveryType;
        return this;
    }

    /**
     * Get the isReplicateAutomaticBackups property: If true, 7 days worth of backups are replicated across regions for
     * Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are
     * not replicated to the Standby database.
     * 
     * @return the isReplicateAutomaticBackups value.
     */
    public Boolean isReplicateAutomaticBackups() {
        return this.isReplicateAutomaticBackups;
    }

    /**
     * Set the isReplicateAutomaticBackups property: If true, 7 days worth of backups are replicated across regions for
     * Cross-Region ADB or Backup-Based DR between Primary and Standby. If false, the backups taken on the Primary are
     * not replicated to the Standby database.
     * 
     * @param isReplicateAutomaticBackups the isReplicateAutomaticBackups value to set.
     * @return the AutonomousDatabaseCrossRegionDisasterRecoveryProperties object itself.
     */
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withIsReplicateAutomaticBackups(Boolean isReplicateAutomaticBackups) {
        this.isReplicateAutomaticBackups = isReplicateAutomaticBackups;
        return this;
    }

    /**
     * Get the ocid property: Database ocid.
     * 
     * @return the ocid value.
     */
    @Override
    public String ocid() {
        return this.ocid;
    }

    /**
     * Get the usedDataStorageSizeInTbs property: The amount of storage that has been used, in terabytes.
     * 
     * @return the usedDataStorageSizeInTbs value.
     */
    @Override
    public Integer usedDataStorageSizeInTbs() {
        return this.usedDataStorageSizeInTbs;
    }

    /**
     * Get the usedDataStorageSizeInGbs property: The storage space consumed by Autonomous Database in GBs.
     * 
     * @return the usedDataStorageSizeInGbs value.
     */
    @Override
    public Integer usedDataStorageSizeInGbs() {
        return this.usedDataStorageSizeInGbs;
    }

    /**
     * Get the timeReclamationOfFreeAutonomousDatabase property: The date and time the Always Free database will be
     * stopped because of inactivity.
     * 
     * @return the timeReclamationOfFreeAutonomousDatabase value.
     */
    @Override
    public String timeReclamationOfFreeAutonomousDatabase() {
        return this.timeReclamationOfFreeAutonomousDatabase;
    }

    /**
     * Get the timeOfLastSwitchover property: The timestamp of the last switchover operation for the Autonomous
     * Database.
     * 
     * @return the timeOfLastSwitchover value.
     */
    @Override
    public String timeOfLastSwitchover() {
        return this.timeOfLastSwitchover;
    }

    /**
     * Get the timeOfLastRefreshPoint property: The refresh point timestamp (UTC).
     * 
     * @return the timeOfLastRefreshPoint value.
     */
    @Override
    public String timeOfLastRefreshPoint() {
        return this.timeOfLastRefreshPoint;
    }

    /**
     * Get the timeOfLastRefresh property: The date and time when last refresh happened.
     * 
     * @return the timeOfLastRefresh value.
     */
    @Override
    public String timeOfLastRefresh() {
        return this.timeOfLastRefresh;
    }

    /**
     * Get the timeOfLastFailover property: The timestamp of the last failover operation.
     * 
     * @return the timeOfLastFailover value.
     */
    @Override
    public String timeOfLastFailover() {
        return this.timeOfLastFailover;
    }

    /**
     * Get the timeLocalDataGuardEnabled property: The date and time that Autonomous Data Guard was enabled for an
     * Autonomous Database where the standby was provisioned in the same region as the primary database.
     * 
     * @return the timeLocalDataGuardEnabled value.
     */
    @Override
    public String timeLocalDataGuardEnabled() {
        return this.timeLocalDataGuardEnabled;
    }

    /**
     * Get the timeDeletionOfFreeAutonomousDatabase property: The date and time the Always Free database will be
     * automatically deleted because of inactivity.
     * 
     * @return the timeDeletionOfFreeAutonomousDatabase value.
     */
    @Override
    public String timeDeletionOfFreeAutonomousDatabase() {
        return this.timeDeletionOfFreeAutonomousDatabase;
    }

    /**
     * Get the timeDataGuardRoleChanged property: The date and time the Autonomous Data Guard role was switched for the
     * Autonomous Database.
     * 
     * @return the timeDataGuardRoleChanged value.
     */
    @Override
    public String timeDataGuardRoleChanged() {
        return this.timeDataGuardRoleChanged;
    }

    /**
     * Get the supportedRegionsToCloneTo property: The list of regions that support the creation of an Autonomous
     * Database clone or an Autonomous Data Guard standby database.
     * 
     * @return the supportedRegionsToCloneTo value.
     */
    @Override
    public List<String> supportedRegionsToCloneTo() {
        return this.supportedRegionsToCloneTo;
    }

    /**
     * Get the sqlWebDeveloperUrl property: The SQL Web Developer URL for the Oracle Autonomous Database.
     * 
     * @return the sqlWebDeveloperUrl value.
     */
    @Override
    public String sqlWebDeveloperUrl() {
        return this.sqlWebDeveloperUrl;
    }

    /**
     * Get the serviceConsoleUrl property: The URL of the Service Console for the Autonomous Database.
     * 
     * @return the serviceConsoleUrl value.
     */
    @Override
    public String serviceConsoleUrl() {
        return this.serviceConsoleUrl;
    }

    /**
     * Get the provisionableCpus property: An array of CPU values that an Autonomous Database can be scaled to.
     * 
     * @return the provisionableCpus value.
     */
    @Override
    public List<Integer> provisionableCpus() {
        return this.provisionableCpus;
    }

    /**
     * Get the privateEndpoint property: The private endpoint for the resource.
     * 
     * @return the privateEndpoint value.
     */
    @Override
    public String privateEndpoint() {
        return this.privateEndpoint;
    }

    /**
     * Get the operationsInsightsStatus property: Status of Operations Insights for this Autonomous Database.
     * 
     * @return the operationsInsightsStatus value.
     */
    @Override
    public OperationsInsightsStatusType operationsInsightsStatus() {
        return this.operationsInsightsStatus;
    }

    /**
     * Get the memoryPerOracleComputeUnitInGbs property: The amount of memory (in GBs) enabled per ECPU or OCPU.
     * 
     * @return the memoryPerOracleComputeUnitInGbs value.
     */
    @Override
    public Integer memoryPerOracleComputeUnitInGbs() {
        return this.memoryPerOracleComputeUnitInGbs;
    }

    /**
     * Get the isPreview property: Indicates if the Autonomous Database version is a preview version.
     * 
     * @return the isPreview value.
     */
    @Override
    public Boolean isPreview() {
        return this.isPreview;
    }

    /**
     * Get the nextLongTermBackupTimestamp property: The date and time when the next long-term backup would be created.
     * 
     * @return the nextLongTermBackupTimestamp value.
     */
    @Override
    public OffsetDateTime nextLongTermBackupTimestamp() {
        return this.nextLongTermBackupTimestamp;
    }

    /**
     * Get the inMemoryAreaInGbs property: The area assigned to In-Memory tables in Autonomous Database.
     * 
     * @return the inMemoryAreaInGbs value.
     */
    @Override
    public Integer inMemoryAreaInGbs() {
        return this.inMemoryAreaInGbs;
    }

    /**
     * Get the dataSafeStatus property: Status of the Data Safe registration for this Autonomous Database.
     * 
     * @return the dataSafeStatus value.
     */
    @Override
    public DataSafeStatusType dataSafeStatus() {
        return this.dataSafeStatus;
    }

    /**
     * Get the connectionUrls property: The URLs for accessing Oracle Application Express (APEX) and SQL Developer Web
     * with a browser from a Compute instance within your VCN or that has a direct connection to your VCN.
     * 
     * @return the connectionUrls value.
     */
    @Override
    public ConnectionUrlType connectionUrls() {
        return this.connectionUrls;
    }

    /**
     * Get the connectionStrings property: The connection string used to connect to the Autonomous Database.
     * 
     * @return the connectionStrings value.
     */
    @Override
    public ConnectionStringType connectionStrings() {
        return this.connectionStrings;
    }

    /**
     * Get the availableUpgradeVersions property: List of Oracle Database versions available for a database upgrade. If
     * there are no version upgrades available, this list is empty.
     * 
     * @return the availableUpgradeVersions value.
     */
    @Override
    public List<String> availableUpgradeVersions() {
        return this.availableUpgradeVersions;
    }

    /**
     * Get the apexDetails property: Information about Oracle APEX Application Development.
     * 
     * @return the apexDetails value.
     */
    @Override
    public ApexDetailsType apexDetails() {
        return this.apexDetails;
    }

    /**
     * Get the allocatedStorageSizeInTbs property: The amount of storage currently allocated for the database tables and
     * billed for, rounded up.
     * 
     * @return the allocatedStorageSizeInTbs value.
     */
    @Override
    public Double allocatedStorageSizeInTbs() {
        return this.allocatedStorageSizeInTbs;
    }

    /**
     * Get the actualUsedDataStorageSizeInTbs property: The current amount of storage in use for user and system data,
     * in terabytes (TB).
     * 
     * @return the actualUsedDataStorageSizeInTbs value.
     */
    @Override
    public Double actualUsedDataStorageSizeInTbs() {
        return this.actualUsedDataStorageSizeInTbs;
    }

    /**
     * Get the timeMaintenanceEnd property: The date and time when maintenance will end.
     * 
     * @return the timeMaintenanceEnd value.
     */
    @Override
    public OffsetDateTime timeMaintenanceEnd() {
        return this.timeMaintenanceEnd;
    }

    /**
     * Get the timeMaintenanceBegin property: The date and time when maintenance will begin.
     * 
     * @return the timeMaintenanceBegin value.
     */
    @Override
    public OffsetDateTime timeMaintenanceBegin() {
        return this.timeMaintenanceBegin;
    }

    /**
     * Get the timeCreated property: The date and time that the database was created.
     * 
     * @return the timeCreated value.
     */
    @Override
    public OffsetDateTime timeCreated() {
        return this.timeCreated;
    }

    /**
     * Get the ociUrl property: HTTPS link to OCI resources exposed to Azure Customer via Azure Interface.
     * 
     * @return the ociUrl value.
     */
    @Override
    public String ociUrl() {
        return this.ociUrl;
    }

    /**
     * Get the lifecycleState property: Views lifecycleState.
     * 
     * @return the lifecycleState value.
     */
    @Override
    public AutonomousDatabaseLifecycleState lifecycleState() {
        return this.lifecycleState;
    }

    /**
     * Get the provisioningState property: Azure resource provisioning state.
     * 
     * @return the provisioningState value.
     */
    @Override
    public AzureResourceProvisioningState provisioningState() {
        return this.provisioningState;
    }

    /**
     * Get the lifecycleDetails property: Additional information about the current lifecycle state.
     * 
     * @return the lifecycleDetails value.
     */
    @Override
    public String lifecycleDetails() {
        return this.lifecycleDetails;
    }

    /**
     * Get the failedDataRecoveryInSeconds property: Indicates the number of seconds of data loss for a Data Guard
     * failover.
     * 
     * @return the failedDataRecoveryInSeconds value.
     */
    @Override
    public Integer failedDataRecoveryInSeconds() {
        return this.failedDataRecoveryInSeconds;
    }

    /**
     * Get the localStandbyDb property: Local Autonomous Disaster Recovery standby database details.
     * 
     * @return the localStandbyDb value.
     */
    @Override
    public AutonomousDatabaseStandbySummary localStandbyDb() {
        return this.localStandbyDb;
    }

    /**
     * Get the remoteDisasterRecoveryConfiguration property: Indicates remote disaster recovery configuration.
     * 
     * @return the remoteDisasterRecoveryConfiguration value.
     */
    @Override
    public DisasterRecoveryConfigurationDetails remoteDisasterRecoveryConfiguration() {
        return this.remoteDisasterRecoveryConfiguration;
    }

    /**
     * Get the timeDisasterRecoveryRoleChanged property: The date and time the Disaster Recovery role was switched for
     * the standby Autonomous Database.
     * 
     * @return the timeDisasterRecoveryRoleChanged value.
     */
    @Override
    public OffsetDateTime timeDisasterRecoveryRoleChanged() {
        return this.timeDisasterRecoveryRoleChanged;
    }

    /**
     * Get the localDisasterRecoveryType property: Indicates the local disaster recovery (DR) type of the Autonomous
     * Database Serverless instance.Autonomous Data Guard (ADG) DR type provides business critical DR with a faster
     * recovery time objective (RTO) during failover or switchover.Backup-based DR type provides lower cost DR with a
     * slower RTO during failover or switchover.
     * 
     * @return the localDisasterRecoveryType value.
     */
    @Override
    public DisasterRecoveryType localDisasterRecoveryType() {
        return this.localDisasterRecoveryType;
    }

    /**
     * Get the isRemoteDataGuardEnabled property: Indicates whether the Autonomous Database has Cross Region Data Guard
     * enabled.
     * 
     * @return the isRemoteDataGuardEnabled value.
     */
    @Override
    public Boolean isRemoteDataGuardEnabled() {
        return this.isRemoteDataGuardEnabled;
    }

    /**
     * Get the peerDbIds property: The list of Azure resource IDs of standby databases located in Autonomous Data Guard
     * remote regions that are associated with the source database. Note that for Autonomous Database Serverless
     * instances, standby databases located in the same region as the source primary database do not have Azure IDs.
     * 
     * @return the peerDbIds value.
     */
    @Override
    public List<String> peerDbIds() {
        return this.peerDbIds;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withAdminPassword(String adminPassword) {
        super.withAdminPassword(adminPassword);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withAutonomousMaintenanceScheduleType(AutonomousMaintenanceScheduleType autonomousMaintenanceScheduleType) {
        super.withAutonomousMaintenanceScheduleType(autonomousMaintenanceScheduleType);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withCharacterSet(String characterSet) {
        super.withCharacterSet(characterSet);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withComputeCount(Float computeCount) {
        super.withComputeCount(computeCount);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withComputeModel(ComputeModel computeModel) {
        super.withComputeModel(computeModel);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withCpuCoreCount(Integer cpuCoreCount) {
        super.withCpuCoreCount(cpuCoreCount);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withCustomerContacts(List<CustomerContact> customerContacts) {
        super.withCustomerContacts(customerContacts);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withDataStorageSizeInTbs(Integer dataStorageSizeInTbs) {
        super.withDataStorageSizeInTbs(dataStorageSizeInTbs);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withDataStorageSizeInGbs(Integer dataStorageSizeInGbs) {
        super.withDataStorageSizeInGbs(dataStorageSizeInGbs);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withDbVersion(String dbVersion) {
        super.withDbVersion(dbVersion);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withDbWorkload(WorkloadType dbWorkload) {
        super.withDbWorkload(dbWorkload);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withDisplayName(String displayName) {
        super.withDisplayName(displayName);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withIsAutoScalingEnabled(Boolean isAutoScalingEnabled) {
        super.withIsAutoScalingEnabled(isAutoScalingEnabled);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withIsAutoScalingForStorageEnabled(Boolean isAutoScalingForStorageEnabled) {
        super.withIsAutoScalingForStorageEnabled(isAutoScalingForStorageEnabled);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withPeerDbId(String peerDbId) {
        super.withPeerDbId(peerDbId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withIsLocalDataGuardEnabled(Boolean isLocalDataGuardEnabled) {
        super.withIsLocalDataGuardEnabled(isLocalDataGuardEnabled);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withIsMtlsConnectionRequired(Boolean isMtlsConnectionRequired) {
        super.withIsMtlsConnectionRequired(isMtlsConnectionRequired);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withIsPreviewVersionWithServiceTermsAccepted(Boolean isPreviewVersionWithServiceTermsAccepted) {
        super.withIsPreviewVersionWithServiceTermsAccepted(isPreviewVersionWithServiceTermsAccepted);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withLicenseModel(LicenseModel licenseModel) {
        super.withLicenseModel(licenseModel);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withNcharacterSet(String ncharacterSet) {
        super.withNcharacterSet(ncharacterSet);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withScheduledOperations(ScheduledOperationsType scheduledOperations) {
        super.withScheduledOperations(scheduledOperations);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withPrivateEndpointIp(String privateEndpointIp) {
        super.withPrivateEndpointIp(privateEndpointIp);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withPrivateEndpointLabel(String privateEndpointLabel) {
        super.withPrivateEndpointLabel(privateEndpointLabel);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withSubnetId(String subnetId) {
        super.withSubnetId(subnetId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withVnetId(String vnetId) {
        super.withVnetId(vnetId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withDatabaseEdition(DatabaseEditionType databaseEdition) {
        super.withDatabaseEdition(databaseEdition);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withAutonomousDatabaseId(String autonomousDatabaseId) {
        super.withAutonomousDatabaseId(autonomousDatabaseId);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withLongTermBackupSchedule(LongTermBackUpScheduleDetails longTermBackupSchedule) {
        super.withLongTermBackupSchedule(longTermBackupSchedule);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withLocalAdgAutoFailoverMaxDataLossLimit(Integer localAdgAutoFailoverMaxDataLossLimit) {
        super.withLocalAdgAutoFailoverMaxDataLossLimit(localAdgAutoFailoverMaxDataLossLimit);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withOpenMode(OpenModeType openMode) {
        super.withOpenMode(openMode);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withPermissionLevel(PermissionLevelType permissionLevel) {
        super.withPermissionLevel(permissionLevel);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withRole(RoleType role) {
        super.withRole(role);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties
        withBackupRetentionPeriodInDays(Integer backupRetentionPeriodInDays) {
        super.withBackupRetentionPeriodInDays(backupRetentionPeriodInDays);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public AutonomousDatabaseCrossRegionDisasterRecoveryProperties withWhitelistedIps(List<String> whitelistedIps) {
        super.withWhitelistedIps(whitelistedIps);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    @Override
    public void validate() {
        if (sourceId() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property sourceId in model AutonomousDatabaseCrossRegionDisasterRecoveryProperties"));
        }
        if (remoteDisasterRecoveryType() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property remoteDisasterRecoveryType in model AutonomousDatabaseCrossRegionDisasterRecoveryProperties"));
        }
        if (customerContacts() != null) {
            customerContacts().forEach(e -> e.validate());
        }
        if (remoteDisasterRecoveryConfiguration() != null) {
            remoteDisasterRecoveryConfiguration().validate();
        }
        if (localStandbyDb() != null) {
            localStandbyDb().validate();
        }
        if (scheduledOperations() != null) {
            scheduledOperations().validate();
        }
        if (apexDetails() != null) {
            apexDetails().validate();
        }
        if (connectionStrings() != null) {
            connectionStrings().validate();
        }
        if (connectionUrls() != null) {
            connectionUrls().validate();
        }
        if (longTermBackupSchedule() != null) {
            longTermBackupSchedule().validate();
        }
    }

    private static final ClientLogger LOGGER
        = new ClientLogger(AutonomousDatabaseCrossRegionDisasterRecoveryProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("adminPassword", adminPassword());
        jsonWriter.writeStringField("autonomousMaintenanceScheduleType",
            autonomousMaintenanceScheduleType() == null ? null : autonomousMaintenanceScheduleType().toString());
        jsonWriter.writeStringField("characterSet", characterSet());
        jsonWriter.writeNumberField("computeCount", computeCount());
        jsonWriter.writeStringField("computeModel", computeModel() == null ? null : computeModel().toString());
        jsonWriter.writeNumberField("cpuCoreCount", cpuCoreCount());
        jsonWriter.writeArrayField("customerContacts", customerContacts(),
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeNumberField("dataStorageSizeInTbs", dataStorageSizeInTbs());
        jsonWriter.writeNumberField("dataStorageSizeInGbs", dataStorageSizeInGbs());
        jsonWriter.writeStringField("dbVersion", dbVersion());
        jsonWriter.writeStringField("dbWorkload", dbWorkload() == null ? null : dbWorkload().toString());
        jsonWriter.writeStringField("displayName", displayName());
        jsonWriter.writeBooleanField("isAutoScalingEnabled", isAutoScalingEnabled());
        jsonWriter.writeBooleanField("isAutoScalingForStorageEnabled", isAutoScalingForStorageEnabled());
        jsonWriter.writeStringField("peerDbId", peerDbId());
        jsonWriter.writeBooleanField("isLocalDataGuardEnabled", isLocalDataGuardEnabled());
        jsonWriter.writeBooleanField("isMtlsConnectionRequired", isMtlsConnectionRequired());
        jsonWriter.writeBooleanField("isPreviewVersionWithServiceTermsAccepted",
            isPreviewVersionWithServiceTermsAccepted());
        jsonWriter.writeStringField("licenseModel", licenseModel() == null ? null : licenseModel().toString());
        jsonWriter.writeStringField("ncharacterSet", ncharacterSet());
        jsonWriter.writeJsonField("scheduledOperations", scheduledOperations());
        jsonWriter.writeStringField("privateEndpointIp", privateEndpointIp());
        jsonWriter.writeStringField("privateEndpointLabel", privateEndpointLabel());
        jsonWriter.writeStringField("subnetId", subnetId());
        jsonWriter.writeStringField("vnetId", vnetId());
        jsonWriter.writeStringField("databaseEdition", databaseEdition() == null ? null : databaseEdition().toString());
        jsonWriter.writeStringField("autonomousDatabaseId", autonomousDatabaseId());
        jsonWriter.writeJsonField("longTermBackupSchedule", longTermBackupSchedule());
        jsonWriter.writeNumberField("localAdgAutoFailoverMaxDataLossLimit", localAdgAutoFailoverMaxDataLossLimit());
        jsonWriter.writeStringField("openMode", openMode() == null ? null : openMode().toString());
        jsonWriter.writeStringField("permissionLevel", permissionLevel() == null ? null : permissionLevel().toString());
        jsonWriter.writeStringField("role", role() == null ? null : role().toString());
        jsonWriter.writeNumberField("backupRetentionPeriodInDays", backupRetentionPeriodInDays());
        jsonWriter.writeArrayField("whitelistedIps", whitelistedIps(),
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("source", this.source);
        jsonWriter.writeStringField("sourceId", this.sourceId);
        jsonWriter.writeStringField("remoteDisasterRecoveryType",
            this.remoteDisasterRecoveryType == null ? null : this.remoteDisasterRecoveryType.toString());
        jsonWriter.writeStringField("dataBaseType", this.dataBaseType == null ? null : this.dataBaseType.toString());
        jsonWriter.writeStringField("sourceLocation", this.sourceLocation);
        jsonWriter.writeStringField("sourceOcid", this.sourceOcid);
        jsonWriter.writeBooleanField("isReplicateAutomaticBackups", this.isReplicateAutomaticBackups);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of AutonomousDatabaseCrossRegionDisasterRecoveryProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of AutonomousDatabaseCrossRegionDisasterRecoveryProperties if the JsonReader was pointing to
     * an instance of it, or null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the AutonomousDatabaseCrossRegionDisasterRecoveryProperties.
     */
    public static AutonomousDatabaseCrossRegionDisasterRecoveryProperties fromJson(JsonReader jsonReader)
        throws IOException {
        return jsonReader.readObject(reader -> {
            AutonomousDatabaseCrossRegionDisasterRecoveryProperties deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                = new AutonomousDatabaseCrossRegionDisasterRecoveryProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("adminPassword".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withAdminPassword(reader.getString());
                } else if ("autonomousMaintenanceScheduleType".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withAutonomousMaintenanceScheduleType(
                            AutonomousMaintenanceScheduleType.fromString(reader.getString()));
                } else if ("characterSet".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withCharacterSet(reader.getString());
                } else if ("computeCount".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withComputeCount(reader.getNullable(JsonReader::getFloat));
                } else if ("computeModel".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withComputeModel(ComputeModel.fromString(reader.getString()));
                } else if ("cpuCoreCount".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withCpuCoreCount(reader.getNullable(JsonReader::getInt));
                } else if ("customerContacts".equals(fieldName)) {
                    List<CustomerContact> customerContacts
                        = reader.readArray(reader1 -> CustomerContact.fromJson(reader1));
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withCustomerContacts(customerContacts);
                } else if ("dataStorageSizeInTbs".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withDataStorageSizeInTbs(reader.getNullable(JsonReader::getInt));
                } else if ("dataStorageSizeInGbs".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withDataStorageSizeInGbs(reader.getNullable(JsonReader::getInt));
                } else if ("dbVersion".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withDbVersion(reader.getString());
                } else if ("dbWorkload".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withDbWorkload(WorkloadType.fromString(reader.getString()));
                } else if ("displayName".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withDisplayName(reader.getString());
                } else if ("isAutoScalingEnabled".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withIsAutoScalingEnabled(reader.getNullable(JsonReader::getBoolean));
                } else if ("isAutoScalingForStorageEnabled".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withIsAutoScalingForStorageEnabled(reader.getNullable(JsonReader::getBoolean));
                } else if ("peerDbIds".equals(fieldName)) {
                    List<String> peerDbIds = reader.readArray(reader1 -> reader1.getString());
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.peerDbIds = peerDbIds;
                } else if ("peerDbId".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withPeerDbId(reader.getString());
                } else if ("isLocalDataGuardEnabled".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withIsLocalDataGuardEnabled(reader.getNullable(JsonReader::getBoolean));
                } else if ("isRemoteDataGuardEnabled".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.isRemoteDataGuardEnabled
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("localDisasterRecoveryType".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.localDisasterRecoveryType
                        = DisasterRecoveryType.fromString(reader.getString());
                } else if ("timeDisasterRecoveryRoleChanged".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.timeDisasterRecoveryRoleChanged
                        = reader
                            .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("remoteDisasterRecoveryConfiguration".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.remoteDisasterRecoveryConfiguration
                        = DisasterRecoveryConfigurationDetails.fromJson(reader);
                } else if ("localStandbyDb".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.localStandbyDb
                        = AutonomousDatabaseStandbySummary.fromJson(reader);
                } else if ("failedDataRecoveryInSeconds".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.failedDataRecoveryInSeconds
                        = reader.getNullable(JsonReader::getInt);
                } else if ("isMtlsConnectionRequired".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withIsMtlsConnectionRequired(reader.getNullable(JsonReader::getBoolean));
                } else if ("isPreviewVersionWithServiceTermsAccepted".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withIsPreviewVersionWithServiceTermsAccepted(reader.getNullable(JsonReader::getBoolean));
                } else if ("licenseModel".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withLicenseModel(LicenseModel.fromString(reader.getString()));
                } else if ("ncharacterSet".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withNcharacterSet(reader.getString());
                } else if ("lifecycleDetails".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.lifecycleDetails
                        = reader.getString();
                } else if ("provisioningState".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.provisioningState
                        = AzureResourceProvisioningState.fromString(reader.getString());
                } else if ("lifecycleState".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.lifecycleState
                        = AutonomousDatabaseLifecycleState.fromString(reader.getString());
                } else if ("scheduledOperations".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withScheduledOperations(ScheduledOperationsType.fromJson(reader));
                } else if ("privateEndpointIp".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withPrivateEndpointIp(reader.getString());
                } else if ("privateEndpointLabel".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withPrivateEndpointLabel(reader.getString());
                } else if ("ociUrl".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.ociUrl = reader.getString();
                } else if ("subnetId".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withSubnetId(reader.getString());
                } else if ("vnetId".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.withVnetId(reader.getString());
                } else if ("timeCreated".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.timeCreated = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("timeMaintenanceBegin".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.timeMaintenanceBegin = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("timeMaintenanceEnd".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.timeMaintenanceEnd = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("actualUsedDataStorageSizeInTbs".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.actualUsedDataStorageSizeInTbs
                        = reader.getNullable(JsonReader::getDouble);
                } else if ("allocatedStorageSizeInTbs".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.allocatedStorageSizeInTbs
                        = reader.getNullable(JsonReader::getDouble);
                } else if ("apexDetails".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.apexDetails
                        = ApexDetailsType.fromJson(reader);
                } else if ("availableUpgradeVersions".equals(fieldName)) {
                    List<String> availableUpgradeVersions = reader.readArray(reader1 -> reader1.getString());
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.availableUpgradeVersions
                        = availableUpgradeVersions;
                } else if ("connectionStrings".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.connectionStrings
                        = ConnectionStringType.fromJson(reader);
                } else if ("connectionUrls".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.connectionUrls
                        = ConnectionUrlType.fromJson(reader);
                } else if ("dataSafeStatus".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.dataSafeStatus
                        = DataSafeStatusType.fromString(reader.getString());
                } else if ("databaseEdition".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withDatabaseEdition(DatabaseEditionType.fromString(reader.getString()));
                } else if ("autonomousDatabaseId".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withAutonomousDatabaseId(reader.getString());
                } else if ("inMemoryAreaInGbs".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.inMemoryAreaInGbs
                        = reader.getNullable(JsonReader::getInt);
                } else if ("nextLongTermBackupTimeStamp".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.nextLongTermBackupTimestamp
                        = reader
                            .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("longTermBackupSchedule".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withLongTermBackupSchedule(LongTermBackUpScheduleDetails.fromJson(reader));
                } else if ("isPreview".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.isPreview
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("localAdgAutoFailoverMaxDataLossLimit".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withLocalAdgAutoFailoverMaxDataLossLimit(reader.getNullable(JsonReader::getInt));
                } else if ("memoryPerOracleComputeUnitInGbs".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.memoryPerOracleComputeUnitInGbs
                        = reader.getNullable(JsonReader::getInt);
                } else if ("openMode".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withOpenMode(OpenModeType.fromString(reader.getString()));
                } else if ("operationsInsightsStatus".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.operationsInsightsStatus
                        = OperationsInsightsStatusType.fromString(reader.getString());
                } else if ("permissionLevel".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withPermissionLevel(PermissionLevelType.fromString(reader.getString()));
                } else if ("privateEndpoint".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.privateEndpoint
                        = reader.getString();
                } else if ("provisionableCpus".equals(fieldName)) {
                    List<Integer> provisionableCpus = reader.readArray(reader1 -> reader1.getInt());
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.provisionableCpus
                        = provisionableCpus;
                } else if ("role".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withRole(RoleType.fromString(reader.getString()));
                } else if ("serviceConsoleUrl".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.serviceConsoleUrl
                        = reader.getString();
                } else if ("sqlWebDeveloperUrl".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.sqlWebDeveloperUrl
                        = reader.getString();
                } else if ("supportedRegionsToCloneTo".equals(fieldName)) {
                    List<String> supportedRegionsToCloneTo = reader.readArray(reader1 -> reader1.getString());
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.supportedRegionsToCloneTo
                        = supportedRegionsToCloneTo;
                } else if ("timeDataGuardRoleChanged".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.timeDataGuardRoleChanged
                        = reader.getString();
                } else if ("timeDeletionOfFreeAutonomousDatabase".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.timeDeletionOfFreeAutonomousDatabase
                        = reader.getString();
                } else if ("timeLocalDataGuardEnabled".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.timeLocalDataGuardEnabled
                        = reader.getString();
                } else if ("timeOfLastFailover".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.timeOfLastFailover
                        = reader.getString();
                } else if ("timeOfLastRefresh".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.timeOfLastRefresh
                        = reader.getString();
                } else if ("timeOfLastRefreshPoint".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.timeOfLastRefreshPoint
                        = reader.getString();
                } else if ("timeOfLastSwitchover".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.timeOfLastSwitchover
                        = reader.getString();
                } else if ("timeReclamationOfFreeAutonomousDatabase".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.timeReclamationOfFreeAutonomousDatabase
                        = reader.getString();
                } else if ("usedDataStorageSizeInGbs".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.usedDataStorageSizeInGbs
                        = reader.getNullable(JsonReader::getInt);
                } else if ("usedDataStorageSizeInTbs".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.usedDataStorageSizeInTbs
                        = reader.getNullable(JsonReader::getInt);
                } else if ("ocid".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.ocid = reader.getString();
                } else if ("backupRetentionPeriodInDays".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withBackupRetentionPeriodInDays(reader.getNullable(JsonReader::getInt));
                } else if ("whitelistedIps".equals(fieldName)) {
                    List<String> whitelistedIps = reader.readArray(reader1 -> reader1.getString());
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties
                        .withWhitelistedIps(whitelistedIps);
                } else if ("sourceId".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.sourceId = reader.getString();
                } else if ("remoteDisasterRecoveryType".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.remoteDisasterRecoveryType
                        = DisasterRecoveryType.fromString(reader.getString());
                } else if ("dataBaseType".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.dataBaseType
                        = DataBaseType.fromString(reader.getString());
                } else if ("sourceLocation".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.sourceLocation
                        = reader.getString();
                } else if ("sourceOcid".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.sourceOcid = reader.getString();
                } else if ("isReplicateAutomaticBackups".equals(fieldName)) {
                    deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties.isReplicateAutomaticBackups
                        = reader.getNullable(JsonReader::getBoolean);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedAutonomousDatabaseCrossRegionDisasterRecoveryProperties;
        });
    }
}
