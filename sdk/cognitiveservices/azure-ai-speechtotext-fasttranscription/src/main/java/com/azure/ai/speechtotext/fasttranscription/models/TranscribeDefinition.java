// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.speechtotext.fasttranscription.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Metadata for a fast transcription request.
 */
@Fluent
public final class TranscribeDefinition implements JsonSerializable<TranscribeDefinition> {
    /*
     * A list of possible locales for the transcription. If not specified, the locale of the speech in the audio is
     * detected automatically from all supported locales.
     */
    @Generated
    private List<String> locales;

    /*
     * Maps some or all candidate locales to a model URI to be used for transcription. If no mapping is given, the
     * default model for the locale is used.
     */
    @Generated
    private Map<String, String> models;

    /*
     * Mode of profanity filtering.
     */
    @Generated
    private ProfanityFilterMode profanityFilterMode;

    /*
     * Mode of diarization.
     */
    @Generated
    private TranscribeDiarizationProperties diarization;

    /*
     * The 0-based indices of the channels to be transcribed separately. If not specified, multiple channels are merged
     * and transcribed jointly. Only up to two channels are supported.
     */
    @Generated
    private List<Integer> channels;

    /**
     * Creates an instance of TranscribeDefinition class.
     */
    @Generated
    public TranscribeDefinition() {
    }

    /**
     * Get the locales property: A list of possible locales for the transcription. If not specified, the locale of the
     * speech in the audio is detected automatically from all supported locales.
     * 
     * @return the locales value.
     */
    @Generated
    public List<String> getLocales() {
        return this.locales;
    }

    /**
     * Set the locales property: A list of possible locales for the transcription. If not specified, the locale of the
     * speech in the audio is detected automatically from all supported locales.
     * 
     * @param locales the locales value to set.
     * @return the TranscribeDefinition object itself.
     */
    @Generated
    public TranscribeDefinition setLocales(List<String> locales) {
        this.locales = locales;
        return this;
    }

    /**
     * Get the models property: Maps some or all candidate locales to a model URI to be used for transcription. If no
     * mapping is given, the default model for the locale is used.
     * 
     * @return the models value.
     */
    @Generated
    public Map<String, String> getModels() {
        return this.models;
    }

    /**
     * Set the models property: Maps some or all candidate locales to a model URI to be used for transcription. If no
     * mapping is given, the default model for the locale is used.
     * 
     * @param models the models value to set.
     * @return the TranscribeDefinition object itself.
     */
    @Generated
    public TranscribeDefinition setModels(Map<String, String> models) {
        this.models = models;
        return this;
    }

    /**
     * Get the profanityFilterMode property: Mode of profanity filtering.
     * 
     * @return the profanityFilterMode value.
     */
    @Generated
    public ProfanityFilterMode getProfanityFilterMode() {
        return this.profanityFilterMode;
    }

    /**
     * Set the profanityFilterMode property: Mode of profanity filtering.
     * 
     * @param profanityFilterMode the profanityFilterMode value to set.
     * @return the TranscribeDefinition object itself.
     */
    @Generated
    public TranscribeDefinition setProfanityFilterMode(ProfanityFilterMode profanityFilterMode) {
        this.profanityFilterMode = profanityFilterMode;
        return this;
    }

    /**
     * Get the diarization property: Mode of diarization.
     * 
     * @return the diarization value.
     */
    @Generated
    public TranscribeDiarizationProperties getDiarization() {
        return this.diarization;
    }

    /**
     * Set the diarization property: Mode of diarization.
     * 
     * @param diarization the diarization value to set.
     * @return the TranscribeDefinition object itself.
     */
    @Generated
    public TranscribeDefinition setDiarization(TranscribeDiarizationProperties diarization) {
        this.diarization = diarization;
        return this;
    }

    /**
     * Get the channels property: The 0-based indices of the channels to be transcribed separately. If not specified,
     * multiple channels are merged and transcribed jointly. Only up to two channels are supported.
     * 
     * @return the channels value.
     */
    @Generated
    public List<Integer> getChannels() {
        return this.channels;
    }

    /**
     * Set the channels property: The 0-based indices of the channels to be transcribed separately. If not specified,
     * multiple channels are merged and transcribed jointly. Only up to two channels are supported.
     * 
     * @param channels the channels value to set.
     * @return the TranscribeDefinition object itself.
     */
    @Generated
    public TranscribeDefinition setChannels(List<Integer> channels) {
        this.channels = channels;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("locales", this.locales, (writer, element) -> writer.writeString(element));
        jsonWriter.writeMapField("models", this.models, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("profanityFilterMode",
            this.profanityFilterMode == null ? null : this.profanityFilterMode.toString());
        jsonWriter.writeJsonField("diarization", this.diarization);
        jsonWriter.writeArrayField("channels", this.channels, (writer, element) -> writer.writeInt(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TranscribeDefinition from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TranscribeDefinition if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the TranscribeDefinition.
     */
    @Generated
    public static TranscribeDefinition fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TranscribeDefinition deserializedTranscribeDefinition = new TranscribeDefinition();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("locales".equals(fieldName)) {
                    List<String> locales = reader.readArray(reader1 -> reader1.getString());
                    deserializedTranscribeDefinition.locales = locales;
                } else if ("models".equals(fieldName)) {
                    Map<String, String> models = reader.readMap(reader1 -> reader1.getString());
                    deserializedTranscribeDefinition.models = models;
                } else if ("profanityFilterMode".equals(fieldName)) {
                    deserializedTranscribeDefinition.profanityFilterMode
                        = ProfanityFilterMode.fromString(reader.getString());
                } else if ("diarization".equals(fieldName)) {
                    deserializedTranscribeDefinition.diarization = TranscribeDiarizationProperties.fromJson(reader);
                } else if ("channels".equals(fieldName)) {
                    List<Integer> channels = reader.readArray(reader1 -> reader1.getInt());
                    deserializedTranscribeDefinition.channels = channels;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTranscribeDefinition;
        });
    }
}
