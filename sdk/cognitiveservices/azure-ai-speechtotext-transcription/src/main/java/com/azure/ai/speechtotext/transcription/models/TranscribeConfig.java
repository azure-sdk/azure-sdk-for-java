// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.speechtotext.transcription.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Metadata for a fast transcription request.
 */
@Fluent
public final class TranscribeConfig implements JsonSerializable<TranscribeConfig> {
    /*
     * A list of possible locales for the transcription. If not specified, the locale of the speech in the audio is
     * detected automatically from all supported locales.
     */
    @Generated
    private List<String> locales;

    /*
     * Maps some or all candidate locales to a model URI to be used for transcription. If no mapping is given, the
     * default model for the locale is used.
     */
    @Generated
    private Map<String, String> models;

    /*
     * Mode of profanity filtering.
     */
    @Generated
    private ProfanityFilterMode profanityFilterMode;

    /*
     * Mode of diarization.
     */
    @Generated
    private TranscribeDiarizationProperties diarizationProperties;

    /*
     * The 0-based indices of the channels to be transcribed separately. If not specified, multiple channels are merged
     * and transcribed jointly. Only up to two channels are supported.
     */
    @Generated
    private List<Integer> activeChannels;

    /**
     * Creates an instance of TranscribeConfig class.
     */
    @Generated
    public TranscribeConfig() {
    }

    /**
     * Get the locales property: A list of possible locales for the transcription. If not specified, the locale of the
     * speech in the audio is detected automatically from all supported locales.
     * 
     * @return the locales value.
     */
    @Generated
    public List<String> getLocales() {
        return this.locales;
    }

    /**
     * Set the locales property: A list of possible locales for the transcription. If not specified, the locale of the
     * speech in the audio is detected automatically from all supported locales.
     * 
     * @param locales the locales value to set.
     * @return the TranscribeConfig object itself.
     */
    @Generated
    public TranscribeConfig setLocales(List<String> locales) {
        this.locales = locales;
        return this;
    }

    /**
     * Get the models property: Maps some or all candidate locales to a model URI to be used for transcription. If no
     * mapping is given, the default model for the locale is used.
     * 
     * @return the models value.
     */
    @Generated
    public Map<String, String> getModels() {
        return this.models;
    }

    /**
     * Set the models property: Maps some or all candidate locales to a model URI to be used for transcription. If no
     * mapping is given, the default model for the locale is used.
     * 
     * @param models the models value to set.
     * @return the TranscribeConfig object itself.
     */
    @Generated
    public TranscribeConfig setModels(Map<String, String> models) {
        this.models = models;
        return this;
    }

    /**
     * Get the profanityFilterMode property: Mode of profanity filtering.
     * 
     * @return the profanityFilterMode value.
     */
    @Generated
    public ProfanityFilterMode getProfanityFilterMode() {
        return this.profanityFilterMode;
    }

    /**
     * Set the profanityFilterMode property: Mode of profanity filtering.
     * 
     * @param profanityFilterMode the profanityFilterMode value to set.
     * @return the TranscribeConfig object itself.
     */
    @Generated
    public TranscribeConfig setProfanityFilterMode(ProfanityFilterMode profanityFilterMode) {
        this.profanityFilterMode = profanityFilterMode;
        return this;
    }

    /**
     * Get the diarizationProperties property: Mode of diarization.
     * 
     * @return the diarizationProperties value.
     */
    @Generated
    public TranscribeDiarizationProperties getDiarizationProperties() {
        return this.diarizationProperties;
    }

    /**
     * Set the diarizationProperties property: Mode of diarization.
     * 
     * @param diarizationProperties the diarizationProperties value to set.
     * @return the TranscribeConfig object itself.
     */
    @Generated
    public TranscribeConfig setDiarizationProperties(TranscribeDiarizationProperties diarizationProperties) {
        this.diarizationProperties = diarizationProperties;
        return this;
    }

    /**
     * Get the activeChannels property: The 0-based indices of the channels to be transcribed separately. If not
     * specified, multiple channels are merged and transcribed jointly. Only up to two channels are supported.
     * 
     * @return the activeChannels value.
     */
    @Generated
    public List<Integer> getActiveChannels() {
        return this.activeChannels;
    }

    /**
     * Set the activeChannels property: The 0-based indices of the channels to be transcribed separately. If not
     * specified, multiple channels are merged and transcribed jointly. Only up to two channels are supported.
     * 
     * @param activeChannels the activeChannels value to set.
     * @return the TranscribeConfig object itself.
     */
    @Generated
    public TranscribeConfig setActiveChannels(List<Integer> activeChannels) {
        this.activeChannels = activeChannels;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("locales", this.locales, (writer, element) -> writer.writeString(element));
        jsonWriter.writeMapField("models", this.models, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("profanityFilterMode",
            this.profanityFilterMode == null ? null : this.profanityFilterMode.toString());
        jsonWriter.writeJsonField("diarization", this.diarizationProperties);
        jsonWriter.writeArrayField("channels", this.activeChannels, (writer, element) -> writer.writeInt(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TranscribeConfig from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TranscribeConfig if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the TranscribeConfig.
     */
    @Generated
    public static TranscribeConfig fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TranscribeConfig deserializedTranscribeConfig = new TranscribeConfig();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("locales".equals(fieldName)) {
                    List<String> locales = reader.readArray(reader1 -> reader1.getString());
                    deserializedTranscribeConfig.locales = locales;
                } else if ("models".equals(fieldName)) {
                    Map<String, String> models = reader.readMap(reader1 -> reader1.getString());
                    deserializedTranscribeConfig.models = models;
                } else if ("profanityFilterMode".equals(fieldName)) {
                    deserializedTranscribeConfig.profanityFilterMode
                        = ProfanityFilterMode.fromString(reader.getString());
                } else if ("diarization".equals(fieldName)) {
                    deserializedTranscribeConfig.diarizationProperties
                        = TranscribeDiarizationProperties.fromJson(reader);
                } else if ("channels".equals(fieldName)) {
                    List<Integer> activeChannels = reader.readArray(reader1 -> reader1.getInt());
                    deserializedTranscribeConfig.activeChannels = activeChannels;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTranscribeConfig;
        });
    }
}
