// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.speechtotext.transcription.models;

import com.azure.ai.speechtotext.transcription.implementation.JsonMergePatchHelper;
import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * TranscriptionProperties.
 */
@Fluent
public final class TranscriptionProperties implements JsonSerializable<TranscriptionProperties> {
    /*
     * A value indicating whether word level timestamps are requested. The default value is false.
     */
    @Generated
    private Boolean wordLevelTimestampsEnabled;

    /*
     * A value indicating whether word level timestamps for the display form are requested. The default value is false.
     */
    @Generated
    private Boolean displayFormWordLevelTimestampsEnabled;

    /*
     * The duration in milliseconds of the transcription.
     * Durations larger than 2^53-1 are not supported to ensure compatibility with JavaScript integers.
     */
    @Generated
    private Integer durationMilliseconds;

    /*
     * A collection of the requested channel numbers. In the default case, the channels 0 and 1 are considered.
     */
    @Generated
    private List<Integer> channels;

    /*
     * The requested destination container.
     * 
     * Remarks
     * 
     * When a destination container is used in combination with a timeToLive, the metadata of a transcription will be
     * deleted normally, but the data stored in the destination container, including transcription results, will remain
     * untouched, because no delete permissions are required for this container.
     * 
     * To support automatic cleanup, either configure blob lifetimes on the container, or use
     * "Bring your own Storage (BYOS)" instead of destinationContainerUrl, where blobs can be cleaned up.
     */
    @Generated
    private String destinationContainer;

    /*
     * The mode used for punctuation.
     */
    @Generated
    private PunctuationMode punctuationMode;

    /*
     * Mode of profanity filtering.
     */
    @Generated
    private ProfanityFilterMode profanityFilterMode;

    /*
     * How long the transcription will be kept in the system after it has completed. Once the transcription reaches the
     * time to live after completion(successful or failed) it will be automatically deleted.
     * 
     * Note: When using BYOS (bring your own storage), the result files on the customer owned storage account will also
     * be deleted.Use either destinationContainerUrl to specify a separate container for result files which will not be
     * deleted when the timeToLive expires, or retrieve the result files through the API and store them as needed.
     * 
     * The shortest supported duration is 6 hours, the longest supported duration is 31 days. 2 days (48 hours) is the
     * recommended default value when data is consumed directly.
     */
    @Generated
    private int timeToLiveHours;

    /*
     * EntityError
     */
    @Generated
    private EntityError error;

    /*
     * Speaker Identification
     */
    @Generated
    private DiarizationProperties diarization;

    /*
     * LanguageIdentificationProperties
     */
    @Generated
    private LanguageIdentificationProperties languageIdentificationProperties;

    /**
     * Stores updated model property, the value is property name, not serialized name.
     */
    @Generated
    private final Set<String> updatedProperties = new HashSet<>();

    @Generated
    private boolean jsonMergePatch;

    @Generated
    private void serializeAsJsonMergePatch(boolean jsonMergePatch) {
        this.jsonMergePatch = jsonMergePatch;
    }

    static {
        JsonMergePatchHelper
            .setTranscriptionPropertiesAccessor(new JsonMergePatchHelper.TranscriptionPropertiesAccessor() {
                @Override
                public TranscriptionProperties prepareModelForJsonMergePatch(TranscriptionProperties model,
                    boolean jsonMergePatchEnabled) {
                    model.serializeAsJsonMergePatch(jsonMergePatchEnabled);
                    return model;
                }

                @Override
                public boolean isJsonMergePatch(TranscriptionProperties model) {
                    return model.jsonMergePatch;
                }
            });
    }

    /**
     * Creates an instance of TranscriptionProperties class.
     */
    @Generated
    public TranscriptionProperties() {
    }

    /**
     * Get the wordLevelTimestampsEnabled property: A value indicating whether word level timestamps are requested. The
     * default value is false.
     * 
     * @return the wordLevelTimestampsEnabled value.
     */
    @Generated
    public Boolean isWordLevelTimestampsEnabled() {
        return this.wordLevelTimestampsEnabled;
    }

    /**
     * Set the wordLevelTimestampsEnabled property: A value indicating whether word level timestamps are requested. The
     * default value is false.
     * 
     * @param wordLevelTimestampsEnabled the wordLevelTimestampsEnabled value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setWordLevelTimestampsEnabled(Boolean wordLevelTimestampsEnabled) {
        this.wordLevelTimestampsEnabled = wordLevelTimestampsEnabled;
        this.updatedProperties.add("wordLevelTimestampsEnabled");
        return this;
    }

    /**
     * Get the displayFormWordLevelTimestampsEnabled property: A value indicating whether word level timestamps for the
     * display form are requested. The default value is false.
     * 
     * @return the displayFormWordLevelTimestampsEnabled value.
     */
    @Generated
    public Boolean isDisplayFormWordLevelTimestampsEnabled() {
        return this.displayFormWordLevelTimestampsEnabled;
    }

    /**
     * Set the displayFormWordLevelTimestampsEnabled property: A value indicating whether word level timestamps for the
     * display form are requested. The default value is false.
     * 
     * @param displayFormWordLevelTimestampsEnabled the displayFormWordLevelTimestampsEnabled value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties
        setDisplayFormWordLevelTimestampsEnabled(Boolean displayFormWordLevelTimestampsEnabled) {
        this.displayFormWordLevelTimestampsEnabled = displayFormWordLevelTimestampsEnabled;
        this.updatedProperties.add("displayFormWordLevelTimestampsEnabled");
        return this;
    }

    /**
     * Get the durationMilliseconds property: The duration in milliseconds of the transcription.
     * Durations larger than 2^53-1 are not supported to ensure compatibility with JavaScript integers.
     * 
     * @return the durationMilliseconds value.
     */
    @Generated
    public Integer getDurationMilliseconds() {
        return this.durationMilliseconds;
    }

    /**
     * Get the channels property: A collection of the requested channel numbers. In the default case, the channels 0 and
     * 1 are considered.
     * 
     * @return the channels value.
     */
    @Generated
    public List<Integer> getChannels() {
        return this.channels;
    }

    /**
     * Set the channels property: A collection of the requested channel numbers. In the default case, the channels 0 and
     * 1 are considered.
     * 
     * @param channels the channels value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setChannels(List<Integer> channels) {
        this.channels = channels;
        this.updatedProperties.add("channels");
        return this;
    }

    /**
     * Get the destinationContainer property: The requested destination container.
     * 
     * Remarks
     * 
     * When a destination container is used in combination with a timeToLive, the metadata of a transcription will be
     * deleted normally, but the data stored in the destination container, including transcription results, will remain
     * untouched, because no delete permissions are required for this container.
     * 
     * To support automatic cleanup, either configure blob lifetimes on the container, or use "Bring your own Storage
     * (BYOS)" instead of destinationContainerUrl, where blobs can be cleaned up.
     * 
     * @return the destinationContainer value.
     */
    @Generated
    public String getDestinationContainer() {
        return this.destinationContainer;
    }

    /**
     * Set the destinationContainer property: The requested destination container.
     * 
     * Remarks
     * 
     * When a destination container is used in combination with a timeToLive, the metadata of a transcription will be
     * deleted normally, but the data stored in the destination container, including transcription results, will remain
     * untouched, because no delete permissions are required for this container.
     * 
     * To support automatic cleanup, either configure blob lifetimes on the container, or use "Bring your own Storage
     * (BYOS)" instead of destinationContainerUrl, where blobs can be cleaned up.
     * 
     * @param destinationContainer the destinationContainer value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setDestinationContainer(String destinationContainer) {
        this.destinationContainer = destinationContainer;
        this.updatedProperties.add("destinationContainer");
        return this;
    }

    /**
     * Get the punctuationMode property: The mode used for punctuation.
     * 
     * @return the punctuationMode value.
     */
    @Generated
    public PunctuationMode getPunctuationMode() {
        return this.punctuationMode;
    }

    /**
     * Set the punctuationMode property: The mode used for punctuation.
     * 
     * @param punctuationMode the punctuationMode value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setPunctuationMode(PunctuationMode punctuationMode) {
        this.punctuationMode = punctuationMode;
        this.updatedProperties.add("punctuationMode");
        return this;
    }

    /**
     * Get the profanityFilterMode property: Mode of profanity filtering.
     * 
     * @return the profanityFilterMode value.
     */
    @Generated
    public ProfanityFilterMode getProfanityFilterMode() {
        return this.profanityFilterMode;
    }

    /**
     * Set the profanityFilterMode property: Mode of profanity filtering.
     * 
     * @param profanityFilterMode the profanityFilterMode value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setProfanityFilterMode(ProfanityFilterMode profanityFilterMode) {
        this.profanityFilterMode = profanityFilterMode;
        this.updatedProperties.add("profanityFilterMode");
        return this;
    }

    /**
     * Get the timeToLiveHours property: How long the transcription will be kept in the system after it has completed.
     * Once the transcription reaches the time to live after completion(successful or failed) it will be automatically
     * deleted.
     * 
     * Note: When using BYOS (bring your own storage), the result files on the customer owned storage account will also
     * be deleted.Use either destinationContainerUrl to specify a separate container for result files which will not be
     * deleted when the timeToLive expires, or retrieve the result files through the API and store them as needed.
     * 
     * The shortest supported duration is 6 hours, the longest supported duration is 31 days. 2 days (48 hours) is the
     * recommended default value when data is consumed directly.
     * 
     * @return the timeToLiveHours value.
     */
    @Generated
    public int getTimeToLiveHours() {
        return this.timeToLiveHours;
    }

    /**
     * Set the timeToLiveHours property: How long the transcription will be kept in the system after it has completed.
     * Once the transcription reaches the time to live after completion(successful or failed) it will be automatically
     * deleted.
     * 
     * Note: When using BYOS (bring your own storage), the result files on the customer owned storage account will also
     * be deleted.Use either destinationContainerUrl to specify a separate container for result files which will not be
     * deleted when the timeToLive expires, or retrieve the result files through the API and store them as needed.
     * 
     * The shortest supported duration is 6 hours, the longest supported duration is 31 days. 2 days (48 hours) is the
     * recommended default value when data is consumed directly.
     * <p>Required when create the resource.</p>
     * 
     * @param timeToLiveHours the timeToLiveHours value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setTimeToLiveHours(int timeToLiveHours) {
        this.timeToLiveHours = timeToLiveHours;
        this.updatedProperties.add("timeToLiveHours");
        return this;
    }

    /**
     * Get the error property: EntityError.
     * 
     * @return the error value.
     */
    @Generated
    public EntityError getError() {
        return this.error;
    }

    /**
     * Set the error property: EntityError.
     * 
     * @param error the error value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setError(EntityError error) {
        this.error = error;
        this.updatedProperties.add("error");
        return this;
    }

    /**
     * Get the diarization property: Speaker Identification.
     * 
     * @return the diarization value.
     */
    @Generated
    public DiarizationProperties getDiarization() {
        return this.diarization;
    }

    /**
     * Set the diarization property: Speaker Identification.
     * 
     * @param diarization the diarization value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties setDiarization(DiarizationProperties diarization) {
        this.diarization = diarization;
        this.updatedProperties.add("diarization");
        return this;
    }

    /**
     * Get the languageIdentificationProperties property: LanguageIdentificationProperties.
     * 
     * @return the languageIdentificationProperties value.
     */
    @Generated
    public LanguageIdentificationProperties getLanguageIdentificationProperties() {
        return this.languageIdentificationProperties;
    }

    /**
     * Set the languageIdentificationProperties property: LanguageIdentificationProperties.
     * 
     * @param languageIdentificationProperties the languageIdentificationProperties value to set.
     * @return the TranscriptionProperties object itself.
     */
    @Generated
    public TranscriptionProperties
        setLanguageIdentificationProperties(LanguageIdentificationProperties languageIdentificationProperties) {
        this.languageIdentificationProperties = languageIdentificationProperties;
        this.updatedProperties.add("languageIdentificationProperties");
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        if (jsonMergePatch) {
            return toJsonMergePatch(jsonWriter);
        } else {
            jsonWriter.writeStartObject();
            jsonWriter.writeBooleanField("wordLevelTimestampsEnabled", this.wordLevelTimestampsEnabled);
            jsonWriter.writeBooleanField("displayFormWordLevelTimestampsEnabled",
                this.displayFormWordLevelTimestampsEnabled);
            jsonWriter.writeArrayField("channels", this.channels, (writer, element) -> writer.writeInt(element));
            jsonWriter.writeStringField("destinationContainerUrl", this.destinationContainer);
            jsonWriter.writeStringField("punctuationMode",
                this.punctuationMode == null ? null : this.punctuationMode.toString());
            jsonWriter.writeStringField("profanityFilterMode",
                this.profanityFilterMode == null ? null : this.profanityFilterMode.toString());
            jsonWriter.writeIntField("timeToLiveHours", this.timeToLiveHours);
            jsonWriter.writeJsonField("error", this.error);
            jsonWriter.writeJsonField("diarization", this.diarization);
            jsonWriter.writeJsonField("languageIdentification", this.languageIdentificationProperties);
            return jsonWriter.writeEndObject();
        }
    }

    @Generated
    private JsonWriter toJsonMergePatch(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        if (updatedProperties.contains("wordLevelTimestampsEnabled")) {
            if (this.wordLevelTimestampsEnabled == null) {
                jsonWriter.writeNullField("wordLevelTimestampsEnabled");
            } else {
                jsonWriter.writeBooleanField("wordLevelTimestampsEnabled", this.wordLevelTimestampsEnabled);
            }
        }
        if (updatedProperties.contains("displayFormWordLevelTimestampsEnabled")) {
            if (this.displayFormWordLevelTimestampsEnabled == null) {
                jsonWriter.writeNullField("displayFormWordLevelTimestampsEnabled");
            } else {
                jsonWriter.writeBooleanField("displayFormWordLevelTimestampsEnabled",
                    this.displayFormWordLevelTimestampsEnabled);
            }
        }
        if (updatedProperties.contains("channels")) {
            if (this.channels == null) {
                jsonWriter.writeNullField("channels");
            } else {
                jsonWriter.writeArrayField("channels", this.channels, (writer, element) -> writer.writeInt(element));
            }
        }
        if (updatedProperties.contains("destinationContainer")) {
            if (this.destinationContainer == null) {
                jsonWriter.writeNullField("destinationContainerUrl");
            } else {
                jsonWriter.writeStringField("destinationContainerUrl", this.destinationContainer);
            }
        }
        if (updatedProperties.contains("punctuationMode")) {
            if (this.punctuationMode == null) {
                jsonWriter.writeNullField("punctuationMode");
            } else {
                jsonWriter.writeStringField("punctuationMode", this.punctuationMode.toString());
            }
        }
        if (updatedProperties.contains("profanityFilterMode")) {
            if (this.profanityFilterMode == null) {
                jsonWriter.writeNullField("profanityFilterMode");
            } else {
                jsonWriter.writeStringField("profanityFilterMode", this.profanityFilterMode.toString());
            }
        }
        if (updatedProperties.contains("timeToLiveHours")) {
            jsonWriter.writeIntField("timeToLiveHours", this.timeToLiveHours);
        }
        if (updatedProperties.contains("error")) {
            if (this.error == null) {
                jsonWriter.writeNullField("error");
            } else {
                JsonMergePatchHelper.getEntityErrorAccessor().prepareModelForJsonMergePatch(this.error, true);
                jsonWriter.writeJsonField("error", this.error);
                JsonMergePatchHelper.getEntityErrorAccessor().prepareModelForJsonMergePatch(this.error, false);
            }
        }
        if (updatedProperties.contains("diarization")) {
            if (this.diarization == null) {
                jsonWriter.writeNullField("diarization");
            } else {
                JsonMergePatchHelper.getDiarizationPropertiesAccessor()
                    .prepareModelForJsonMergePatch(this.diarization, true);
                jsonWriter.writeJsonField("diarization", this.diarization);
                JsonMergePatchHelper.getDiarizationPropertiesAccessor()
                    .prepareModelForJsonMergePatch(this.diarization, false);
            }
        }
        if (updatedProperties.contains("languageIdentificationProperties")) {
            if (this.languageIdentificationProperties == null) {
                jsonWriter.writeNullField("languageIdentification");
            } else {
                JsonMergePatchHelper.getLanguageIdentificationPropertiesAccessor()
                    .prepareModelForJsonMergePatch(this.languageIdentificationProperties, true);
                jsonWriter.writeJsonField("languageIdentification", this.languageIdentificationProperties);
                JsonMergePatchHelper.getLanguageIdentificationPropertiesAccessor()
                    .prepareModelForJsonMergePatch(this.languageIdentificationProperties, false);
            }
        }
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TranscriptionProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TranscriptionProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the TranscriptionProperties.
     */
    @Generated
    public static TranscriptionProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TranscriptionProperties deserializedTranscriptionProperties = new TranscriptionProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("wordLevelTimestampsEnabled".equals(fieldName)) {
                    deserializedTranscriptionProperties.wordLevelTimestampsEnabled
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("displayFormWordLevelTimestampsEnabled".equals(fieldName)) {
                    deserializedTranscriptionProperties.displayFormWordLevelTimestampsEnabled
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("durationMilliseconds".equals(fieldName)) {
                    deserializedTranscriptionProperties.durationMilliseconds = reader.getNullable(JsonReader::getInt);
                } else if ("channels".equals(fieldName)) {
                    List<Integer> channels = reader.readArray(reader1 -> reader1.getInt());
                    deserializedTranscriptionProperties.channels = channels;
                } else if ("destinationContainerUrl".equals(fieldName)) {
                    deserializedTranscriptionProperties.destinationContainer = reader.getString();
                } else if ("punctuationMode".equals(fieldName)) {
                    deserializedTranscriptionProperties.punctuationMode
                        = PunctuationMode.fromString(reader.getString());
                } else if ("profanityFilterMode".equals(fieldName)) {
                    deserializedTranscriptionProperties.profanityFilterMode
                        = ProfanityFilterMode.fromString(reader.getString());
                } else if ("timeToLiveHours".equals(fieldName)) {
                    deserializedTranscriptionProperties.timeToLiveHours = reader.getInt();
                } else if ("error".equals(fieldName)) {
                    deserializedTranscriptionProperties.error = EntityError.fromJson(reader);
                } else if ("diarization".equals(fieldName)) {
                    deserializedTranscriptionProperties.diarization = DiarizationProperties.fromJson(reader);
                } else if ("languageIdentification".equals(fieldName)) {
                    deserializedTranscriptionProperties.languageIdentificationProperties
                        = LanguageIdentificationProperties.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTranscriptionProperties;
        });
    }
}
