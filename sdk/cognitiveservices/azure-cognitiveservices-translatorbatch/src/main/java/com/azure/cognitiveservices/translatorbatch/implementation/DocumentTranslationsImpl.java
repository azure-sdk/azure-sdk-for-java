// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.cognitiveservices.translatorbatch.implementation;

import com.azure.core.annotation.Delete;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.PagedFlux;
import com.azure.core.http.rest.PagedIterable;
import com.azure.core.http.rest.PagedResponse;
import com.azure.core.http.rest.PagedResponseBase;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.core.util.polling.DefaultPollingStrategy;
import com.azure.core.util.polling.PollerFlux;
import com.azure.core.util.polling.SyncPoller;
import com.azure.core.util.serializer.TypeReference;
import java.nio.ByteBuffer;
import java.time.Duration;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/** An instance of this class provides access to all the operations defined in DocumentTranslations. */
public final class DocumentTranslationsImpl {
    /** The proxy service used to perform REST calls. */
    private final DocumentTranslationsService service;

    /** The service client containing this operation class. */
    private final BatchDocumentTranslationClientImpl client;

    /**
     * Initializes an instance of DocumentTranslationsImpl.
     *
     * @param client the instance of the service client containing this operation class.
     */
    DocumentTranslationsImpl(BatchDocumentTranslationClientImpl client) {
        this.service =
                RestProxy.create(
                        DocumentTranslationsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * The interface defining all the services for BatchDocumentTranslationClientDocumentTranslations to be used by the
     * proxy service to perform REST calls.
     */
    @Host("{endpoint}/translator/text/batch/v2.0-preview1")
    @ServiceInterface(name = "BatchDocumentTransla")
    private interface DocumentTranslationsService {
        @Post("/batches")
        @ExpectedResponses({202})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Void>> startTranslation(
                @HostParam("endpoint") String endpoint, RequestOptions requestOptions, Context context);

        @Get("/batches")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getTranslationsStatus(
                @HostParam("endpoint") String endpoint, RequestOptions requestOptions, Context context);

        @Get("/batches/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getTranslationStatus(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                RequestOptions requestOptions,
                Context context);

        @Delete("/batches/{id}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> cancelTranslation(
                @HostParam("endpoint") String endpoint,
                @PathParam("id") String id,
                RequestOptions requestOptions,
                Context context);

        @Get("/formats")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getSupportedDocumentFormats(
                @HostParam("endpoint") String endpoint, RequestOptions requestOptions, Context context);

        @Get("/glossaries/formats")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getSupportedGlossaryFormats(
                @HostParam("endpoint") String endpoint, RequestOptions requestOptions, Context context);

        @Post("/translation")
        @ExpectedResponses({200, 200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<Flux<ByteBuffer>>> translateDocument(
                @HostParam("endpoint") String endpoint, RequestOptions requestOptions, Context context);

        @Get("{nextLink}")
        @ExpectedResponses({200})
        @UnexpectedResponseExceptionType(
                value = ClientAuthenticationException.class,
                code = {401})
        @UnexpectedResponseExceptionType(
                value = ResourceNotFoundException.class,
                code = {404})
        @UnexpectedResponseExceptionType(
                value = ResourceModifiedException.class,
                code = {409})
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> getTranslationsStatusNext(
                @PathParam(value = "nextLink", encoded = true) String nextLink,
                @HostParam("endpoint") String endpoint,
                RequestOptions requestOptions,
                Context context);
    }

    /**
     * Use this API to submit a bulk (batch) translation request to the Document Translation service. Each request can
     * contain multiple documents and must contain a source and destination container for each document.
     *
     * <p>The prefix and suffix filter (if supplied) are used to filter folders. The prefix is applied to the subpath
     * after the container name.
     *
     * <p>Glossaries / Translation memory can be included in the request and are applied by the service when the
     * document is translated.
     *
     * <p>If the glossary is invalid or unreachable during translation, an error is indicated in the document status. If
     * a file with the same name already exists at the destination, it will be overwritten. The targetUrl for each
     * target language must be unique.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     source: {
     *         containerUrl: String
     *         filters: [
     *             {
     *                 prefix: String
     *                 suffix: String
     *             }
     *         ]
     *         language: String
     *     }
     *     sources: [
     *         {
     *             blobUrl: String
     *             language: String
     *         }
     *     ]
     *     properties: {
     *         flight: String
     *         pdfOutputAdditionalFormat: String(None/OpenXmlWord)
     *         category: String
     *         glossaries: [
     *             {
     *                 glossaryUrl: String
     *                 format: String
     *                 version: String
     *                 sourceLanguage: String
     *                 targetLanguage: String
     *                 language: String
     *             }
     *         ]
     *     }
     *     targets: [
     *         {
     *             targetUrl: String
     *             language: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> startTranslationWithResponseAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.startTranslation(this.client.getEndpoint(), requestOptions, context));
    }

    /**
     * Use this API to submit a bulk (batch) translation request to the Document Translation service. Each request can
     * contain multiple documents and must contain a source and destination container for each document.
     *
     * <p>The prefix and suffix filter (if supplied) are used to filter folders. The prefix is applied to the subpath
     * after the container name.
     *
     * <p>Glossaries / Translation memory can be included in the request and are applied by the service when the
     * document is translated.
     *
     * <p>If the glossary is invalid or unreachable during translation, an error is indicated in the document status. If
     * a file with the same name already exists at the destination, it will be overwritten. The targetUrl for each
     * target language must be unique.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     source: {
     *         containerUrl: String
     *         filters: [
     *             {
     *                 prefix: String
     *                 suffix: String
     *             }
     *         ]
     *         language: String
     *     }
     *     sources: [
     *         {
     *             blobUrl: String
     *             language: String
     *         }
     *     ]
     *     properties: {
     *         flight: String
     *         pdfOutputAdditionalFormat: String(None/OpenXmlWord)
     *         category: String
     *         glossaries: [
     *             {
     *                 glossaryUrl: String
     *                 format: String
     *                 version: String
     *                 sourceLanguage: String
     *                 targetLanguage: String
     *                 language: String
     *             }
     *         ]
     *     }
     *     targets: [
     *         {
     *             targetUrl: String
     *             language: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Void>> startTranslationWithResponseAsync(RequestOptions requestOptions, Context context) {
        return service.startTranslation(this.client.getEndpoint(), requestOptions, context);
    }

    /**
     * Use this API to submit a bulk (batch) translation request to the Document Translation service. Each request can
     * contain multiple documents and must contain a source and destination container for each document.
     *
     * <p>The prefix and suffix filter (if supplied) are used to filter folders. The prefix is applied to the subpath
     * after the container name.
     *
     * <p>Glossaries / Translation memory can be included in the request and are applied by the service when the
     * document is translated.
     *
     * <p>If the glossary is invalid or unreachable during translation, an error is indicated in the document status. If
     * a file with the same name already exists at the destination, it will be overwritten. The targetUrl for each
     * target language must be unique.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     source: {
     *         containerUrl: String
     *         filters: [
     *             {
     *                 prefix: String
     *                 suffix: String
     *             }
     *         ]
     *         language: String
     *     }
     *     sources: [
     *         {
     *             blobUrl: String
     *             language: String
     *         }
     *     ]
     *     properties: {
     *         flight: String
     *         pdfOutputAdditionalFormat: String(None/OpenXmlWord)
     *         category: String
     *         glossaries: [
     *             {
     *                 glossaryUrl: String
     *                 format: String
     *                 version: String
     *                 sourceLanguage: String
     *                 targetLanguage: String
     *                 language: String
     *             }
     *         ]
     *     }
     *     targets: [
     *         {
     *             targetUrl: String
     *             language: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginStartTranslationAsync(RequestOptions requestOptions) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.startTranslationWithResponseAsync(requestOptions),
                new DefaultPollingStrategy<>(
                        this.client.getHttpPipeline(),
                        null,
                        requestOptions != null && requestOptions.getContext() != null
                                ? requestOptions.getContext()
                                : Context.NONE),
                new TypeReferenceBinaryData(),
                new TypeReferenceBinaryData());
    }

    /**
     * Use this API to submit a bulk (batch) translation request to the Document Translation service. Each request can
     * contain multiple documents and must contain a source and destination container for each document.
     *
     * <p>The prefix and suffix filter (if supplied) are used to filter folders. The prefix is applied to the subpath
     * after the container name.
     *
     * <p>Glossaries / Translation memory can be included in the request and are applied by the service when the
     * document is translated.
     *
     * <p>If the glossary is invalid or unreachable during translation, an error is indicated in the document status. If
     * a file with the same name already exists at the destination, it will be overwritten. The targetUrl for each
     * target language must be unique.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     source: {
     *         containerUrl: String
     *         filters: [
     *             {
     *                 prefix: String
     *                 suffix: String
     *             }
     *         ]
     *         language: String
     *     }
     *     sources: [
     *         {
     *             blobUrl: String
     *             language: String
     *         }
     *     ]
     *     properties: {
     *         flight: String
     *         pdfOutputAdditionalFormat: String(None/OpenXmlWord)
     *         category: String
     *         glossaries: [
     *             {
     *                 glossaryUrl: String
     *                 format: String
     *                 version: String
     *                 sourceLanguage: String
     *                 targetLanguage: String
     *                 language: String
     *             }
     *         ]
     *     }
     *     targets: [
     *         {
     *             targetUrl: String
     *             language: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link PollerFlux} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public PollerFlux<BinaryData, BinaryData> beginStartTranslationAsync(
            RequestOptions requestOptions, Context context) {
        return PollerFlux.create(
                Duration.ofSeconds(1),
                () -> this.startTranslationWithResponseAsync(requestOptions, context),
                new DefaultPollingStrategy<>(
                        this.client.getHttpPipeline(),
                        null,
                        requestOptions != null && requestOptions.getContext() != null
                                ? requestOptions.getContext()
                                : Context.NONE),
                new TypeReferenceBinaryData(),
                new TypeReferenceBinaryData());
    }

    /**
     * Use this API to submit a bulk (batch) translation request to the Document Translation service. Each request can
     * contain multiple documents and must contain a source and destination container for each document.
     *
     * <p>The prefix and suffix filter (if supplied) are used to filter folders. The prefix is applied to the subpath
     * after the container name.
     *
     * <p>Glossaries / Translation memory can be included in the request and are applied by the service when the
     * document is translated.
     *
     * <p>If the glossary is invalid or unreachable during translation, an error is indicated in the document status. If
     * a file with the same name already exists at the destination, it will be overwritten. The targetUrl for each
     * target language must be unique.
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     source: {
     *         containerUrl: String
     *         filters: [
     *             {
     *                 prefix: String
     *                 suffix: String
     *             }
     *         ]
     *         language: String
     *     }
     *     sources: [
     *         {
     *             blobUrl: String
     *             language: String
     *         }
     *     ]
     *     properties: {
     *         flight: String
     *         pdfOutputAdditionalFormat: String(None/OpenXmlWord)
     *         category: String
     *         glossaries: [
     *             {
     *                 glossaryUrl: String
     *                 format: String
     *                 version: String
     *                 sourceLanguage: String
     *                 targetLanguage: String
     *                 language: String
     *             }
     *         ]
     *     }
     *     targets: [
     *         {
     *             targetUrl: String
     *             language: String
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the {@link SyncPoller} for polling of long-running operation.
     */
    @ServiceMethod(returns = ReturnType.LONG_RUNNING_OPERATION)
    public SyncPoller<BinaryData, BinaryData> beginStartTranslation(RequestOptions requestOptions) {
        return this.beginStartTranslationAsync(requestOptions).getSyncPoller();
    }

    /**
     * Returns a list of batch requests submitted and the status for each request. This list only contains batch
     * requests submitted by the user (based on the resource).
     *
     * <p>If the number of requests exceeds our paging limit, server-side paging is used. Paginated responses indicate a
     * partial result and include a continuation token in the response. The absence of a continuation token means that
     * no additional pages are available.
     *
     * <p>$top, $skip and $maxpagesize query parameters can be used to specify a number of results to return and an
     * offset for the collection.
     *
     * <p>$top indicates the total number of records the user wants to be returned across all pages. $skip indicates the
     * number of records to skip from the list of batches based on the sorting method specified. By default, we sort by
     * descending start time. $maxpagesize is the maximum items returned in a page. If more items are requested via $top
     * (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next
     * page.
     *
     * <p>$orderBy query parameter can be used to sort the returned list (ex "$orderBy=createdDateTimeUtc asc" or
     * "$orderBy=createdDateTimeUtc desc"). The default sorting is descending by createdDateTimeUtc. Some query
     * parameters can be used to filter the returned list (ex: "status=Succeeded,Cancelled") will only return succeeded
     * and cancelled operations. createdDateTimeUtcStart and createdDateTimeUtcEnd can be used combined or separately to
     * specify a range of datetime to filter the returned list by. The supported filtering query parameters are (status,
     * ids, createdDateTimeUtcStart, createdDateTimeUtcEnd).
     *
     * <p>The server honors the values specified by the client. However, clients must be prepared to handle responses
     * that contain a different page size or contain a continuation token.
     *
     * <p>When both $top and $skip are included, the server should first apply $skip and then $top on the collection.
     * Note: If the server can't honor $top and/or $skip, the server must return an error to the client informing about
     * it instead of just ignoring the query options. This reduces the risk of the client making assumptions about the
     * data returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$top</td><td>String</td><td>No</td><td>$top indicates the total number of records the user wants to be returned across all pages.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>$skip indicates the number of records to skip from the list of records held by the server based on the sorting method specified.  By default, we sort by descending start time.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>$maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
     *
     * Clients MAY request server-driven paging with a specific page size by specifying a $maxpagesize preference. The server SHOULD honor this preference if the specified page size is smaller than the server's default page size.</td></tr>
     *     <tr><td>ids</td><td>String</td><td>No</td><td>Ids to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>statuses</td><td>String</td><td>No</td><td>Statuses to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>createdDateTimeUtcStart</td><td>String</td><td>No</td><td>the start datetime to get items after</td></tr>
     *     <tr><td>createdDateTimeUtcEnd</td><td>String</td><td>No</td><td>the end datetime to get items before</td></tr>
     *     <tr><td>$orderBy</td><td>String</td><td>No</td><td>the sorting query for the collection (ex: 'CreatedDateTimeUtc asc', 'CreatedDateTimeUtc desc'). In the form of "," separated string.</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             id: String
     *             self: String
     *             createdDateTimeUtc: String
     *             lastActionDateTimeUtc: String
     *             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *                 message: String
     *                 target: String
     *                 innerError: {
     *                     code: String
     *                     message: String
     *                     target: String
     *                     innerError: (recursive schema, see innerError above)
     *                 }
     *             }
     *             summary: {
     *                 total: int
     *                 failed: int
     *                 success: int
     *                 inProgress: int
     *                 notYetStarted: int
     *                 cancelled: int
     *                 totalCharacterCharged: long
     *             }
     *             documents: [
     *                 {
     *                     self: String
     *                     blobUrl: String
     *                     createdDateTimeUtc: String
     *                     id: long
     *                     targets: [
     *                         {
     *                             blobUrl: String
     *                             lastActionDateTimeUtc: String
     *                             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                             language: String
     *                             error: (recursive schema, see error above)
     *                             progress: float
     *                             id: long
     *                             characterCharged: Long
     *                             self: String
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job Status Response along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getTranslationsStatusSinglePageAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context -> service.getTranslationsStatus(this.client.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Returns a list of batch requests submitted and the status for each request. This list only contains batch
     * requests submitted by the user (based on the resource).
     *
     * <p>If the number of requests exceeds our paging limit, server-side paging is used. Paginated responses indicate a
     * partial result and include a continuation token in the response. The absence of a continuation token means that
     * no additional pages are available.
     *
     * <p>$top, $skip and $maxpagesize query parameters can be used to specify a number of results to return and an
     * offset for the collection.
     *
     * <p>$top indicates the total number of records the user wants to be returned across all pages. $skip indicates the
     * number of records to skip from the list of batches based on the sorting method specified. By default, we sort by
     * descending start time. $maxpagesize is the maximum items returned in a page. If more items are requested via $top
     * (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next
     * page.
     *
     * <p>$orderBy query parameter can be used to sort the returned list (ex "$orderBy=createdDateTimeUtc asc" or
     * "$orderBy=createdDateTimeUtc desc"). The default sorting is descending by createdDateTimeUtc. Some query
     * parameters can be used to filter the returned list (ex: "status=Succeeded,Cancelled") will only return succeeded
     * and cancelled operations. createdDateTimeUtcStart and createdDateTimeUtcEnd can be used combined or separately to
     * specify a range of datetime to filter the returned list by. The supported filtering query parameters are (status,
     * ids, createdDateTimeUtcStart, createdDateTimeUtcEnd).
     *
     * <p>The server honors the values specified by the client. However, clients must be prepared to handle responses
     * that contain a different page size or contain a continuation token.
     *
     * <p>When both $top and $skip are included, the server should first apply $skip and then $top on the collection.
     * Note: If the server can't honor $top and/or $skip, the server must return an error to the client informing about
     * it instead of just ignoring the query options. This reduces the risk of the client making assumptions about the
     * data returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$top</td><td>String</td><td>No</td><td>$top indicates the total number of records the user wants to be returned across all pages.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>$skip indicates the number of records to skip from the list of records held by the server based on the sorting method specified.  By default, we sort by descending start time.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>$maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
     *
     * Clients MAY request server-driven paging with a specific page size by specifying a $maxpagesize preference. The server SHOULD honor this preference if the specified page size is smaller than the server's default page size.</td></tr>
     *     <tr><td>ids</td><td>String</td><td>No</td><td>Ids to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>statuses</td><td>String</td><td>No</td><td>Statuses to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>createdDateTimeUtcStart</td><td>String</td><td>No</td><td>the start datetime to get items after</td></tr>
     *     <tr><td>createdDateTimeUtcEnd</td><td>String</td><td>No</td><td>the end datetime to get items before</td></tr>
     *     <tr><td>$orderBy</td><td>String</td><td>No</td><td>the sorting query for the collection (ex: 'CreatedDateTimeUtc asc', 'CreatedDateTimeUtc desc'). In the form of "," separated string.</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             id: String
     *             self: String
     *             createdDateTimeUtc: String
     *             lastActionDateTimeUtc: String
     *             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *                 message: String
     *                 target: String
     *                 innerError: {
     *                     code: String
     *                     message: String
     *                     target: String
     *                     innerError: (recursive schema, see innerError above)
     *                 }
     *             }
     *             summary: {
     *                 total: int
     *                 failed: int
     *                 success: int
     *                 inProgress: int
     *                 notYetStarted: int
     *                 cancelled: int
     *                 totalCharacterCharged: long
     *             }
     *             documents: [
     *                 {
     *                     self: String
     *                     blobUrl: String
     *                     createdDateTimeUtc: String
     *                     id: long
     *                     targets: [
     *                         {
     *                             blobUrl: String
     *                             lastActionDateTimeUtc: String
     *                             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                             language: String
     *                             error: (recursive schema, see error above)
     *                             progress: float
     *                             id: long
     *                             characterCharged: Long
     *                             self: String
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job Status Response along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getTranslationsStatusSinglePageAsync(
            RequestOptions requestOptions, Context context) {
        return service.getTranslationsStatus(this.client.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Returns a list of batch requests submitted and the status for each request. This list only contains batch
     * requests submitted by the user (based on the resource).
     *
     * <p>If the number of requests exceeds our paging limit, server-side paging is used. Paginated responses indicate a
     * partial result and include a continuation token in the response. The absence of a continuation token means that
     * no additional pages are available.
     *
     * <p>$top, $skip and $maxpagesize query parameters can be used to specify a number of results to return and an
     * offset for the collection.
     *
     * <p>$top indicates the total number of records the user wants to be returned across all pages. $skip indicates the
     * number of records to skip from the list of batches based on the sorting method specified. By default, we sort by
     * descending start time. $maxpagesize is the maximum items returned in a page. If more items are requested via $top
     * (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next
     * page.
     *
     * <p>$orderBy query parameter can be used to sort the returned list (ex "$orderBy=createdDateTimeUtc asc" or
     * "$orderBy=createdDateTimeUtc desc"). The default sorting is descending by createdDateTimeUtc. Some query
     * parameters can be used to filter the returned list (ex: "status=Succeeded,Cancelled") will only return succeeded
     * and cancelled operations. createdDateTimeUtcStart and createdDateTimeUtcEnd can be used combined or separately to
     * specify a range of datetime to filter the returned list by. The supported filtering query parameters are (status,
     * ids, createdDateTimeUtcStart, createdDateTimeUtcEnd).
     *
     * <p>The server honors the values specified by the client. However, clients must be prepared to handle responses
     * that contain a different page size or contain a continuation token.
     *
     * <p>When both $top and $skip are included, the server should first apply $skip and then $top on the collection.
     * Note: If the server can't honor $top and/or $skip, the server must return an error to the client informing about
     * it instead of just ignoring the query options. This reduces the risk of the client making assumptions about the
     * data returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$top</td><td>String</td><td>No</td><td>$top indicates the total number of records the user wants to be returned across all pages.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>$skip indicates the number of records to skip from the list of records held by the server based on the sorting method specified.  By default, we sort by descending start time.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>$maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
     *
     * Clients MAY request server-driven paging with a specific page size by specifying a $maxpagesize preference. The server SHOULD honor this preference if the specified page size is smaller than the server's default page size.</td></tr>
     *     <tr><td>ids</td><td>String</td><td>No</td><td>Ids to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>statuses</td><td>String</td><td>No</td><td>Statuses to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>createdDateTimeUtcStart</td><td>String</td><td>No</td><td>the start datetime to get items after</td></tr>
     *     <tr><td>createdDateTimeUtcEnd</td><td>String</td><td>No</td><td>the end datetime to get items before</td></tr>
     *     <tr><td>$orderBy</td><td>String</td><td>No</td><td>the sorting query for the collection (ex: 'CreatedDateTimeUtc asc', 'CreatedDateTimeUtc desc'). In the form of "," separated string.</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             id: String
     *             self: String
     *             createdDateTimeUtc: String
     *             lastActionDateTimeUtc: String
     *             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *                 message: String
     *                 target: String
     *                 innerError: {
     *                     code: String
     *                     message: String
     *                     target: String
     *                     innerError: (recursive schema, see innerError above)
     *                 }
     *             }
     *             summary: {
     *                 total: int
     *                 failed: int
     *                 success: int
     *                 inProgress: int
     *                 notYetStarted: int
     *                 cancelled: int
     *                 totalCharacterCharged: long
     *             }
     *             documents: [
     *                 {
     *                     self: String
     *                     blobUrl: String
     *                     createdDateTimeUtc: String
     *                     id: long
     *                     targets: [
     *                         {
     *                             blobUrl: String
     *                             lastActionDateTimeUtc: String
     *                             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                             language: String
     *                             error: (recursive schema, see error above)
     *                             progress: float
     *                             id: long
     *                             characterCharged: Long
     *                             self: String
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job Status Response as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getTranslationsStatusAsync(RequestOptions requestOptions) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedFlux<>(
                () -> getTranslationsStatusSinglePageAsync(requestOptions),
                nextLink -> getTranslationsStatusNextSinglePageAsync(nextLink, requestOptionsForNextPage));
    }

    /**
     * Returns a list of batch requests submitted and the status for each request. This list only contains batch
     * requests submitted by the user (based on the resource).
     *
     * <p>If the number of requests exceeds our paging limit, server-side paging is used. Paginated responses indicate a
     * partial result and include a continuation token in the response. The absence of a continuation token means that
     * no additional pages are available.
     *
     * <p>$top, $skip and $maxpagesize query parameters can be used to specify a number of results to return and an
     * offset for the collection.
     *
     * <p>$top indicates the total number of records the user wants to be returned across all pages. $skip indicates the
     * number of records to skip from the list of batches based on the sorting method specified. By default, we sort by
     * descending start time. $maxpagesize is the maximum items returned in a page. If more items are requested via $top
     * (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next
     * page.
     *
     * <p>$orderBy query parameter can be used to sort the returned list (ex "$orderBy=createdDateTimeUtc asc" or
     * "$orderBy=createdDateTimeUtc desc"). The default sorting is descending by createdDateTimeUtc. Some query
     * parameters can be used to filter the returned list (ex: "status=Succeeded,Cancelled") will only return succeeded
     * and cancelled operations. createdDateTimeUtcStart and createdDateTimeUtcEnd can be used combined or separately to
     * specify a range of datetime to filter the returned list by. The supported filtering query parameters are (status,
     * ids, createdDateTimeUtcStart, createdDateTimeUtcEnd).
     *
     * <p>The server honors the values specified by the client. However, clients must be prepared to handle responses
     * that contain a different page size or contain a continuation token.
     *
     * <p>When both $top and $skip are included, the server should first apply $skip and then $top on the collection.
     * Note: If the server can't honor $top and/or $skip, the server must return an error to the client informing about
     * it instead of just ignoring the query options. This reduces the risk of the client making assumptions about the
     * data returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$top</td><td>String</td><td>No</td><td>$top indicates the total number of records the user wants to be returned across all pages.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>$skip indicates the number of records to skip from the list of records held by the server based on the sorting method specified.  By default, we sort by descending start time.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>$maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
     *
     * Clients MAY request server-driven paging with a specific page size by specifying a $maxpagesize preference. The server SHOULD honor this preference if the specified page size is smaller than the server's default page size.</td></tr>
     *     <tr><td>ids</td><td>String</td><td>No</td><td>Ids to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>statuses</td><td>String</td><td>No</td><td>Statuses to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>createdDateTimeUtcStart</td><td>String</td><td>No</td><td>the start datetime to get items after</td></tr>
     *     <tr><td>createdDateTimeUtcEnd</td><td>String</td><td>No</td><td>the end datetime to get items before</td></tr>
     *     <tr><td>$orderBy</td><td>String</td><td>No</td><td>the sorting query for the collection (ex: 'CreatedDateTimeUtc asc', 'CreatedDateTimeUtc desc'). In the form of "," separated string.</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             id: String
     *             self: String
     *             createdDateTimeUtc: String
     *             lastActionDateTimeUtc: String
     *             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *                 message: String
     *                 target: String
     *                 innerError: {
     *                     code: String
     *                     message: String
     *                     target: String
     *                     innerError: (recursive schema, see innerError above)
     *                 }
     *             }
     *             summary: {
     *                 total: int
     *                 failed: int
     *                 success: int
     *                 inProgress: int
     *                 notYetStarted: int
     *                 cancelled: int
     *                 totalCharacterCharged: long
     *             }
     *             documents: [
     *                 {
     *                     self: String
     *                     blobUrl: String
     *                     createdDateTimeUtc: String
     *                     id: long
     *                     targets: [
     *                         {
     *                             blobUrl: String
     *                             lastActionDateTimeUtc: String
     *                             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                             language: String
     *                             error: (recursive schema, see error above)
     *                             progress: float
     *                             id: long
     *                             characterCharged: Long
     *                             self: String
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job Status Response as paginated response with {@link PagedFlux}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedFlux<BinaryData> getTranslationsStatusAsync(RequestOptions requestOptions, Context context) {
        RequestOptions requestOptionsForNextPage = new RequestOptions();
        requestOptionsForNextPage.setContext(
                requestOptions != null && requestOptions.getContext() != null
                        ? requestOptions.getContext()
                        : Context.NONE);
        return new PagedFlux<>(
                () -> getTranslationsStatusSinglePageAsync(requestOptions, context),
                nextLink -> getTranslationsStatusNextSinglePageAsync(nextLink, requestOptionsForNextPage, context));
    }

    /**
     * Returns a list of batch requests submitted and the status for each request. This list only contains batch
     * requests submitted by the user (based on the resource).
     *
     * <p>If the number of requests exceeds our paging limit, server-side paging is used. Paginated responses indicate a
     * partial result and include a continuation token in the response. The absence of a continuation token means that
     * no additional pages are available.
     *
     * <p>$top, $skip and $maxpagesize query parameters can be used to specify a number of results to return and an
     * offset for the collection.
     *
     * <p>$top indicates the total number of records the user wants to be returned across all pages. $skip indicates the
     * number of records to skip from the list of batches based on the sorting method specified. By default, we sort by
     * descending start time. $maxpagesize is the maximum items returned in a page. If more items are requested via $top
     * (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next
     * page.
     *
     * <p>$orderBy query parameter can be used to sort the returned list (ex "$orderBy=createdDateTimeUtc asc" or
     * "$orderBy=createdDateTimeUtc desc"). The default sorting is descending by createdDateTimeUtc. Some query
     * parameters can be used to filter the returned list (ex: "status=Succeeded,Cancelled") will only return succeeded
     * and cancelled operations. createdDateTimeUtcStart and createdDateTimeUtcEnd can be used combined or separately to
     * specify a range of datetime to filter the returned list by. The supported filtering query parameters are (status,
     * ids, createdDateTimeUtcStart, createdDateTimeUtcEnd).
     *
     * <p>The server honors the values specified by the client. However, clients must be prepared to handle responses
     * that contain a different page size or contain a continuation token.
     *
     * <p>When both $top and $skip are included, the server should first apply $skip and then $top on the collection.
     * Note: If the server can't honor $top and/or $skip, the server must return an error to the client informing about
     * it instead of just ignoring the query options. This reduces the risk of the client making assumptions about the
     * data returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$top</td><td>String</td><td>No</td><td>$top indicates the total number of records the user wants to be returned across all pages.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>$skip indicates the number of records to skip from the list of records held by the server based on the sorting method specified.  By default, we sort by descending start time.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>$maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
     *
     * Clients MAY request server-driven paging with a specific page size by specifying a $maxpagesize preference. The server SHOULD honor this preference if the specified page size is smaller than the server's default page size.</td></tr>
     *     <tr><td>ids</td><td>String</td><td>No</td><td>Ids to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>statuses</td><td>String</td><td>No</td><td>Statuses to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>createdDateTimeUtcStart</td><td>String</td><td>No</td><td>the start datetime to get items after</td></tr>
     *     <tr><td>createdDateTimeUtcEnd</td><td>String</td><td>No</td><td>the end datetime to get items before</td></tr>
     *     <tr><td>$orderBy</td><td>String</td><td>No</td><td>the sorting query for the collection (ex: 'CreatedDateTimeUtc asc', 'CreatedDateTimeUtc desc'). In the form of "," separated string.</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             id: String
     *             self: String
     *             createdDateTimeUtc: String
     *             lastActionDateTimeUtc: String
     *             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *                 message: String
     *                 target: String
     *                 innerError: {
     *                     code: String
     *                     message: String
     *                     target: String
     *                     innerError: (recursive schema, see innerError above)
     *                 }
     *             }
     *             summary: {
     *                 total: int
     *                 failed: int
     *                 success: int
     *                 inProgress: int
     *                 notYetStarted: int
     *                 cancelled: int
     *                 totalCharacterCharged: long
     *             }
     *             documents: [
     *                 {
     *                     self: String
     *                     blobUrl: String
     *                     createdDateTimeUtc: String
     *                     id: long
     *                     targets: [
     *                         {
     *                             blobUrl: String
     *                             lastActionDateTimeUtc: String
     *                             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                             language: String
     *                             error: (recursive schema, see error above)
     *                             progress: float
     *                             id: long
     *                             characterCharged: Long
     *                             self: String
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job Status Response as paginated response with {@link PagedIterable}.
     */
    @ServiceMethod(returns = ReturnType.COLLECTION)
    public PagedIterable<BinaryData> getTranslationsStatus(RequestOptions requestOptions) {
        return new PagedIterable<>(getTranslationsStatusAsync(requestOptions));
    }

    /**
     * Returns the status for a document translation request. The status includes the overall request status, as well as
     * the status for documents that are being translated as part of that request.
     *
     * <p>The returned status also contains the status for all documents in the request.
     *
     * <p>If the number of documents in the response exceeds our paging limit, server-side paging is used. Paginated
     * responses indicate a partial result and include a continuation token in the response. The absence of a
     * continuation token means that no additional pages are available.
     *
     * <p>$top, $skip and $maxpagesize query parameters can be used to specify a number of results to return and an
     * offset for the collection.
     *
     * <p>$top indicates the total number of records the user wants to be returned across all pages. $skip indicates the
     * number of records to skip from the list of document status held by the server based on the sorting method
     * specified. By default, we sort by descending start time. $maxpagesize is the maximum items returned in a page. If
     * more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink
     * will contain the link to the next page.
     *
     * <p>$orderBy query parameter can be used to sort the returned list (ex "$orderBy=createdDateTimeUtc asc" or
     * "$orderBy=createdDateTimeUtc desc"). The default sorting is descending by createdDateTimeUtc. Some query
     * parameters can be used to filter the returned list (ex: "status=Succeeded,Cancelled") will only return succeeded
     * and cancelled documents. createdDateTimeUtcStart and createdDateTimeUtcEnd can be used combined or separately to
     * specify a range of datetime to filter the returned list by. The supported filtering query parameters are (status,
     * ids, createdDateTimeUtcStart, createdDateTimeUtcEnd).
     *
     * <p>When both $top and $skip are included, the server should first apply $skip and then $top on the collection.
     * Note: If the server can't honor $top and/or $skip, the server must return an error to the client informing about
     * it instead of just ignoring the query options. This reduces the risk of the client making assumptions about the
     * data returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$top</td><td>String</td><td>No</td><td>$top indicates the total number of records the user wants to be returned across all pages.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>$skip indicates the number of records to skip from the list of records held by the server based on the sorting method specified.  By default, we sort by descending start time.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>$maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
     *
     * Clients MAY request server-driven paging with a specific page size by specifying a $maxpagesize preference. The server SHOULD honor this preference if the specified page size is smaller than the server's default page size.</td></tr>
     *     <tr><td>ids</td><td>String</td><td>No</td><td>Ids to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>statuses</td><td>String</td><td>No</td><td>Statuses to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>createdDateTimeUtcStart</td><td>String</td><td>No</td><td>the start datetime to get items after</td></tr>
     *     <tr><td>createdDateTimeUtcEnd</td><td>String</td><td>No</td><td>the end datetime to get items before</td></tr>
     *     <tr><td>$orderBy</td><td>String</td><td>No</td><td>the sorting query for the collection (ex: 'CreatedDateTimeUtc asc', 'CreatedDateTimeUtc desc'). In the form of "," separated string.</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String
     *     self: String
     *     createdDateTimeUtc: String
     *     lastActionDateTimeUtc: String
     *     status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *     error: {
     *         code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *         message: String
     *         target: String
     *         innerError: {
     *             code: String
     *             message: String
     *             target: String
     *             innerError: (recursive schema, see innerError above)
     *         }
     *     }
     *     summary: {
     *         total: int
     *         failed: int
     *         success: int
     *         inProgress: int
     *         notYetStarted: int
     *         cancelled: int
     *         totalCharacterCharged: long
     *     }
     *     documents: [
     *         {
     *             self: String
     *             blobUrl: String
     *             createdDateTimeUtc: String
     *             id: long
     *             targets: [
     *                 {
     *                     blobUrl: String
     *                     lastActionDateTimeUtc: String
     *                     status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                     language: String
     *                     error: (recursive schema, see error above)
     *                     progress: float
     *                     id: long
     *                     characterCharged: Long
     *                     self: String
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param id Format - uuid. The operation id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job status response along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTranslationStatusWithResponseAsync(String id, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.getTranslationStatus(this.client.getEndpoint(), id, requestOptions, context));
    }

    /**
     * Returns the status for a document translation request. The status includes the overall request status, as well as
     * the status for documents that are being translated as part of that request.
     *
     * <p>The returned status also contains the status for all documents in the request.
     *
     * <p>If the number of documents in the response exceeds our paging limit, server-side paging is used. Paginated
     * responses indicate a partial result and include a continuation token in the response. The absence of a
     * continuation token means that no additional pages are available.
     *
     * <p>$top, $skip and $maxpagesize query parameters can be used to specify a number of results to return and an
     * offset for the collection.
     *
     * <p>$top indicates the total number of records the user wants to be returned across all pages. $skip indicates the
     * number of records to skip from the list of document status held by the server based on the sorting method
     * specified. By default, we sort by descending start time. $maxpagesize is the maximum items returned in a page. If
     * more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink
     * will contain the link to the next page.
     *
     * <p>$orderBy query parameter can be used to sort the returned list (ex "$orderBy=createdDateTimeUtc asc" or
     * "$orderBy=createdDateTimeUtc desc"). The default sorting is descending by createdDateTimeUtc. Some query
     * parameters can be used to filter the returned list (ex: "status=Succeeded,Cancelled") will only return succeeded
     * and cancelled documents. createdDateTimeUtcStart and createdDateTimeUtcEnd can be used combined or separately to
     * specify a range of datetime to filter the returned list by. The supported filtering query parameters are (status,
     * ids, createdDateTimeUtcStart, createdDateTimeUtcEnd).
     *
     * <p>When both $top and $skip are included, the server should first apply $skip and then $top on the collection.
     * Note: If the server can't honor $top and/or $skip, the server must return an error to the client informing about
     * it instead of just ignoring the query options. This reduces the risk of the client making assumptions about the
     * data returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$top</td><td>String</td><td>No</td><td>$top indicates the total number of records the user wants to be returned across all pages.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>$skip indicates the number of records to skip from the list of records held by the server based on the sorting method specified.  By default, we sort by descending start time.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>$maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
     *
     * Clients MAY request server-driven paging with a specific page size by specifying a $maxpagesize preference. The server SHOULD honor this preference if the specified page size is smaller than the server's default page size.</td></tr>
     *     <tr><td>ids</td><td>String</td><td>No</td><td>Ids to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>statuses</td><td>String</td><td>No</td><td>Statuses to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>createdDateTimeUtcStart</td><td>String</td><td>No</td><td>the start datetime to get items after</td></tr>
     *     <tr><td>createdDateTimeUtcEnd</td><td>String</td><td>No</td><td>the end datetime to get items before</td></tr>
     *     <tr><td>$orderBy</td><td>String</td><td>No</td><td>the sorting query for the collection (ex: 'CreatedDateTimeUtc asc', 'CreatedDateTimeUtc desc'). In the form of "," separated string.</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String
     *     self: String
     *     createdDateTimeUtc: String
     *     lastActionDateTimeUtc: String
     *     status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *     error: {
     *         code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *         message: String
     *         target: String
     *         innerError: {
     *             code: String
     *             message: String
     *             target: String
     *             innerError: (recursive schema, see innerError above)
     *         }
     *     }
     *     summary: {
     *         total: int
     *         failed: int
     *         success: int
     *         inProgress: int
     *         notYetStarted: int
     *         cancelled: int
     *         totalCharacterCharged: long
     *     }
     *     documents: [
     *         {
     *             self: String
     *             blobUrl: String
     *             createdDateTimeUtc: String
     *             id: long
     *             targets: [
     *                 {
     *                     blobUrl: String
     *                     lastActionDateTimeUtc: String
     *                     status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                     language: String
     *                     error: (recursive schema, see error above)
     *                     progress: float
     *                     id: long
     *                     characterCharged: Long
     *                     self: String
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param id Format - uuid. The operation id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job status response along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getTranslationStatusWithResponseAsync(
            String id, RequestOptions requestOptions, Context context) {
        return service.getTranslationStatus(this.client.getEndpoint(), id, requestOptions, context);
    }

    /**
     * Returns the status for a document translation request. The status includes the overall request status, as well as
     * the status for documents that are being translated as part of that request.
     *
     * <p>The returned status also contains the status for all documents in the request.
     *
     * <p>If the number of documents in the response exceeds our paging limit, server-side paging is used. Paginated
     * responses indicate a partial result and include a continuation token in the response. The absence of a
     * continuation token means that no additional pages are available.
     *
     * <p>$top, $skip and $maxpagesize query parameters can be used to specify a number of results to return and an
     * offset for the collection.
     *
     * <p>$top indicates the total number of records the user wants to be returned across all pages. $skip indicates the
     * number of records to skip from the list of document status held by the server based on the sorting method
     * specified. By default, we sort by descending start time. $maxpagesize is the maximum items returned in a page. If
     * more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink
     * will contain the link to the next page.
     *
     * <p>$orderBy query parameter can be used to sort the returned list (ex "$orderBy=createdDateTimeUtc asc" or
     * "$orderBy=createdDateTimeUtc desc"). The default sorting is descending by createdDateTimeUtc. Some query
     * parameters can be used to filter the returned list (ex: "status=Succeeded,Cancelled") will only return succeeded
     * and cancelled documents. createdDateTimeUtcStart and createdDateTimeUtcEnd can be used combined or separately to
     * specify a range of datetime to filter the returned list by. The supported filtering query parameters are (status,
     * ids, createdDateTimeUtcStart, createdDateTimeUtcEnd).
     *
     * <p>When both $top and $skip are included, the server should first apply $skip and then $top on the collection.
     * Note: If the server can't honor $top and/or $skip, the server must return an error to the client informing about
     * it instead of just ignoring the query options. This reduces the risk of the client making assumptions about the
     * data returned.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>$top</td><td>String</td><td>No</td><td>$top indicates the total number of records the user wants to be returned across all pages.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$skip</td><td>String</td><td>No</td><td>$skip indicates the number of records to skip from the list of records held by the server based on the sorting method specified.  By default, we sort by descending start time.
     *
     * Clients MAY use $top and $skip query parameters to specify a number of results to return and an offset into the collection.
     * When both $top and $skip are given by a client, the server SHOULD first apply $skip and then $top on the collection.
     *
     * Note: If the server can't honor $top and/or $skip, the server MUST return an error to the client informing about it instead of just ignoring the query options.</td></tr>
     *     <tr><td>$maxpagesize</td><td>String</td><td>No</td><td>$maxpagesize is the maximum items returned in a page.  If more items are requested via $top (or $top is not specified and there are more items to be returned), @nextLink will contain the link to the next page.
     *
     * Clients MAY request server-driven paging with a specific page size by specifying a $maxpagesize preference. The server SHOULD honor this preference if the specified page size is smaller than the server's default page size.</td></tr>
     *     <tr><td>ids</td><td>String</td><td>No</td><td>Ids to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>statuses</td><td>String</td><td>No</td><td>Statuses to use in filtering. In the form of "," separated string.</td></tr>
     *     <tr><td>createdDateTimeUtcStart</td><td>String</td><td>No</td><td>the start datetime to get items after</td></tr>
     *     <tr><td>createdDateTimeUtcEnd</td><td>String</td><td>No</td><td>the end datetime to get items before</td></tr>
     *     <tr><td>$orderBy</td><td>String</td><td>No</td><td>the sorting query for the collection (ex: 'CreatedDateTimeUtc asc', 'CreatedDateTimeUtc desc'). In the form of "," separated string.</td></tr>
     * </table>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String
     *     self: String
     *     createdDateTimeUtc: String
     *     lastActionDateTimeUtc: String
     *     status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *     error: {
     *         code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *         message: String
     *         target: String
     *         innerError: {
     *             code: String
     *             message: String
     *             target: String
     *             innerError: (recursive schema, see innerError above)
     *         }
     *     }
     *     summary: {
     *         total: int
     *         failed: int
     *         success: int
     *         inProgress: int
     *         notYetStarted: int
     *         cancelled: int
     *         totalCharacterCharged: long
     *     }
     *     documents: [
     *         {
     *             self: String
     *             blobUrl: String
     *             createdDateTimeUtc: String
     *             id: long
     *             targets: [
     *                 {
     *                     blobUrl: String
     *                     lastActionDateTimeUtc: String
     *                     status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                     language: String
     *                     error: (recursive schema, see error above)
     *                     progress: float
     *                     id: long
     *                     characterCharged: Long
     *                     self: String
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param id Format - uuid. The operation id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job status response along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getTranslationStatusWithResponse(String id, RequestOptions requestOptions) {
        return getTranslationStatusWithResponseAsync(id, requestOptions).block();
    }

    /**
     * Cancel a currently processing or queued translation. A translation will not be cancelled if it is already
     * completed or failed or cancelling. A bad request will be returned. All documents that have completed translation
     * will not be cancelled and will be charged. All pending documents will be cancelled if possible.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String
     *     self: String
     *     createdDateTimeUtc: String
     *     lastActionDateTimeUtc: String
     *     status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *     error: {
     *         code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *         message: String
     *         target: String
     *         innerError: {
     *             code: String
     *             message: String
     *             target: String
     *             innerError: (recursive schema, see innerError above)
     *         }
     *     }
     *     summary: {
     *         total: int
     *         failed: int
     *         success: int
     *         inProgress: int
     *         notYetStarted: int
     *         cancelled: int
     *         totalCharacterCharged: long
     *     }
     *     documents: [
     *         {
     *             self: String
     *             blobUrl: String
     *             createdDateTimeUtc: String
     *             id: long
     *             targets: [
     *                 {
     *                     blobUrl: String
     *                     lastActionDateTimeUtc: String
     *                     status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                     language: String
     *                     error: (recursive schema, see error above)
     *                     progress: float
     *                     id: long
     *                     characterCharged: Long
     *                     self: String
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param id Format - uuid. The operation-id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job status response along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> cancelTranslationWithResponseAsync(String id, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.cancelTranslation(this.client.getEndpoint(), id, requestOptions, context));
    }

    /**
     * Cancel a currently processing or queued translation. A translation will not be cancelled if it is already
     * completed or failed or cancelling. A bad request will be returned. All documents that have completed translation
     * will not be cancelled and will be charged. All pending documents will be cancelled if possible.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String
     *     self: String
     *     createdDateTimeUtc: String
     *     lastActionDateTimeUtc: String
     *     status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *     error: {
     *         code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *         message: String
     *         target: String
     *         innerError: {
     *             code: String
     *             message: String
     *             target: String
     *             innerError: (recursive schema, see innerError above)
     *         }
     *     }
     *     summary: {
     *         total: int
     *         failed: int
     *         success: int
     *         inProgress: int
     *         notYetStarted: int
     *         cancelled: int
     *         totalCharacterCharged: long
     *     }
     *     documents: [
     *         {
     *             self: String
     *             blobUrl: String
     *             createdDateTimeUtc: String
     *             id: long
     *             targets: [
     *                 {
     *                     blobUrl: String
     *                     lastActionDateTimeUtc: String
     *                     status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                     language: String
     *                     error: (recursive schema, see error above)
     *                     progress: float
     *                     id: long
     *                     characterCharged: Long
     *                     self: String
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param id Format - uuid. The operation-id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job status response along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> cancelTranslationWithResponseAsync(
            String id, RequestOptions requestOptions, Context context) {
        return service.cancelTranslation(this.client.getEndpoint(), id, requestOptions, context);
    }

    /**
     * Cancel a currently processing or queued translation. A translation will not be cancelled if it is already
     * completed or failed or cancelling. A bad request will be returned. All documents that have completed translation
     * will not be cancelled and will be charged. All pending documents will be cancelled if possible.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     id: String
     *     self: String
     *     createdDateTimeUtc: String
     *     lastActionDateTimeUtc: String
     *     status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *     error: {
     *         code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *         message: String
     *         target: String
     *         innerError: {
     *             code: String
     *             message: String
     *             target: String
     *             innerError: (recursive schema, see innerError above)
     *         }
     *     }
     *     summary: {
     *         total: int
     *         failed: int
     *         success: int
     *         inProgress: int
     *         notYetStarted: int
     *         cancelled: int
     *         totalCharacterCharged: long
     *     }
     *     documents: [
     *         {
     *             self: String
     *             blobUrl: String
     *             createdDateTimeUtc: String
     *             id: long
     *             targets: [
     *                 {
     *                     blobUrl: String
     *                     lastActionDateTimeUtc: String
     *                     status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                     language: String
     *                     error: (recursive schema, see error above)
     *                     progress: float
     *                     id: long
     *                     characterCharged: Long
     *                     self: String
     *                 }
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param id Format - uuid. The operation-id.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job status response along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> cancelTranslationWithResponse(String id, RequestOptions requestOptions) {
        return cancelTranslationWithResponseAsync(id, requestOptions).block();
    }

    /**
     * The list of supported document formats supported by the Document Translation service. The list includes the
     * common file extension, as well as the content-type if using the upload API.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             format: String
     *             fileExtensions: [
     *                 String
     *             ]
     *             contentTypes: [
     *                 String
     *             ]
     *             defaultVersion: String
     *             versions: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return list of supported file formats along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getSupportedDocumentFormatsWithResponseAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.getSupportedDocumentFormats(this.client.getEndpoint(), requestOptions, context));
    }

    /**
     * The list of supported document formats supported by the Document Translation service. The list includes the
     * common file extension, as well as the content-type if using the upload API.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             format: String
     *             fileExtensions: [
     *                 String
     *             ]
     *             contentTypes: [
     *                 String
     *             ]
     *             defaultVersion: String
     *             versions: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return list of supported file formats along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getSupportedDocumentFormatsWithResponseAsync(
            RequestOptions requestOptions, Context context) {
        return service.getSupportedDocumentFormats(this.client.getEndpoint(), requestOptions, context);
    }

    /**
     * The list of supported document formats supported by the Document Translation service. The list includes the
     * common file extension, as well as the content-type if using the upload API.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             format: String
     *             fileExtensions: [
     *                 String
     *             ]
     *             contentTypes: [
     *                 String
     *             ]
     *             defaultVersion: String
     *             versions: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return list of supported file formats along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getSupportedDocumentFormatsWithResponse(RequestOptions requestOptions) {
        return getSupportedDocumentFormatsWithResponseAsync(requestOptions).block();
    }

    /**
     * The list of supported glossary formats supported by the Document Translation service. The list includes the
     * common file extension used.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             format: String
     *             fileExtensions: [
     *                 String
     *             ]
     *             contentTypes: [
     *                 String
     *             ]
     *             defaultVersion: String
     *             versions: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return list of supported file formats along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getSupportedGlossaryFormatsWithResponseAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.getSupportedGlossaryFormats(this.client.getEndpoint(), requestOptions, context));
    }

    /**
     * The list of supported glossary formats supported by the Document Translation service. The list includes the
     * common file extension used.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             format: String
     *             fileExtensions: [
     *                 String
     *             ]
     *             contentTypes: [
     *                 String
     *             ]
     *             defaultVersion: String
     *             versions: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return list of supported file formats along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getSupportedGlossaryFormatsWithResponseAsync(
            RequestOptions requestOptions, Context context) {
        return service.getSupportedGlossaryFormats(this.client.getEndpoint(), requestOptions, context);
    }

    /**
     * The list of supported glossary formats supported by the Document Translation service. The list includes the
     * common file extension used.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             format: String
     *             fileExtensions: [
     *                 String
     *             ]
     *             contentTypes: [
     *                 String
     *             ]
     *             defaultVersion: String
     *             versions: [
     *                 String
     *             ]
     *         }
     *     ]
     * }
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return list of supported file formats along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getSupportedGlossaryFormatsWithResponse(RequestOptions requestOptions) {
        return getSupportedGlossaryFormatsWithResponseAsync(requestOptions).block();
    }

    /**
     * Use this API to translate a single document. the request body should contain the document content and the
     * 'Content-Type' header should contain the document type.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>From</td><td>String</td><td>No</td><td>The from language of the Translation Request, if empty or not specified it will be autodetect</td></tr>
     *     <tr><td>To</td><td>String</td><td>Yes</td><td>The to language of the Translation Request</td></tr>
     *     <tr><td>Category</td><td>String</td><td>No</td><td>The category of the translation.  If empty, default to general</td></tr>
     * </table>
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>Content-Type</td><td>String</td><td>Yes</td><td>Upload file type</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * String
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * Flux<ByteBuffer>
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Flux<ByteBuffer>>> translateDocumentWithResponseAsync(RequestOptions requestOptions) {
        return FluxUtil.withContext(
                context -> service.translateDocument(this.client.getEndpoint(), requestOptions, context));
    }

    /**
     * Use this API to translate a single document. the request body should contain the document content and the
     * 'Content-Type' header should contain the document type.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>From</td><td>String</td><td>No</td><td>The from language of the Translation Request, if empty or not specified it will be autodetect</td></tr>
     *     <tr><td>To</td><td>String</td><td>Yes</td><td>The to language of the Translation Request</td></tr>
     *     <tr><td>Category</td><td>String</td><td>No</td><td>The category of the translation.  If empty, default to general</td></tr>
     * </table>
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>Content-Type</td><td>String</td><td>Yes</td><td>Upload file type</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * String
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * Flux<ByteBuffer>
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<Flux<ByteBuffer>>> translateDocumentWithResponseAsync(
            RequestOptions requestOptions, Context context) {
        return service.translateDocument(this.client.getEndpoint(), requestOptions, context);
    }

    /**
     * Use this API to translate a single document. the request body should contain the document content and the
     * 'Content-Type' header should contain the document type.
     *
     * <p><strong>Query Parameters</strong>
     *
     * <table border="1">
     *     <caption>Query Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>From</td><td>String</td><td>No</td><td>The from language of the Translation Request, if empty or not specified it will be autodetect</td></tr>
     *     <tr><td>To</td><td>String</td><td>Yes</td><td>The to language of the Translation Request</td></tr>
     *     <tr><td>Category</td><td>String</td><td>No</td><td>The category of the translation.  If empty, default to general</td></tr>
     * </table>
     *
     * <p><strong>Header Parameters</strong>
     *
     * <table border="1">
     *     <caption>Header Parameters</caption>
     *     <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     *     <tr><td>Content-Type</td><td>String</td><td>Yes</td><td>Upload file type</td></tr>
     * </table>
     *
     * <p><strong>Request Body Schema</strong>
     *
     * <pre>{@code
     * String
     * }</pre>
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * Flux<ByteBuffer>
     * }</pre>
     *
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the response body along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<Flux<ByteBuffer>> translateDocumentWithResponse(RequestOptions requestOptions) {
        return translateDocumentWithResponseAsync(requestOptions).block();
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             id: String
     *             self: String
     *             createdDateTimeUtc: String
     *             lastActionDateTimeUtc: String
     *             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *                 message: String
     *                 target: String
     *                 innerError: {
     *                     code: String
     *                     message: String
     *                     target: String
     *                     innerError: (recursive schema, see innerError above)
     *                 }
     *             }
     *             summary: {
     *                 total: int
     *                 failed: int
     *                 success: int
     *                 inProgress: int
     *                 notYetStarted: int
     *                 cancelled: int
     *                 totalCharacterCharged: long
     *             }
     *             documents: [
     *                 {
     *                     self: String
     *                     blobUrl: String
     *                     createdDateTimeUtc: String
     *                     id: long
     *                     targets: [
     *                         {
     *                             blobUrl: String
     *                             lastActionDateTimeUtc: String
     *                             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                             language: String
     *                             error: (recursive schema, see error above)
     *                             progress: float
     *                             id: long
     *                             characterCharged: Long
     *                             self: String
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job Status Response along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getTranslationsStatusNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions) {
        return FluxUtil.withContext(
                        context ->
                                service.getTranslationsStatusNext(
                                        nextLink, this.client.getEndpoint(), requestOptions, context))
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    /**
     * Get the next page of items.
     *
     * <p><strong>Response Body Schema</strong>
     *
     * <pre>{@code
     * {
     *     value: [
     *         {
     *             id: String
     *             self: String
     *             createdDateTimeUtc: String
     *             lastActionDateTimeUtc: String
     *             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *             error: {
     *                 code: String(InvalidRequest/InvalidArgument/InternalServerError/ServiceUnavailable/ResourceNotFound/Unauthorized/RequestRateTooHigh)
     *                 message: String
     *                 target: String
     *                 innerError: {
     *                     code: String
     *                     message: String
     *                     target: String
     *                     innerError: (recursive schema, see innerError above)
     *                 }
     *             }
     *             summary: {
     *                 total: int
     *                 failed: int
     *                 success: int
     *                 inProgress: int
     *                 notYetStarted: int
     *                 cancelled: int
     *                 totalCharacterCharged: long
     *             }
     *             documents: [
     *                 {
     *                     self: String
     *                     blobUrl: String
     *                     createdDateTimeUtc: String
     *                     id: long
     *                     targets: [
     *                         {
     *                             blobUrl: String
     *                             lastActionDateTimeUtc: String
     *                             status: String(NotStarted/Running/Succeeded/Failed/Cancelled/Cancelling/ValidationFailed)
     *                             language: String
     *                             error: (recursive schema, see error above)
     *                             progress: float
     *                             id: long
     *                             characterCharged: Long
     *                             self: String
     *                         }
     *                     ]
     *                 }
     *             ]
     *         }
     *     ]
     *     nextLink: String
     * }
     * }</pre>
     *
     * @param nextLink The nextLink parameter.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @param context The context to associate with this operation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return translation job Status Response along with {@link PagedResponse} on successful completion of {@link
     *     Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<PagedResponse<BinaryData>> getTranslationsStatusNextSinglePageAsync(
            String nextLink, RequestOptions requestOptions, Context context) {
        return service.getTranslationsStatusNext(nextLink, this.client.getEndpoint(), requestOptions, context)
                .map(
                        res ->
                                new PagedResponseBase<>(
                                        res.getRequest(),
                                        res.getStatusCode(),
                                        res.getHeaders(),
                                        getValues(res.getValue(), "value"),
                                        getNextLink(res.getValue(), "@nextLink"),
                                        null));
    }

    private static final class TypeReferenceBinaryData extends TypeReference<BinaryData> {
        // empty
    }

    private List<BinaryData> getValues(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            List<?> values = (List<?>) obj.get(path);
            return values.stream().map(BinaryData::fromObject).collect(Collectors.toList());
        } catch (RuntimeException e) {
            return null;
        }
    }

    private String getNextLink(BinaryData binaryData, String path) {
        try {
            Map<?, ?> obj = binaryData.toObject(Map.class);
            return (String) obj.get(path);
        } catch (RuntimeException e) {
            return null;
        }
    }
}
