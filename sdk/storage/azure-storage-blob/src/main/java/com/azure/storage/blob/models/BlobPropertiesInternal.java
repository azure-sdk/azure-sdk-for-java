// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.storage.blob.models;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.Immutable;
import com.azure.core.util.CoreUtils;
import com.azure.core.util.DateTimeRfc1123;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.util.Objects;

/**
 * The properties of a blob.
 */
@Immutable
public final class BlobPropertiesInternal implements JsonSerializable<BlobPropertiesInternal> {
    /*
     * The date-time the blob was created in RFC1123 format.
     */
    @Generated
    private DateTimeRfc1123 creationTime;

    /*
     * The date-time the blob was last modified in RFC1123 format.
     */
    @Generated
    private final DateTimeRfc1123 lastModified;

    /*
     * The blog ETag.
     */
    @Generated
    private final String eTag;

    /*
     * The content length of the blob.
     */
    @Generated
    private Long contentLength;

    /*
     * The content type of the blob.
     */
    @Generated
    private String contentType;

    /*
     * The content encoding of the blob.
     */
    @Generated
    private String contentEncoding;

    /*
     * The content language of the blob.
     */
    @Generated
    private String contentLanguage;

    /*
     * The content MD5 of the blob.
     */
    @Generated
    private byte[] contentMd5;

    /*
     * The content disposition of the blob.
     */
    @Generated
    private String contentDisposition;

    /*
     * The cache control of the blob.
     */
    @Generated
    private String cacheControl;

    /*
     * The sequence number of the blob.
     */
    @Generated
    private Long blobSequenceNumber;

    /*
     * The blob type.
     */
    @Generated
    private BlobType blobType;

    /*
     * The lease status of the blob.
     */
    @Generated
    private LeaseStatus leaseStatus;

    /*
     * The lease state of the blob.
     */
    @Generated
    private LeaseState leaseState;

    /*
     * The lease duration of the blob.
     */
    @Generated
    private LeaseDuration leaseDuration;

    /*
     * The copy ID of the blob.
     */
    @Generated
    private String copyId;

    /*
     * The copy status of the blob.
     */
    @Generated
    private CopyStatus copyStatus;

    /*
     * The copy source of the blob.
     */
    @Generated
    private String copySource;

    /*
     * The copy progress of the blob.
     */
    @Generated
    private String copyProgress;

    /*
     * The copy completion time of the blob.
     */
    @Generated
    private DateTimeRfc1123 copyCompletionTime;

    /*
     * The copy status description of the blob.
     */
    @Generated
    private String copyStatusDescription;

    /*
     * Whether the blog is encrypted on the server.
     */
    @Generated
    private Boolean serverEncrypted;

    /*
     * Whether the blog is incremental copy.
     */
    @Generated
    private Boolean incrementalCopy;

    /*
     * The name of the destination snapshot.
     */
    @Generated
    private String destinationSnapshot;

    /*
     * The time the blob was deleted.
     */
    @Generated
    private DateTimeRfc1123 deletedTime;

    /*
     * The remaining retention days of the blob.
     */
    @Generated
    private Integer remainingRetentionDays;

    /*
     * The access tier of the blob.
     */
    @Generated
    private AccessTier accessTier;

    /*
     * Whether the access tier is inferred.
     */
    @Generated
    private Boolean accessTierInferred;

    /*
     * The archive status of the blob.
     */
    @Generated
    private ArchiveStatus archiveStatus;

    /*
     * Customer provided key sha256
     */
    @Generated
    private String customerProvidedKeySha256;

    /*
     * The encryption scope of the blob.
     */
    @Generated
    private String encryptionScope;

    /*
     * The access tier change time of the blob.
     */
    @Generated
    private DateTimeRfc1123 accessTierChangeTime;

    /*
     * The number of tags for the blob.
     */
    @Generated
    private Integer tagCount;

    /*
     * The expire time of the blob.
     */
    @Generated
    private DateTimeRfc1123 expiresOn;

    /*
     * Whether the blob is sealed.
     */
    @Generated
    private Boolean isSealed;

    /*
     * The rehydrate priority of the blob.
     */
    @Generated
    private RehydratePriority rehydratePriority;

    /*
     * The last access time of the blob.
     */
    @Generated
    private DateTimeRfc1123 lastAccessedOn;

    /*
     * The immutability policy until time of the blob.
     */
    @Generated
    private DateTimeRfc1123 immutabilityPolicyExpiresOn;

    /*
     * The immutability policy mode of the blob.
     */
    @Generated
    private BlobImmutabilityPolicyMode immutabilityPolicyMode;

    /*
     * Whether the blob is under legal hold.
     */
    @Generated
    private Boolean legalHold;

    /**
     * Creates an instance of BlobPropertiesInternal class.
     * 
     * @param lastModified the lastModified value to set.
     * @param eTag the eTag value to set.
     */
    @Generated
    private BlobPropertiesInternal(OffsetDateTime lastModified, String eTag) {
        if (lastModified == null) {
            this.lastModified = null;
        } else {
            this.lastModified = new DateTimeRfc1123(lastModified);
        }
        this.eTag = eTag;
    }

    /**
     * Get the creationTime property: The date-time the blob was created in RFC1123 format.
     * 
     * @return the creationTime value.
     */
    @Generated
    public OffsetDateTime getCreationTime() {
        if (this.creationTime == null) {
            return null;
        }
        return this.creationTime.getDateTime();
    }

    /**
     * Get the lastModified property: The date-time the blob was last modified in RFC1123 format.
     * 
     * @return the lastModified value.
     */
    @Generated
    public OffsetDateTime getLastModified() {
        if (this.lastModified == null) {
            return null;
        }
        return this.lastModified.getDateTime();
    }

    /**
     * Get the eTag property: The blog ETag.
     * 
     * @return the eTag value.
     */
    @Generated
    public String getETag() {
        return this.eTag;
    }

    /**
     * Get the contentLength property: The content length of the blob.
     * 
     * @return the contentLength value.
     */
    @Generated
    public Long getContentLength() {
        return this.contentLength;
    }

    /**
     * Get the contentType property: The content type of the blob.
     * 
     * @return the contentType value.
     */
    @Generated
    public String getContentType() {
        return this.contentType;
    }

    /**
     * Get the contentEncoding property: The content encoding of the blob.
     * 
     * @return the contentEncoding value.
     */
    @Generated
    public String getContentEncoding() {
        return this.contentEncoding;
    }

    /**
     * Get the contentLanguage property: The content language of the blob.
     * 
     * @return the contentLanguage value.
     */
    @Generated
    public String getContentLanguage() {
        return this.contentLanguage;
    }

    /**
     * Get the contentMd5 property: The content MD5 of the blob.
     * 
     * @return the contentMd5 value.
     */
    @Generated
    public byte[] getContentMd5() {
        return CoreUtils.clone(this.contentMd5);
    }

    /**
     * Get the contentDisposition property: The content disposition of the blob.
     * 
     * @return the contentDisposition value.
     */
    @Generated
    public String getContentDisposition() {
        return this.contentDisposition;
    }

    /**
     * Get the cacheControl property: The cache control of the blob.
     * 
     * @return the cacheControl value.
     */
    @Generated
    public String getCacheControl() {
        return this.cacheControl;
    }

    /**
     * Get the blobSequenceNumber property: The sequence number of the blob.
     * 
     * @return the blobSequenceNumber value.
     */
    @Generated
    public Long getBlobSequenceNumber() {
        return this.blobSequenceNumber;
    }

    /**
     * Get the blobType property: The blob type.
     * 
     * @return the blobType value.
     */
    @Generated
    public BlobType getBlobType() {
        return this.blobType;
    }

    /**
     * Get the leaseStatus property: The lease status of the blob.
     * 
     * @return the leaseStatus value.
     */
    @Generated
    public LeaseStatus getLeaseStatus() {
        return this.leaseStatus;
    }

    /**
     * Get the leaseState property: The lease state of the blob.
     * 
     * @return the leaseState value.
     */
    @Generated
    public LeaseState getLeaseState() {
        return this.leaseState;
    }

    /**
     * Get the leaseDuration property: The lease duration of the blob.
     * 
     * @return the leaseDuration value.
     */
    @Generated
    public LeaseDuration getLeaseDuration() {
        return this.leaseDuration;
    }

    /**
     * Get the copyId property: The copy ID of the blob.
     * 
     * @return the copyId value.
     */
    @Generated
    public String getCopyId() {
        return this.copyId;
    }

    /**
     * Get the copyStatus property: The copy status of the blob.
     * 
     * @return the copyStatus value.
     */
    @Generated
    public CopyStatus getCopyStatus() {
        return this.copyStatus;
    }

    /**
     * Get the copySource property: The copy source of the blob.
     * 
     * @return the copySource value.
     */
    @Generated
    public String getCopySource() {
        return this.copySource;
    }

    /**
     * Get the copyProgress property: The copy progress of the blob.
     * 
     * @return the copyProgress value.
     */
    @Generated
    public String getCopyProgress() {
        return this.copyProgress;
    }

    /**
     * Get the copyCompletionTime property: The copy completion time of the blob.
     * 
     * @return the copyCompletionTime value.
     */
    @Generated
    public OffsetDateTime getCopyCompletionTime() {
        if (this.copyCompletionTime == null) {
            return null;
        }
        return this.copyCompletionTime.getDateTime();
    }

    /**
     * Get the copyStatusDescription property: The copy status description of the blob.
     * 
     * @return the copyStatusDescription value.
     */
    @Generated
    public String getCopyStatusDescription() {
        return this.copyStatusDescription;
    }

    /**
     * Get the serverEncrypted property: Whether the blog is encrypted on the server.
     * 
     * @return the serverEncrypted value.
     */
    @Generated
    public Boolean isServerEncrypted() {
        return this.serverEncrypted;
    }

    /**
     * Get the incrementalCopy property: Whether the blog is incremental copy.
     * 
     * @return the incrementalCopy value.
     */
    @Generated
    public Boolean isIncrementalCopy() {
        return this.incrementalCopy;
    }

    /**
     * Get the destinationSnapshot property: The name of the destination snapshot.
     * 
     * @return the destinationSnapshot value.
     */
    @Generated
    public String getDestinationSnapshot() {
        return this.destinationSnapshot;
    }

    /**
     * Get the deletedTime property: The time the blob was deleted.
     * 
     * @return the deletedTime value.
     */
    @Generated
    public OffsetDateTime getDeletedTime() {
        if (this.deletedTime == null) {
            return null;
        }
        return this.deletedTime.getDateTime();
    }

    /**
     * Get the remainingRetentionDays property: The remaining retention days of the blob.
     * 
     * @return the remainingRetentionDays value.
     */
    @Generated
    public Integer getRemainingRetentionDays() {
        return this.remainingRetentionDays;
    }

    /**
     * Get the accessTier property: The access tier of the blob.
     * 
     * @return the accessTier value.
     */
    @Generated
    public AccessTier getAccessTier() {
        return this.accessTier;
    }

    /**
     * Get the accessTierInferred property: Whether the access tier is inferred.
     * 
     * @return the accessTierInferred value.
     */
    @Generated
    public Boolean isAccessTierInferred() {
        return this.accessTierInferred;
    }

    /**
     * Get the archiveStatus property: The archive status of the blob.
     * 
     * @return the archiveStatus value.
     */
    @Generated
    public ArchiveStatus getArchiveStatus() {
        return this.archiveStatus;
    }

    /**
     * Get the customerProvidedKeySha256 property: Customer provided key sha256.
     * 
     * @return the customerProvidedKeySha256 value.
     */
    @Generated
    public String getCustomerProvidedKeySha256() {
        return this.customerProvidedKeySha256;
    }

    /**
     * Get the encryptionScope property: The encryption scope of the blob.
     * 
     * @return the encryptionScope value.
     */
    @Generated
    public String getEncryptionScope() {
        return this.encryptionScope;
    }

    /**
     * Get the accessTierChangeTime property: The access tier change time of the blob.
     * 
     * @return the accessTierChangeTime value.
     */
    @Generated
    public OffsetDateTime getAccessTierChangeTime() {
        if (this.accessTierChangeTime == null) {
            return null;
        }
        return this.accessTierChangeTime.getDateTime();
    }

    /**
     * Get the tagCount property: The number of tags for the blob.
     * 
     * @return the tagCount value.
     */
    @Generated
    public Integer getTagCount() {
        return this.tagCount;
    }

    /**
     * Get the expiresOn property: The expire time of the blob.
     * 
     * @return the expiresOn value.
     */
    @Generated
    public OffsetDateTime getExpiresOn() {
        if (this.expiresOn == null) {
            return null;
        }
        return this.expiresOn.getDateTime();
    }

    /**
     * Get the isSealed property: Whether the blob is sealed.
     * 
     * @return the isSealed value.
     */
    @Generated
    public Boolean isSealed() {
        return this.isSealed;
    }

    /**
     * Get the rehydratePriority property: The rehydrate priority of the blob.
     * 
     * @return the rehydratePriority value.
     */
    @Generated
    public RehydratePriority getRehydratePriority() {
        return this.rehydratePriority;
    }

    /**
     * Get the lastAccessedOn property: The last access time of the blob.
     * 
     * @return the lastAccessedOn value.
     */
    @Generated
    public OffsetDateTime getLastAccessedOn() {
        if (this.lastAccessedOn == null) {
            return null;
        }
        return this.lastAccessedOn.getDateTime();
    }

    /**
     * Get the immutabilityPolicyExpiresOn property: The immutability policy until time of the blob.
     * 
     * @return the immutabilityPolicyExpiresOn value.
     */
    @Generated
    public OffsetDateTime getImmutabilityPolicyExpiresOn() {
        if (this.immutabilityPolicyExpiresOn == null) {
            return null;
        }
        return this.immutabilityPolicyExpiresOn.getDateTime();
    }

    /**
     * Get the immutabilityPolicyMode property: The immutability policy mode of the blob.
     * 
     * @return the immutabilityPolicyMode value.
     */
    @Generated
    public BlobImmutabilityPolicyMode getImmutabilityPolicyMode() {
        return this.immutabilityPolicyMode;
    }

    /**
     * Get the legalHold property: Whether the blob is under legal hold.
     * 
     * @return the legalHold value.
     */
    @Generated
    public Boolean isLegalHold() {
        return this.legalHold;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("lastModified", Objects.toString(this.lastModified, null));
        jsonWriter.writeStringField("eTag", this.eTag);
        jsonWriter.writeStringField("creationTime", Objects.toString(this.creationTime, null));
        jsonWriter.writeNumberField("contentLength", this.contentLength);
        jsonWriter.writeStringField("contentType", this.contentType);
        jsonWriter.writeStringField("contentEncoding", this.contentEncoding);
        jsonWriter.writeStringField("contentLanguage", this.contentLanguage);
        jsonWriter.writeBinaryField("contentMd5", this.contentMd5);
        jsonWriter.writeStringField("contentDisposition", this.contentDisposition);
        jsonWriter.writeStringField("cacheControl", this.cacheControl);
        jsonWriter.writeNumberField("blobSequenceNumber", this.blobSequenceNumber);
        jsonWriter.writeStringField("blobType", this.blobType == null ? null : this.blobType.toString());
        jsonWriter.writeStringField("leaseStatus", this.leaseStatus == null ? null : this.leaseStatus.toString());
        jsonWriter.writeStringField("leaseState", this.leaseState == null ? null : this.leaseState.toString());
        jsonWriter.writeStringField("leaseDuration", this.leaseDuration == null ? null : this.leaseDuration.toString());
        jsonWriter.writeStringField("copyId", this.copyId);
        jsonWriter.writeStringField("copyStatus", this.copyStatus == null ? null : this.copyStatus.toString());
        jsonWriter.writeStringField("copySource", this.copySource);
        jsonWriter.writeStringField("copyProgress", this.copyProgress);
        jsonWriter.writeStringField("copyCompletionTime", Objects.toString(this.copyCompletionTime, null));
        jsonWriter.writeStringField("copyStatusDescription", this.copyStatusDescription);
        jsonWriter.writeBooleanField("serverEncrypted", this.serverEncrypted);
        jsonWriter.writeBooleanField("incrementalCopy", this.incrementalCopy);
        jsonWriter.writeStringField("destinationSnapshot", this.destinationSnapshot);
        jsonWriter.writeStringField("deletedTime", Objects.toString(this.deletedTime, null));
        jsonWriter.writeNumberField("remainingRetentionDays", this.remainingRetentionDays);
        jsonWriter.writeStringField("accessTier", this.accessTier == null ? null : this.accessTier.toString());
        jsonWriter.writeBooleanField("accessTierInferred", this.accessTierInferred);
        jsonWriter.writeStringField("archiveStatus", this.archiveStatus == null ? null : this.archiveStatus.toString());
        jsonWriter.writeStringField("customerProvidedKeySha256", this.customerProvidedKeySha256);
        jsonWriter.writeStringField("encryptionScope", this.encryptionScope);
        jsonWriter.writeStringField("accessTierChangeTime", Objects.toString(this.accessTierChangeTime, null));
        jsonWriter.writeNumberField("tagCount", this.tagCount);
        jsonWriter.writeStringField("expiryTime", Objects.toString(this.expiresOn, null));
        jsonWriter.writeBooleanField("sealed", this.isSealed);
        jsonWriter.writeStringField("rehydratePriority",
            this.rehydratePriority == null ? null : this.rehydratePriority.toString());
        jsonWriter.writeStringField("lastAccessTime", Objects.toString(this.lastAccessedOn, null));
        jsonWriter.writeStringField("immutabilityPolicyUntilDate",
            Objects.toString(this.immutabilityPolicyExpiresOn, null));
        jsonWriter.writeStringField("immutabilityPolicyMode",
            this.immutabilityPolicyMode == null ? null : this.immutabilityPolicyMode.toString());
        jsonWriter.writeBooleanField("legalHold", this.legalHold);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of BlobPropertiesInternal from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of BlobPropertiesInternal if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the BlobPropertiesInternal.
     */
    @Generated
    public static BlobPropertiesInternal fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            OffsetDateTime lastModified = null;
            String eTag = null;
            DateTimeRfc1123 creationTime = null;
            Long contentLength = null;
            String contentType = null;
            String contentEncoding = null;
            String contentLanguage = null;
            byte[] contentMd5 = null;
            String contentDisposition = null;
            String cacheControl = null;
            Long blobSequenceNumber = null;
            BlobType blobType = null;
            LeaseStatus leaseStatus = null;
            LeaseState leaseState = null;
            LeaseDuration leaseDuration = null;
            String copyId = null;
            CopyStatus copyStatus = null;
            String copySource = null;
            String copyProgress = null;
            DateTimeRfc1123 copyCompletionTime = null;
            String copyStatusDescription = null;
            Boolean serverEncrypted = null;
            Boolean incrementalCopy = null;
            String destinationSnapshot = null;
            DateTimeRfc1123 deletedTime = null;
            Integer remainingRetentionDays = null;
            AccessTier accessTier = null;
            Boolean accessTierInferred = null;
            ArchiveStatus archiveStatus = null;
            String customerProvidedKeySha256 = null;
            String encryptionScope = null;
            DateTimeRfc1123 accessTierChangeTime = null;
            Integer tagCount = null;
            DateTimeRfc1123 expiresOn = null;
            Boolean isSealed = null;
            RehydratePriority rehydratePriority = null;
            DateTimeRfc1123 lastAccessedOn = null;
            DateTimeRfc1123 immutabilityPolicyExpiresOn = null;
            BlobImmutabilityPolicyMode immutabilityPolicyMode = null;
            Boolean legalHold = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("lastModified".equals(fieldName)) {
                    DateTimeRfc1123 lastModifiedHolder
                        = reader.getNullable(nonNullReader -> new DateTimeRfc1123(nonNullReader.getString()));
                    if (lastModifiedHolder != null) {
                        lastModified = lastModifiedHolder.getDateTime();
                    }
                } else if ("eTag".equals(fieldName)) {
                    eTag = reader.getString();
                } else if ("creationTime".equals(fieldName)) {
                    creationTime = reader.getNullable(nonNullReader -> new DateTimeRfc1123(nonNullReader.getString()));
                } else if ("contentLength".equals(fieldName)) {
                    contentLength = reader.getNullable(JsonReader::getLong);
                } else if ("contentType".equals(fieldName)) {
                    contentType = reader.getString();
                } else if ("contentEncoding".equals(fieldName)) {
                    contentEncoding = reader.getString();
                } else if ("contentLanguage".equals(fieldName)) {
                    contentLanguage = reader.getString();
                } else if ("contentMd5".equals(fieldName)) {
                    contentMd5 = reader.getBinary();
                } else if ("contentDisposition".equals(fieldName)) {
                    contentDisposition = reader.getString();
                } else if ("cacheControl".equals(fieldName)) {
                    cacheControl = reader.getString();
                } else if ("blobSequenceNumber".equals(fieldName)) {
                    blobSequenceNumber = reader.getNullable(JsonReader::getLong);
                } else if ("blobType".equals(fieldName)) {
                    blobType = BlobType.fromString(reader.getString());
                } else if ("leaseStatus".equals(fieldName)) {
                    leaseStatus = LeaseStatus.fromString(reader.getString());
                } else if ("leaseState".equals(fieldName)) {
                    leaseState = LeaseState.fromString(reader.getString());
                } else if ("leaseDuration".equals(fieldName)) {
                    leaseDuration = LeaseDuration.fromString(reader.getString());
                } else if ("copyId".equals(fieldName)) {
                    copyId = reader.getString();
                } else if ("copyStatus".equals(fieldName)) {
                    copyStatus = CopyStatus.fromString(reader.getString());
                } else if ("copySource".equals(fieldName)) {
                    copySource = reader.getString();
                } else if ("copyProgress".equals(fieldName)) {
                    copyProgress = reader.getString();
                } else if ("copyCompletionTime".equals(fieldName)) {
                    copyCompletionTime
                        = reader.getNullable(nonNullReader -> new DateTimeRfc1123(nonNullReader.getString()));
                } else if ("copyStatusDescription".equals(fieldName)) {
                    copyStatusDescription = reader.getString();
                } else if ("serverEncrypted".equals(fieldName)) {
                    serverEncrypted = reader.getNullable(JsonReader::getBoolean);
                } else if ("incrementalCopy".equals(fieldName)) {
                    incrementalCopy = reader.getNullable(JsonReader::getBoolean);
                } else if ("destinationSnapshot".equals(fieldName)) {
                    destinationSnapshot = reader.getString();
                } else if ("deletedTime".equals(fieldName)) {
                    deletedTime = reader.getNullable(nonNullReader -> new DateTimeRfc1123(nonNullReader.getString()));
                } else if ("remainingRetentionDays".equals(fieldName)) {
                    remainingRetentionDays = reader.getNullable(JsonReader::getInt);
                } else if ("accessTier".equals(fieldName)) {
                    accessTier = AccessTier.fromString(reader.getString());
                } else if ("accessTierInferred".equals(fieldName)) {
                    accessTierInferred = reader.getNullable(JsonReader::getBoolean);
                } else if ("archiveStatus".equals(fieldName)) {
                    archiveStatus = ArchiveStatus.fromString(reader.getString());
                } else if ("customerProvidedKeySha256".equals(fieldName)) {
                    customerProvidedKeySha256 = reader.getString();
                } else if ("encryptionScope".equals(fieldName)) {
                    encryptionScope = reader.getString();
                } else if ("accessTierChangeTime".equals(fieldName)) {
                    accessTierChangeTime
                        = reader.getNullable(nonNullReader -> new DateTimeRfc1123(nonNullReader.getString()));
                } else if ("tagCount".equals(fieldName)) {
                    tagCount = reader.getNullable(JsonReader::getInt);
                } else if ("expiryTime".equals(fieldName)) {
                    expiresOn = reader.getNullable(nonNullReader -> new DateTimeRfc1123(nonNullReader.getString()));
                } else if ("sealed".equals(fieldName)) {
                    isSealed = reader.getNullable(JsonReader::getBoolean);
                } else if ("rehydratePriority".equals(fieldName)) {
                    rehydratePriority = RehydratePriority.fromString(reader.getString());
                } else if ("lastAccessTime".equals(fieldName)) {
                    lastAccessedOn
                        = reader.getNullable(nonNullReader -> new DateTimeRfc1123(nonNullReader.getString()));
                } else if ("immutabilityPolicyUntilDate".equals(fieldName)) {
                    immutabilityPolicyExpiresOn
                        = reader.getNullable(nonNullReader -> new DateTimeRfc1123(nonNullReader.getString()));
                } else if ("immutabilityPolicyMode".equals(fieldName)) {
                    immutabilityPolicyMode = BlobImmutabilityPolicyMode.fromString(reader.getString());
                } else if ("legalHold".equals(fieldName)) {
                    legalHold = reader.getNullable(JsonReader::getBoolean);
                } else {
                    reader.skipChildren();
                }
            }
            BlobPropertiesInternal deserializedBlobPropertiesInternal = new BlobPropertiesInternal(lastModified, eTag);
            deserializedBlobPropertiesInternal.creationTime = creationTime;
            deserializedBlobPropertiesInternal.contentLength = contentLength;
            deserializedBlobPropertiesInternal.contentType = contentType;
            deserializedBlobPropertiesInternal.contentEncoding = contentEncoding;
            deserializedBlobPropertiesInternal.contentLanguage = contentLanguage;
            deserializedBlobPropertiesInternal.contentMd5 = contentMd5;
            deserializedBlobPropertiesInternal.contentDisposition = contentDisposition;
            deserializedBlobPropertiesInternal.cacheControl = cacheControl;
            deserializedBlobPropertiesInternal.blobSequenceNumber = blobSequenceNumber;
            deserializedBlobPropertiesInternal.blobType = blobType;
            deserializedBlobPropertiesInternal.leaseStatus = leaseStatus;
            deserializedBlobPropertiesInternal.leaseState = leaseState;
            deserializedBlobPropertiesInternal.leaseDuration = leaseDuration;
            deserializedBlobPropertiesInternal.copyId = copyId;
            deserializedBlobPropertiesInternal.copyStatus = copyStatus;
            deserializedBlobPropertiesInternal.copySource = copySource;
            deserializedBlobPropertiesInternal.copyProgress = copyProgress;
            deserializedBlobPropertiesInternal.copyCompletionTime = copyCompletionTime;
            deserializedBlobPropertiesInternal.copyStatusDescription = copyStatusDescription;
            deserializedBlobPropertiesInternal.serverEncrypted = serverEncrypted;
            deserializedBlobPropertiesInternal.incrementalCopy = incrementalCopy;
            deserializedBlobPropertiesInternal.destinationSnapshot = destinationSnapshot;
            deserializedBlobPropertiesInternal.deletedTime = deletedTime;
            deserializedBlobPropertiesInternal.remainingRetentionDays = remainingRetentionDays;
            deserializedBlobPropertiesInternal.accessTier = accessTier;
            deserializedBlobPropertiesInternal.accessTierInferred = accessTierInferred;
            deserializedBlobPropertiesInternal.archiveStatus = archiveStatus;
            deserializedBlobPropertiesInternal.customerProvidedKeySha256 = customerProvidedKeySha256;
            deserializedBlobPropertiesInternal.encryptionScope = encryptionScope;
            deserializedBlobPropertiesInternal.accessTierChangeTime = accessTierChangeTime;
            deserializedBlobPropertiesInternal.tagCount = tagCount;
            deserializedBlobPropertiesInternal.expiresOn = expiresOn;
            deserializedBlobPropertiesInternal.isSealed = isSealed;
            deserializedBlobPropertiesInternal.rehydratePriority = rehydratePriority;
            deserializedBlobPropertiesInternal.lastAccessedOn = lastAccessedOn;
            deserializedBlobPropertiesInternal.immutabilityPolicyExpiresOn = immutabilityPolicyExpiresOn;
            deserializedBlobPropertiesInternal.immutabilityPolicyMode = immutabilityPolicyMode;
            deserializedBlobPropertiesInternal.legalHold = legalHold;

            return deserializedBlobPropertiesInternal;
        });
    }
}
