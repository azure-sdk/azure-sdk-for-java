// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Definition of TargetHealth.
 */
@Fluent
public final class TargetHealth implements JsonSerializable<TargetHealth> {
    /*
     * <p>A description of the target health that provides additional details. If the state is <code>healthy</code>, a
     * description is not provided.</p>
     */
    private String description;

    /*
     * <p>The reason code.</p> <p>If the target state is <code>healthy</code>, a reason code is not provided.</p> <p>If
     * the target state is <code>initial</code>, the reason code can be one of the following values:</p> <ul> <li> <p>
     * <code>Elb.RegistrationInProgress</code> - The target is in the process of being registered with the load
     * balancer.</p> </li> <li> <p> <code>Elb.InitialHealthChecking</code> - The load balancer is still sending the
     * target the minimum number of health checks required to determine its health status.</p> </li> </ul> <p>If the
     * target state is <code>unhealthy</code>, the reason code can be one of the following values:</p> <ul> <li> <p>
     * <code>Target.ResponseCodeMismatch</code> - The health checks did not return an expected HTTP code. Applies only
     * to Application Load Balancers and Gateway Load Balancers.</p> </li> <li> <p> <code>Target.Timeout</code> - The
     * health check requests timed out. Applies only to Application Load Balancers and Gateway Load Balancers.</p> </li>
     * <li> <p> <code>Target.FailedHealthChecks</code> - The load balancer received an error while establishing a
     * connection to the target or the target response was malformed.</p> </li> <li> <p> <code>Elb.InternalError</code>
     * - The health checks failed due to an internal error. Applies only to Application Load Balancers.</p> </li> </ul>
     * <p>If the target state is <code>unused</code>, the reason code can be one of the following values:</p> <ul> <li>
     * <p> <code>Target.NotRegistered</code> - The target is not registered with the target group.</p> </li> <li> <p>
     * <code>Target.NotInUse</code> - The target group is not used by any load balancer or the target is in an
     * Availability Zone that is not enabled for its load balancer.</p> </li> <li> <p> <code>Target.InvalidState</code>
     * - The target is in the stopped or terminated state.</p> </li> <li> <p> <code>Target.IpUnusable</code> - The
     * target IP address is reserved for use by a load balancer.</p> </li> </ul> <p>If the target state is
     * <code>draining</code>, the reason code can be the following value:</p> <ul> <li> <p>
     * <code>Target.DeregistrationInProgress</code> - The target is in the process of being deregistered and the
     * deregistration delay period has not expired.</p> </li> </ul> <p>If the target state is <code>unavailable</code>,
     * the reason code can be the following value:</p> <ul> <li> <p> <code>Target.HealthCheckDisabled</code> - Health
     * checks are disabled for the target group. Applies only to Application Load Balancers.</p> </li> <li> <p>
     * <code>Elb.InternalError</code> - Target health is unavailable due to an internal error. Applies only to Network
     * Load Balancers.</p> </li> </ul>
     */
    private TargetHealthReasonEnumValue reason;

    /*
     * <p>The state of the target.</p>
     */
    private TargetHealthStateEnumValue state;

    /**
     * Creates an instance of TargetHealth class.
     */
    public TargetHealth() {
    }

    /**
     * Get the description property: &lt;p&gt;A description of the target health that provides additional details. If
     * the state is &lt;code&gt;healthy&lt;/code&gt;, a description is not provided.&lt;/p&gt;.
     * 
     * @return the description value.
     */
    public String description() {
        return this.description;
    }

    /**
     * Set the description property: &lt;p&gt;A description of the target health that provides additional details. If
     * the state is &lt;code&gt;healthy&lt;/code&gt;, a description is not provided.&lt;/p&gt;.
     * 
     * @param description the description value to set.
     * @return the TargetHealth object itself.
     */
    public TargetHealth withDescription(String description) {
        this.description = description;
        return this;
    }

    /**
     * Get the reason property: &lt;p&gt;The reason code.&lt;/p&gt; &lt;p&gt;If the target state is
     * &lt;code&gt;healthy&lt;/code&gt;, a reason code is not provided.&lt;/p&gt; &lt;p&gt;If the target state is
     * &lt;code&gt;initial&lt;/code&gt;, the reason code can be one of the following values:&lt;/p&gt; &lt;ul&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;Elb.RegistrationInProgress&lt;/code&gt; - The target is in the process of being
     * registered with the load balancer.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;
     * &lt;code&gt;Elb.InitialHealthChecking&lt;/code&gt; - The load balancer is still sending the target the minimum
     * number of health checks required to determine its health status.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If
     * the target state is &lt;code&gt;unhealthy&lt;/code&gt;, the reason code can be one of the following
     * values:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.ResponseCodeMismatch&lt;/code&gt; - The
     * health checks did not return an expected HTTP code. Applies only to Application Load Balancers and Gateway Load
     * Balancers.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.Timeout&lt;/code&gt; - The health check
     * requests timed out. Applies only to Application Load Balancers and Gateway Load Balancers.&lt;/p&gt; &lt;/li&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.FailedHealthChecks&lt;/code&gt; - The load balancer received an error
     * while establishing a connection to the target or the target response was malformed.&lt;/p&gt; &lt;/li&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;Elb.InternalError&lt;/code&gt; - The health checks failed due to an internal
     * error. Applies only to Application Load Balancers.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If the target state
     * is &lt;code&gt;unused&lt;/code&gt;, the reason code can be one of the following values:&lt;/p&gt; &lt;ul&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.NotRegistered&lt;/code&gt; - The target is not registered with the target
     * group.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.NotInUse&lt;/code&gt; - The target group is
     * not used by any load balancer or the target is in an Availability Zone that is not enabled for its load
     * balancer.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.InvalidState&lt;/code&gt; - The target is
     * in the stopped or terminated state.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;
     * &lt;code&gt;Target.IpUnusable&lt;/code&gt; - The target IP address is reserved for use by a load
     * balancer.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If the target state is &lt;code&gt;draining&lt;/code&gt;,
     * the reason code can be the following value:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;
     * &lt;code&gt;Target.DeregistrationInProgress&lt;/code&gt; - The target is in the process of being deregistered and
     * the deregistration delay period has not expired.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If the target state
     * is &lt;code&gt;unavailable&lt;/code&gt;, the reason code can be the following value:&lt;/p&gt; &lt;ul&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.HealthCheckDisabled&lt;/code&gt; - Health checks are disabled for the
     * target group. Applies only to Application Load Balancers.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;
     * &lt;code&gt;Elb.InternalError&lt;/code&gt; - Target health is unavailable due to an internal error. Applies only
     * to Network Load Balancers.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @return the reason value.
     */
    public TargetHealthReasonEnumValue reason() {
        return this.reason;
    }

    /**
     * Set the reason property: &lt;p&gt;The reason code.&lt;/p&gt; &lt;p&gt;If the target state is
     * &lt;code&gt;healthy&lt;/code&gt;, a reason code is not provided.&lt;/p&gt; &lt;p&gt;If the target state is
     * &lt;code&gt;initial&lt;/code&gt;, the reason code can be one of the following values:&lt;/p&gt; &lt;ul&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;Elb.RegistrationInProgress&lt;/code&gt; - The target is in the process of being
     * registered with the load balancer.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;
     * &lt;code&gt;Elb.InitialHealthChecking&lt;/code&gt; - The load balancer is still sending the target the minimum
     * number of health checks required to determine its health status.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If
     * the target state is &lt;code&gt;unhealthy&lt;/code&gt;, the reason code can be one of the following
     * values:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.ResponseCodeMismatch&lt;/code&gt; - The
     * health checks did not return an expected HTTP code. Applies only to Application Load Balancers and Gateway Load
     * Balancers.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.Timeout&lt;/code&gt; - The health check
     * requests timed out. Applies only to Application Load Balancers and Gateway Load Balancers.&lt;/p&gt; &lt;/li&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.FailedHealthChecks&lt;/code&gt; - The load balancer received an error
     * while establishing a connection to the target or the target response was malformed.&lt;/p&gt; &lt;/li&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;Elb.InternalError&lt;/code&gt; - The health checks failed due to an internal
     * error. Applies only to Application Load Balancers.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If the target state
     * is &lt;code&gt;unused&lt;/code&gt;, the reason code can be one of the following values:&lt;/p&gt; &lt;ul&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.NotRegistered&lt;/code&gt; - The target is not registered with the target
     * group.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.NotInUse&lt;/code&gt; - The target group is
     * not used by any load balancer or the target is in an Availability Zone that is not enabled for its load
     * balancer.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.InvalidState&lt;/code&gt; - The target is
     * in the stopped or terminated state.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;
     * &lt;code&gt;Target.IpUnusable&lt;/code&gt; - The target IP address is reserved for use by a load
     * balancer.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If the target state is &lt;code&gt;draining&lt;/code&gt;,
     * the reason code can be the following value:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;
     * &lt;code&gt;Target.DeregistrationInProgress&lt;/code&gt; - The target is in the process of being deregistered and
     * the deregistration delay period has not expired.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;If the target state
     * is &lt;code&gt;unavailable&lt;/code&gt;, the reason code can be the following value:&lt;/p&gt; &lt;ul&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;Target.HealthCheckDisabled&lt;/code&gt; - Health checks are disabled for the
     * target group. Applies only to Application Load Balancers.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;
     * &lt;code&gt;Elb.InternalError&lt;/code&gt; - Target health is unavailable due to an internal error. Applies only
     * to Network Load Balancers.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @param reason the reason value to set.
     * @return the TargetHealth object itself.
     */
    public TargetHealth withReason(TargetHealthReasonEnumValue reason) {
        this.reason = reason;
        return this;
    }

    /**
     * Get the state property: &lt;p&gt;The state of the target.&lt;/p&gt;.
     * 
     * @return the state value.
     */
    public TargetHealthStateEnumValue state() {
        return this.state;
    }

    /**
     * Set the state property: &lt;p&gt;The state of the target.&lt;/p&gt;.
     * 
     * @param state the state value to set.
     * @return the TargetHealth object itself.
     */
    public TargetHealth withState(TargetHealthStateEnumValue state) {
        this.state = state;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (reason() != null) {
            reason().validate();
        }
        if (state() != null) {
            state().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("description", this.description);
        jsonWriter.writeJsonField("reason", this.reason);
        jsonWriter.writeJsonField("state", this.state);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TargetHealth from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TargetHealth if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the TargetHealth.
     */
    public static TargetHealth fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            TargetHealth deserializedTargetHealth = new TargetHealth();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("description".equals(fieldName)) {
                    deserializedTargetHealth.description = reader.getString();
                } else if ("reason".equals(fieldName)) {
                    deserializedTargetHealth.reason = TargetHealthReasonEnumValue.fromJson(reader);
                } else if ("state".equals(fieldName)) {
                    deserializedTargetHealth.state = TargetHealthStateEnumValue.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedTargetHealth;
        });
    }
}
