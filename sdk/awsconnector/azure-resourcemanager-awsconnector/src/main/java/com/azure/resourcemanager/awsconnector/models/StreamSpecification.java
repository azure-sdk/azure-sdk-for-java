// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Definition of StreamSpecification.
 */
@Fluent
public final class StreamSpecification implements JsonSerializable<StreamSpecification> {
    /*
     * Creates or updates a resource-based policy document that contains the permissions for DDB resources, such as a
     * table's streams. Resource-based policies let you define access permissions by specifying who has access to each
     * resource, and the actions they are allowed to perform on each resource. In a CFNshort template, you can provide
     * the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For more
     * information about resource-based policies, see [Using resource-based policies
     * for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and
     * [Resource-based policy
     * examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). Creates or
     * updates a resource-based policy document that contains the permissions for DDB resources, such as a table, its
     * indexes, and stream. Resource-based policies let you define access permissions by specifying who has access to
     * each resource, and the actions they are allowed to perform on each resource. In a CFNshort template, you can
     * provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For
     * more information about resource-based policies, see [Using resource-based policies
     * for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and
     * [Resource-based policy
     * examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). While defining
     * resource-based policies in your CFNshort templates, the following considerations apply: + The maximum size
     * supported for a resource-based policy document in JSON format is 20 KB. DDB counts whitespaces when calculating
     * the size of a policy against this limit. + Resource-based policies don't support [drift
     * detection](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html#). If you
     * update a policy outside of the CFNshort stack template, you'll need to update the CFNshort stack with the
     * changes. + Resource-based policies don't support out-of-band changes. If you add, update, or delete a policy
     * outside of the CFNshort template, the change won't be overwritten if there are no changes to the policy within
     * the template. For example, say that your template contains a resource-based policy, which you later update
     * outside of the template. If you don't make any changes to the policy in the template, the updated policy in DDB
     * won’t be synced with the policy in the template. Conversely, say that your template doesn’t contain a
     * resource-based policy, but you add a policy outside of the template. This policy won’t be removed from DDB as
     * long as you don’t add it to the template. When you add a policy to the template and update the stack, the
     * existing policy in DDB will be updated to match the one defined in the template. For a full list of all
     * considerations, see [Resource-based policy
     * considerations](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html).
     */
    private ResourcePolicy resourcePolicy;

    /*
     * When an item in the table is modified, ``StreamViewType`` determines what information is written to the stream
     * for this table. Valid values for ``StreamViewType`` are: + ``KEYS_ONLY`` - Only the key attributes of the
     * modified item are written to the stream. + ``NEW_IMAGE`` - The entire item, as it appears after it was modified,
     * is written to the stream. + ``OLD_IMAGE`` - The entire item, as it appeared before it was modified, is written to
     * the stream. + ``NEW_AND_OLD_IMAGES`` - Both the new and the old item images of the item are written to the
     * stream.
     */
    private String streamViewType;

    /**
     * Creates an instance of StreamSpecification class.
     */
    public StreamSpecification() {
    }

    /**
     * Get the resourcePolicy property: Creates or updates a resource-based policy document that contains the
     * permissions for DDB resources, such as a table's streams. Resource-based policies let you define access
     * permissions by specifying who has access to each resource, and the actions they are allowed to perform on each
     * resource. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts
     * YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using
     * resource-based policies
     * for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and
     * [Resource-based policy
     * examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). Creates or
     * updates a resource-based policy document that contains the permissions for DDB resources, such as a table, its
     * indexes, and stream. Resource-based policies let you define access permissions by specifying who has access to
     * each resource, and the actions they are allowed to perform on each resource. In a CFNshort template, you can
     * provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For
     * more information about resource-based policies, see [Using resource-based policies
     * for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and
     * [Resource-based policy
     * examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). While defining
     * resource-based policies in your CFNshort templates, the following considerations apply: + The maximum size
     * supported for a resource-based policy document in JSON format is 20 KB. DDB counts whitespaces when calculating
     * the size of a policy against this limit. + Resource-based policies don't support [drift
     * detection](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html#). If you
     * update a policy outside of the CFNshort stack template, you'll need to update the CFNshort stack with the
     * changes. + Resource-based policies don't support out-of-band changes. If you add, update, or delete a policy
     * outside of the CFNshort template, the change won't be overwritten if there are no changes to the policy within
     * the template. For example, say that your template contains a resource-based policy, which you later update
     * outside of the template. If you don't make any changes to the policy in the template, the updated policy in DDB
     * won’t be synced with the policy in the template. Conversely, say that your template doesn’t contain a
     * resource-based policy, but you add a policy outside of the template. This policy won’t be removed from DDB as
     * long as you don’t add it to the template. When you add a policy to the template and update the stack, the
     * existing policy in DDB will be updated to match the one defined in the template. For a full list of all
     * considerations, see [Resource-based policy
     * considerations](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html).
     * 
     * @return the resourcePolicy value.
     */
    public ResourcePolicy resourcePolicy() {
        return this.resourcePolicy;
    }

    /**
     * Set the resourcePolicy property: Creates or updates a resource-based policy document that contains the
     * permissions for DDB resources, such as a table's streams. Resource-based policies let you define access
     * permissions by specifying who has access to each resource, and the actions they are allowed to perform on each
     * resource. In a CFNshort template, you can provide the policy in JSON or YAML format because CFNshort converts
     * YAML to JSON before submitting it to DDB. For more information about resource-based policies, see [Using
     * resource-based policies
     * for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and
     * [Resource-based policy
     * examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). Creates or
     * updates a resource-based policy document that contains the permissions for DDB resources, such as a table, its
     * indexes, and stream. Resource-based policies let you define access permissions by specifying who has access to
     * each resource, and the actions they are allowed to perform on each resource. In a CFNshort template, you can
     * provide the policy in JSON or YAML format because CFNshort converts YAML to JSON before submitting it to DDB. For
     * more information about resource-based policies, see [Using resource-based policies
     * for](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/access-control-resource-based.html) and
     * [Resource-based policy
     * examples](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-examples.html). While defining
     * resource-based policies in your CFNshort templates, the following considerations apply: + The maximum size
     * supported for a resource-based policy document in JSON format is 20 KB. DDB counts whitespaces when calculating
     * the size of a policy against this limit. + Resource-based policies don't support [drift
     * detection](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-stack-drift.html#). If you
     * update a policy outside of the CFNshort stack template, you'll need to update the CFNshort stack with the
     * changes. + Resource-based policies don't support out-of-band changes. If you add, update, or delete a policy
     * outside of the CFNshort template, the change won't be overwritten if there are no changes to the policy within
     * the template. For example, say that your template contains a resource-based policy, which you later update
     * outside of the template. If you don't make any changes to the policy in the template, the updated policy in DDB
     * won’t be synced with the policy in the template. Conversely, say that your template doesn’t contain a
     * resource-based policy, but you add a policy outside of the template. This policy won’t be removed from DDB as
     * long as you don’t add it to the template. When you add a policy to the template and update the stack, the
     * existing policy in DDB will be updated to match the one defined in the template. For a full list of all
     * considerations, see [Resource-based policy
     * considerations](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/rbac-considerations.html).
     * 
     * @param resourcePolicy the resourcePolicy value to set.
     * @return the StreamSpecification object itself.
     */
    public StreamSpecification withResourcePolicy(ResourcePolicy resourcePolicy) {
        this.resourcePolicy = resourcePolicy;
        return this;
    }

    /**
     * Get the streamViewType property: When an item in the table is modified, ``StreamViewType`` determines what
     * information is written to the stream for this table. Valid values for ``StreamViewType`` are: + ``KEYS_ONLY`` -
     * Only the key attributes of the modified item are written to the stream. + ``NEW_IMAGE`` - The entire item, as it
     * appears after it was modified, is written to the stream. + ``OLD_IMAGE`` - The entire item, as it appeared before
     * it was modified, is written to the stream. + ``NEW_AND_OLD_IMAGES`` - Both the new and the old item images of the
     * item are written to the stream.
     * 
     * @return the streamViewType value.
     */
    public String streamViewType() {
        return this.streamViewType;
    }

    /**
     * Set the streamViewType property: When an item in the table is modified, ``StreamViewType`` determines what
     * information is written to the stream for this table. Valid values for ``StreamViewType`` are: + ``KEYS_ONLY`` -
     * Only the key attributes of the modified item are written to the stream. + ``NEW_IMAGE`` - The entire item, as it
     * appears after it was modified, is written to the stream. + ``OLD_IMAGE`` - The entire item, as it appeared before
     * it was modified, is written to the stream. + ``NEW_AND_OLD_IMAGES`` - Both the new and the old item images of the
     * item are written to the stream.
     * 
     * @param streamViewType the streamViewType value to set.
     * @return the StreamSpecification object itself.
     */
    public StreamSpecification withStreamViewType(String streamViewType) {
        this.streamViewType = streamViewType;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (resourcePolicy() != null) {
            resourcePolicy().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("resourcePolicy", this.resourcePolicy);
        jsonWriter.writeStringField("streamViewType", this.streamViewType);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of StreamSpecification from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of StreamSpecification if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the StreamSpecification.
     */
    public static StreamSpecification fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            StreamSpecification deserializedStreamSpecification = new StreamSpecification();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("resourcePolicy".equals(fieldName)) {
                    deserializedStreamSpecification.resourcePolicy = ResourcePolicy.fromJson(reader);
                } else if ("streamViewType".equals(fieldName)) {
                    deserializedStreamSpecification.streamViewType = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedStreamSpecification;
        });
    }
}
