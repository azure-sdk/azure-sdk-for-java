// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Definition of awsEcsService.
 */
@Fluent
public final class AwsEcsServiceProperties implements JsonSerializable<AwsEcsServiceProperties> {
    /*
     * The capacity provider strategy to use for the service. If a ``capacityProviderStrategy`` is specified, the
     * ``launchType`` parameter must be omitted. If no ``capacityProviderStrategy`` or ``launchType`` is specified, the
     * ``defaultCapacityProviderStrategy`` for the cluster is used. A capacity provider strategy may contain a maximum
     * of 6 capacity providers.
     */
    private List<CapacityProviderStrategyItem> capacityProviderStrategy;

    /*
     * The short name or full Amazon Resource Name (ARN) of the cluster that you run your service on. If you do not
     * specify a cluster, the default cluster is assumed.
     */
    private String cluster;

    /*
     * Optional deployment parameters that control how many tasks run during the deployment and the ordering of stopping
     * and starting tasks. The ``DeploymentConfiguration`` property specifies optional deployment parameters that
     * control how many tasks run during the deployment and the ordering of stopping and starting tasks.
     */
    private DeploymentConfiguration deploymentConfiguration;

    /*
     * The deployment controller to use for the service. If no deployment controller is specified, the default value of
     * ``ECS`` is used. The deployment controller to use for the service. For more information, see [Amazon ECS
     * deployment types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html) in the
     * *Amazon Elastic Container Service Developer Guide*.
     */
    private DeploymentController deploymentController;

    /*
     * The number of instantiations of the specified task definition to place and keep running in your service. For new
     * services, if a desired count is not specified, a default value of ``1`` is used. When using the ``DAEMON``
     * scheduling strategy, the desired count is not required. For existing services, if a desired count is not
     * specified, it is omitted from the operation.
     */
    private Integer desiredCount;

    /*
     * Specifies whether to turn on Amazon ECS managed tags for the tasks within the service. For more information, see
     * [Tagging your Amazon ECS
     * resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the *Amazon
     * Elastic Container Service Developer Guide*. When you use Amazon ECS managed tags, you need to set the
     * ``propagateTags`` request parameter.
     */
    private Boolean enableEcsManagedTags;

    /*
     * Determines whether the execute command functionality is turned on for the service. If ``true``, the execute
     * command functionality is turned on for all containers in tasks as part of the service.
     */
    private Boolean enableExecuteCommand;

    /*
     * The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing
     * target health checks after a task has first started. This is only used when your service is configured to use a
     * load balancer. If your service has a load balancer defined and you don't specify a health check grace period
     * value, the default value of ``0`` is used. If you do not use an Elastic Load Balancing, we recommend that you use
     * the ``startPeriod`` in the task definition health check parameters. For more information, see [Health
     * check](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_HealthCheck.html). If your service's tasks
     * take a while to start and respond to Elastic Load Balancing health checks, you can specify a health check grace
     * period of up to 2,147,483,647 seconds (about 69 years). During that time, the Amazon ECS service scheduler
     * ignores health check status. This grace period can prevent the service scheduler from marking tasks as unhealthy
     * and stopping them before they have time to come up.
     */
    private Integer healthCheckGracePeriodSeconds;

    /*
     * The launch type on which to run your service. For more information, see [Amazon ECS Launch
     * Types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) in the *Amazon Elastic
     * Container Service Developer Guide*.
     */
    private LaunchType launchType;

    /*
     * A list of load balancer objects to associate with the service. If you specify the ``Role`` property,
     * ``LoadBalancers`` must be specified as well. For information about the number of load balancers that you can
     * specify per service, see [Service Load
     * Balancing](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html) in the
     * *Amazon Elastic Container Service Developer Guide*.
     */
    private List<LoadBalancer> loadBalancers;

    /*
     * Property name
     */
    private String name;

    /*
     * The network configuration for the service. This parameter is required for task definitions that use the
     * ``awsvpc`` network mode to receive their own elastic network interface, and it is not supported for other network
     * modes. For more information, see [Task
     * Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html) in the *Amazon
     * Elastic Container Service Developer Guide*. The ``NetworkConfiguration`` property specifies an object
     * representing the network configuration for a task or service.
     */
    private NetworkConfiguration networkConfiguration;

    /*
     * An array of placement constraint objects to use for tasks in your service. You can specify a maximum of 10
     * constraints for each task. This limit includes constraints in the task definition and those specified at runtime.
     */
    private List<PlacementConstraint> placementConstraints;

    /*
     * The placement strategy objects to use for tasks in your service. You can specify a maximum of 5 strategy rules
     * for each service.
     */
    private List<PlacementStrategy> placementStrategies;

    /*
     * The platform version that your tasks in the service are running on. A platform version is specified only for
     * tasks using the Fargate launch type. If one isn't specified, the ``LATEST`` platform version is used. For more
     * information, see [platform
     * versions](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html) in the *Amazon
     * Elastic Container Service Developer Guide*.
     */
    private String platformVersion;

    /*
     * Specifies whether to propagate the tags from the task definition to the task. If no value is specified, the tags
     * aren't propagated. Tags can only be propagated to the task during task creation. To add tags to a task after task
     * creation, use the [TagResource](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html)
     * API action. The default is ``NONE``.
     */
    private PropagateTags propagateTags;

    /*
     * The name or full Amazon Resource Name (ARN) of the IAM role that allows Amazon ECS to make calls to your load
     * balancer on your behalf. This parameter is only permitted if you are using a load balancer with your service and
     * your task definition doesn't use the ``awsvpc`` network mode. If you specify the ``role`` parameter, you must
     * also specify a load balancer object with the ``loadBalancers`` parameter. If your account has already created the
     * Amazon ECS service-linked role, that role is used for your service unless you specify a role here. The
     * service-linked role is required if your task definition uses the ``awsvpc`` network mode or if the service is
     * configured to use service discovery, an external deployment controller, multiple target groups, or Elastic
     * Inference accelerators in which case you don't specify a role here. For more information, see [Using
     * service-linked roles for Amazon
     * ECS](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html) in the *Amazon
     * Elastic Container Service Developer Guide*. If your specified role has a path other than ``/``, then you must
     * either specify the full role ARN (this is recommended) or prefix the role name with the path. For example, if a
     * role with the name ``bar`` has a path of ``/foo/`` then you would specify ``/foo/bar`` as the role name. For more
     * information, see [Friendly names and
     * paths](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) in
     * the *IAM User Guide*.
     */
    private String role;

    /*
     * The scheduling strategy to use for the service. For more information, see
     * [Services](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html). There are two service
     * scheduler strategies available: + ``REPLICA``-The replica scheduling strategy places and maintains the desired
     * number of tasks across your cluster. By default, the service scheduler spreads tasks across Availability Zones.
     * You can use task placement strategies and constraints to customize task placement decisions. This scheduler
     * strategy is required if the service uses the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types. +
     * ``DAEMON``-The daemon scheduling strategy deploys exactly one task on each active container instance that meets
     * all of the task placement constraints that you specify in your cluster. The service scheduler also evaluates the
     * task placement constraints for running tasks and will stop tasks that don't meet the placement constraints. When
     * you're using this strategy, you don't need to specify a desired number of tasks, a task placement strategy, or
     * use Service Auto Scaling policies. Tasks using the Fargate launch type or the ``CODE_DEPLOY`` or ``EXTERNAL``
     * deployment controller types don't support the ``DAEMON`` scheduling strategy.
     */
    private SchedulingStrategy schedulingStrategy;

    /*
     * Property serviceArn
     */
    private String serviceArn;

    /*
     * The configuration for this service to discover and connect to services, and be discovered by, and connected from,
     * other services within a namespace. Tasks that run in a namespace can use short names to connect to services in
     * the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a
     * managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS
     * services create are supported with Service Connect. For more information, see [Service
     * Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic
     * Container Service Developer Guide*. The Service Connect configuration of your Amazon ECS service. The
     * configuration for this service to discover and connect to services, and be discovered by, and connected from,
     * other services within a namespace. Tasks that run in a namespace can use short names to connect to services in
     * the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a
     * managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS
     * services create are supported with Service Connect. For more information, see [Service
     * Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic
     * Container Service Developer Guide*.
     */
    private ServiceConnectConfiguration serviceConnectConfiguration;

    /*
     * The name of your service. Up to 255 letters (uppercase and lowercase), numbers, underscores, and hyphens are
     * allowed. Service names must be unique within a cluster, but you can have similarly named services in multiple
     * clusters within a Region or across multiple Regions. The stack update fails if you change any properties that
     * require replacement and the ``ServiceName`` is configured. This is because AWS CloudFormation creates the
     * replacement service first, but each ``ServiceName`` must be unique in the cluster.
     */
    private String serviceName;

    /*
     * The details of the service discovery registry to associate with this service. For more information, see [Service
     * discovery](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html). Each service may
     * be associated with one service registry. Multiple service registries for each service isn't supported.
     */
    private List<ServiceRegistry> serviceRegistries;

    /*
     * The metadata that you apply to the service to help you categorize and organize them. Each tag consists of a key
     * and an optional value, both of which you define. When a service is deleted, the tags are deleted as well. The
     * following basic restrictions apply to tags: + Maximum number of tags per resource - 50 + For each resource, each
     * tag key must be unique, and each tag key can have only one value. + Maximum key length - 128 Unicode characters
     * in UTF-8 + Maximum value length - 256 Unicode characters in UTF-8 + If your tagging schema is used across
     * multiple services and resources, remember that other services may have restrictions on allowed characters.
     * Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the following
     * characters: + - = . _ : / @. + Tag keys and values are case-sensitive. + Do not use ``aws:``, ``AWS:``, or any
     * upper or lowercase combination of such as a prefix for either keys or values as it is reserved for AWS use. You
     * cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count against your tags
     * per resource limit.
     */
    private List<TagAutoGenerated26> tags;

    /*
     * The ``family`` and ``revision`` (``family:revision``) or full ARN of the task definition to run in your service.
     * If a ``revision`` isn't specified, the latest ``ACTIVE`` revision is used. A task definition must be specified if
     * the service uses either the ``ECS`` or ``CODE_DEPLOY`` deployment controllers. For more information about
     * deployment types, see [Amazon ECS deployment
     * types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html).
     */
    private String taskDefinition;

    /*
     * The configuration for a volume specified in the task definition as a volume that is configured at launch time.
     * Currently, the only supported volume type is an Amazon EBS volume.
     */
    private List<ServiceVolumeConfiguration> volumeConfigurations;

    /**
     * Creates an instance of AwsEcsServiceProperties class.
     */
    public AwsEcsServiceProperties() {
    }

    /**
     * Get the capacityProviderStrategy property: The capacity provider strategy to use for the service. If a
     * ``capacityProviderStrategy`` is specified, the ``launchType`` parameter must be omitted. If no
     * ``capacityProviderStrategy`` or ``launchType`` is specified, the ``defaultCapacityProviderStrategy`` for the
     * cluster is used. A capacity provider strategy may contain a maximum of 6 capacity providers.
     * 
     * @return the capacityProviderStrategy value.
     */
    public List<CapacityProviderStrategyItem> capacityProviderStrategy() {
        return this.capacityProviderStrategy;
    }

    /**
     * Set the capacityProviderStrategy property: The capacity provider strategy to use for the service. If a
     * ``capacityProviderStrategy`` is specified, the ``launchType`` parameter must be omitted. If no
     * ``capacityProviderStrategy`` or ``launchType`` is specified, the ``defaultCapacityProviderStrategy`` for the
     * cluster is used. A capacity provider strategy may contain a maximum of 6 capacity providers.
     * 
     * @param capacityProviderStrategy the capacityProviderStrategy value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties
        withCapacityProviderStrategy(List<CapacityProviderStrategyItem> capacityProviderStrategy) {
        this.capacityProviderStrategy = capacityProviderStrategy;
        return this;
    }

    /**
     * Get the cluster property: The short name or full Amazon Resource Name (ARN) of the cluster that you run your
     * service on. If you do not specify a cluster, the default cluster is assumed.
     * 
     * @return the cluster value.
     */
    public String cluster() {
        return this.cluster;
    }

    /**
     * Set the cluster property: The short name or full Amazon Resource Name (ARN) of the cluster that you run your
     * service on. If you do not specify a cluster, the default cluster is assumed.
     * 
     * @param cluster the cluster value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withCluster(String cluster) {
        this.cluster = cluster;
        return this;
    }

    /**
     * Get the deploymentConfiguration property: Optional deployment parameters that control how many tasks run during
     * the deployment and the ordering of stopping and starting tasks. The ``DeploymentConfiguration`` property
     * specifies optional deployment parameters that control how many tasks run during the deployment and the ordering
     * of stopping and starting tasks.
     * 
     * @return the deploymentConfiguration value.
     */
    public DeploymentConfiguration deploymentConfiguration() {
        return this.deploymentConfiguration;
    }

    /**
     * Set the deploymentConfiguration property: Optional deployment parameters that control how many tasks run during
     * the deployment and the ordering of stopping and starting tasks. The ``DeploymentConfiguration`` property
     * specifies optional deployment parameters that control how many tasks run during the deployment and the ordering
     * of stopping and starting tasks.
     * 
     * @param deploymentConfiguration the deploymentConfiguration value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withDeploymentConfiguration(DeploymentConfiguration deploymentConfiguration) {
        this.deploymentConfiguration = deploymentConfiguration;
        return this;
    }

    /**
     * Get the deploymentController property: The deployment controller to use for the service. If no deployment
     * controller is specified, the default value of ``ECS`` is used. The deployment controller to use for the service.
     * For more information, see [Amazon ECS deployment
     * types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html) in the *Amazon Elastic
     * Container Service Developer Guide*.
     * 
     * @return the deploymentController value.
     */
    public DeploymentController deploymentController() {
        return this.deploymentController;
    }

    /**
     * Set the deploymentController property: The deployment controller to use for the service. If no deployment
     * controller is specified, the default value of ``ECS`` is used. The deployment controller to use for the service.
     * For more information, see [Amazon ECS deployment
     * types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html) in the *Amazon Elastic
     * Container Service Developer Guide*.
     * 
     * @param deploymentController the deploymentController value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withDeploymentController(DeploymentController deploymentController) {
        this.deploymentController = deploymentController;
        return this;
    }

    /**
     * Get the desiredCount property: The number of instantiations of the specified task definition to place and keep
     * running in your service. For new services, if a desired count is not specified, a default value of ``1`` is used.
     * When using the ``DAEMON`` scheduling strategy, the desired count is not required. For existing services, if a
     * desired count is not specified, it is omitted from the operation.
     * 
     * @return the desiredCount value.
     */
    public Integer desiredCount() {
        return this.desiredCount;
    }

    /**
     * Set the desiredCount property: The number of instantiations of the specified task definition to place and keep
     * running in your service. For new services, if a desired count is not specified, a default value of ``1`` is used.
     * When using the ``DAEMON`` scheduling strategy, the desired count is not required. For existing services, if a
     * desired count is not specified, it is omitted from the operation.
     * 
     * @param desiredCount the desiredCount value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withDesiredCount(Integer desiredCount) {
        this.desiredCount = desiredCount;
        return this;
    }

    /**
     * Get the enableEcsManagedTags property: Specifies whether to turn on Amazon ECS managed tags for the tasks within
     * the service. For more information, see [Tagging your Amazon ECS
     * resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the *Amazon
     * Elastic Container Service Developer Guide*. When you use Amazon ECS managed tags, you need to set the
     * ``propagateTags`` request parameter.
     * 
     * @return the enableEcsManagedTags value.
     */
    public Boolean enableEcsManagedTags() {
        return this.enableEcsManagedTags;
    }

    /**
     * Set the enableEcsManagedTags property: Specifies whether to turn on Amazon ECS managed tags for the tasks within
     * the service. For more information, see [Tagging your Amazon ECS
     * resources](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html) in the *Amazon
     * Elastic Container Service Developer Guide*. When you use Amazon ECS managed tags, you need to set the
     * ``propagateTags`` request parameter.
     * 
     * @param enableEcsManagedTags the enableEcsManagedTags value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withEnableEcsManagedTags(Boolean enableEcsManagedTags) {
        this.enableEcsManagedTags = enableEcsManagedTags;
        return this;
    }

    /**
     * Get the enableExecuteCommand property: Determines whether the execute command functionality is turned on for the
     * service. If ``true``, the execute command functionality is turned on for all containers in tasks as part of the
     * service.
     * 
     * @return the enableExecuteCommand value.
     */
    public Boolean enableExecuteCommand() {
        return this.enableExecuteCommand;
    }

    /**
     * Set the enableExecuteCommand property: Determines whether the execute command functionality is turned on for the
     * service. If ``true``, the execute command functionality is turned on for all containers in tasks as part of the
     * service.
     * 
     * @param enableExecuteCommand the enableExecuteCommand value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withEnableExecuteCommand(Boolean enableExecuteCommand) {
        this.enableExecuteCommand = enableExecuteCommand;
        return this;
    }

    /**
     * Get the healthCheckGracePeriodSeconds property: The period of time, in seconds, that the Amazon ECS service
     * scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. This is
     * only used when your service is configured to use a load balancer. If your service has a load balancer defined and
     * you don't specify a health check grace period value, the default value of ``0`` is used. If you do not use an
     * Elastic Load Balancing, we recommend that you use the ``startPeriod`` in the task definition health check
     * parameters. For more information, see [Health
     * check](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_HealthCheck.html). If your service's tasks
     * take a while to start and respond to Elastic Load Balancing health checks, you can specify a health check grace
     * period of up to 2,147,483,647 seconds (about 69 years). During that time, the Amazon ECS service scheduler
     * ignores health check status. This grace period can prevent the service scheduler from marking tasks as unhealthy
     * and stopping them before they have time to come up.
     * 
     * @return the healthCheckGracePeriodSeconds value.
     */
    public Integer healthCheckGracePeriodSeconds() {
        return this.healthCheckGracePeriodSeconds;
    }

    /**
     * Set the healthCheckGracePeriodSeconds property: The period of time, in seconds, that the Amazon ECS service
     * scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. This is
     * only used when your service is configured to use a load balancer. If your service has a load balancer defined and
     * you don't specify a health check grace period value, the default value of ``0`` is used. If you do not use an
     * Elastic Load Balancing, we recommend that you use the ``startPeriod`` in the task definition health check
     * parameters. For more information, see [Health
     * check](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_HealthCheck.html). If your service's tasks
     * take a while to start and respond to Elastic Load Balancing health checks, you can specify a health check grace
     * period of up to 2,147,483,647 seconds (about 69 years). During that time, the Amazon ECS service scheduler
     * ignores health check status. This grace period can prevent the service scheduler from marking tasks as unhealthy
     * and stopping them before they have time to come up.
     * 
     * @param healthCheckGracePeriodSeconds the healthCheckGracePeriodSeconds value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withHealthCheckGracePeriodSeconds(Integer healthCheckGracePeriodSeconds) {
        this.healthCheckGracePeriodSeconds = healthCheckGracePeriodSeconds;
        return this;
    }

    /**
     * Get the launchType property: The launch type on which to run your service. For more information, see [Amazon ECS
     * Launch Types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) in the *Amazon
     * Elastic Container Service Developer Guide*.
     * 
     * @return the launchType value.
     */
    public LaunchType launchType() {
        return this.launchType;
    }

    /**
     * Set the launchType property: The launch type on which to run your service. For more information, see [Amazon ECS
     * Launch Types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) in the *Amazon
     * Elastic Container Service Developer Guide*.
     * 
     * @param launchType the launchType value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withLaunchType(LaunchType launchType) {
        this.launchType = launchType;
        return this;
    }

    /**
     * Get the loadBalancers property: A list of load balancer objects to associate with the service. If you specify the
     * ``Role`` property, ``LoadBalancers`` must be specified as well. For information about the number of load
     * balancers that you can specify per service, see [Service Load
     * Balancing](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html) in the
     * *Amazon Elastic Container Service Developer Guide*.
     * 
     * @return the loadBalancers value.
     */
    public List<LoadBalancer> loadBalancers() {
        return this.loadBalancers;
    }

    /**
     * Set the loadBalancers property: A list of load balancer objects to associate with the service. If you specify the
     * ``Role`` property, ``LoadBalancers`` must be specified as well. For information about the number of load
     * balancers that you can specify per service, see [Service Load
     * Balancing](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-load-balancing.html) in the
     * *Amazon Elastic Container Service Developer Guide*.
     * 
     * @param loadBalancers the loadBalancers value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withLoadBalancers(List<LoadBalancer> loadBalancers) {
        this.loadBalancers = loadBalancers;
        return this;
    }

    /**
     * Get the name property: Property name.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Set the name property: Property name.
     * 
     * @param name the name value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get the networkConfiguration property: The network configuration for the service. This parameter is required for
     * task definitions that use the ``awsvpc`` network mode to receive their own elastic network interface, and it is
     * not supported for other network modes. For more information, see [Task
     * Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html) in the *Amazon
     * Elastic Container Service Developer Guide*. The ``NetworkConfiguration`` property specifies an object
     * representing the network configuration for a task or service.
     * 
     * @return the networkConfiguration value.
     */
    public NetworkConfiguration networkConfiguration() {
        return this.networkConfiguration;
    }

    /**
     * Set the networkConfiguration property: The network configuration for the service. This parameter is required for
     * task definitions that use the ``awsvpc`` network mode to receive their own elastic network interface, and it is
     * not supported for other network modes. For more information, see [Task
     * Networking](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task-networking.html) in the *Amazon
     * Elastic Container Service Developer Guide*. The ``NetworkConfiguration`` property specifies an object
     * representing the network configuration for a task or service.
     * 
     * @param networkConfiguration the networkConfiguration value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withNetworkConfiguration(NetworkConfiguration networkConfiguration) {
        this.networkConfiguration = networkConfiguration;
        return this;
    }

    /**
     * Get the placementConstraints property: An array of placement constraint objects to use for tasks in your service.
     * You can specify a maximum of 10 constraints for each task. This limit includes constraints in the task definition
     * and those specified at runtime.
     * 
     * @return the placementConstraints value.
     */
    public List<PlacementConstraint> placementConstraints() {
        return this.placementConstraints;
    }

    /**
     * Set the placementConstraints property: An array of placement constraint objects to use for tasks in your service.
     * You can specify a maximum of 10 constraints for each task. This limit includes constraints in the task definition
     * and those specified at runtime.
     * 
     * @param placementConstraints the placementConstraints value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withPlacementConstraints(List<PlacementConstraint> placementConstraints) {
        this.placementConstraints = placementConstraints;
        return this;
    }

    /**
     * Get the placementStrategies property: The placement strategy objects to use for tasks in your service. You can
     * specify a maximum of 5 strategy rules for each service.
     * 
     * @return the placementStrategies value.
     */
    public List<PlacementStrategy> placementStrategies() {
        return this.placementStrategies;
    }

    /**
     * Set the placementStrategies property: The placement strategy objects to use for tasks in your service. You can
     * specify a maximum of 5 strategy rules for each service.
     * 
     * @param placementStrategies the placementStrategies value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withPlacementStrategies(List<PlacementStrategy> placementStrategies) {
        this.placementStrategies = placementStrategies;
        return this;
    }

    /**
     * Get the platformVersion property: The platform version that your tasks in the service are running on. A platform
     * version is specified only for tasks using the Fargate launch type. If one isn't specified, the ``LATEST``
     * platform version is used. For more information, see [platform
     * versions](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html) in the *Amazon
     * Elastic Container Service Developer Guide*.
     * 
     * @return the platformVersion value.
     */
    public String platformVersion() {
        return this.platformVersion;
    }

    /**
     * Set the platformVersion property: The platform version that your tasks in the service are running on. A platform
     * version is specified only for tasks using the Fargate launch type. If one isn't specified, the ``LATEST``
     * platform version is used. For more information, see [platform
     * versions](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html) in the *Amazon
     * Elastic Container Service Developer Guide*.
     * 
     * @param platformVersion the platformVersion value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withPlatformVersion(String platformVersion) {
        this.platformVersion = platformVersion;
        return this;
    }

    /**
     * Get the propagateTags property: Specifies whether to propagate the tags from the task definition to the task. If
     * no value is specified, the tags aren't propagated. Tags can only be propagated to the task during task creation.
     * To add tags to a task after task creation, use the
     * [TagResource](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html) API action. The
     * default is ``NONE``.
     * 
     * @return the propagateTags value.
     */
    public PropagateTags propagateTags() {
        return this.propagateTags;
    }

    /**
     * Set the propagateTags property: Specifies whether to propagate the tags from the task definition to the task. If
     * no value is specified, the tags aren't propagated. Tags can only be propagated to the task during task creation.
     * To add tags to a task after task creation, use the
     * [TagResource](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_TagResource.html) API action. The
     * default is ``NONE``.
     * 
     * @param propagateTags the propagateTags value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withPropagateTags(PropagateTags propagateTags) {
        this.propagateTags = propagateTags;
        return this;
    }

    /**
     * Get the role property: The name or full Amazon Resource Name (ARN) of the IAM role that allows Amazon ECS to make
     * calls to your load balancer on your behalf. This parameter is only permitted if you are using a load balancer
     * with your service and your task definition doesn't use the ``awsvpc`` network mode. If you specify the ``role``
     * parameter, you must also specify a load balancer object with the ``loadBalancers`` parameter. If your account has
     * already created the Amazon ECS service-linked role, that role is used for your service unless you specify a role
     * here. The service-linked role is required if your task definition uses the ``awsvpc`` network mode or if the
     * service is configured to use service discovery, an external deployment controller, multiple target groups, or
     * Elastic Inference accelerators in which case you don't specify a role here. For more information, see [Using
     * service-linked roles for Amazon
     * ECS](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html) in the *Amazon
     * Elastic Container Service Developer Guide*. If your specified role has a path other than ``/``, then you must
     * either specify the full role ARN (this is recommended) or prefix the role name with the path. For example, if a
     * role with the name ``bar`` has a path of ``/foo/`` then you would specify ``/foo/bar`` as the role name. For more
     * information, see [Friendly names and
     * paths](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) in
     * the *IAM User Guide*.
     * 
     * @return the role value.
     */
    public String role() {
        return this.role;
    }

    /**
     * Set the role property: The name or full Amazon Resource Name (ARN) of the IAM role that allows Amazon ECS to make
     * calls to your load balancer on your behalf. This parameter is only permitted if you are using a load balancer
     * with your service and your task definition doesn't use the ``awsvpc`` network mode. If you specify the ``role``
     * parameter, you must also specify a load balancer object with the ``loadBalancers`` parameter. If your account has
     * already created the Amazon ECS service-linked role, that role is used for your service unless you specify a role
     * here. The service-linked role is required if your task definition uses the ``awsvpc`` network mode or if the
     * service is configured to use service discovery, an external deployment controller, multiple target groups, or
     * Elastic Inference accelerators in which case you don't specify a role here. For more information, see [Using
     * service-linked roles for Amazon
     * ECS](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/using-service-linked-roles.html) in the *Amazon
     * Elastic Container Service Developer Guide*. If your specified role has a path other than ``/``, then you must
     * either specify the full role ARN (this is recommended) or prefix the role name with the path. For example, if a
     * role with the name ``bar`` has a path of ``/foo/`` then you would specify ``/foo/bar`` as the role name. For more
     * information, see [Friendly names and
     * paths](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) in
     * the *IAM User Guide*.
     * 
     * @param role the role value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withRole(String role) {
        this.role = role;
        return this;
    }

    /**
     * Get the schedulingStrategy property: The scheduling strategy to use for the service. For more information, see
     * [Services](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html). There are two service
     * scheduler strategies available: + ``REPLICA``-The replica scheduling strategy places and maintains the desired
     * number of tasks across your cluster. By default, the service scheduler spreads tasks across Availability Zones.
     * You can use task placement strategies and constraints to customize task placement decisions. This scheduler
     * strategy is required if the service uses the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types. +
     * ``DAEMON``-The daemon scheduling strategy deploys exactly one task on each active container instance that meets
     * all of the task placement constraints that you specify in your cluster. The service scheduler also evaluates the
     * task placement constraints for running tasks and will stop tasks that don't meet the placement constraints. When
     * you're using this strategy, you don't need to specify a desired number of tasks, a task placement strategy, or
     * use Service Auto Scaling policies. Tasks using the Fargate launch type or the ``CODE_DEPLOY`` or ``EXTERNAL``
     * deployment controller types don't support the ``DAEMON`` scheduling strategy.
     * 
     * @return the schedulingStrategy value.
     */
    public SchedulingStrategy schedulingStrategy() {
        return this.schedulingStrategy;
    }

    /**
     * Set the schedulingStrategy property: The scheduling strategy to use for the service. For more information, see
     * [Services](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs_services.html). There are two service
     * scheduler strategies available: + ``REPLICA``-The replica scheduling strategy places and maintains the desired
     * number of tasks across your cluster. By default, the service scheduler spreads tasks across Availability Zones.
     * You can use task placement strategies and constraints to customize task placement decisions. This scheduler
     * strategy is required if the service uses the ``CODE_DEPLOY`` or ``EXTERNAL`` deployment controller types. +
     * ``DAEMON``-The daemon scheduling strategy deploys exactly one task on each active container instance that meets
     * all of the task placement constraints that you specify in your cluster. The service scheduler also evaluates the
     * task placement constraints for running tasks and will stop tasks that don't meet the placement constraints. When
     * you're using this strategy, you don't need to specify a desired number of tasks, a task placement strategy, or
     * use Service Auto Scaling policies. Tasks using the Fargate launch type or the ``CODE_DEPLOY`` or ``EXTERNAL``
     * deployment controller types don't support the ``DAEMON`` scheduling strategy.
     * 
     * @param schedulingStrategy the schedulingStrategy value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withSchedulingStrategy(SchedulingStrategy schedulingStrategy) {
        this.schedulingStrategy = schedulingStrategy;
        return this;
    }

    /**
     * Get the serviceArn property: Property serviceArn.
     * 
     * @return the serviceArn value.
     */
    public String serviceArn() {
        return this.serviceArn;
    }

    /**
     * Set the serviceArn property: Property serviceArn.
     * 
     * @param serviceArn the serviceArn value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withServiceArn(String serviceArn) {
        this.serviceArn = serviceArn;
        return this;
    }

    /**
     * Get the serviceConnectConfiguration property: The configuration for this service to discover and connect to
     * services, and be discovered by, and connected from, other services within a namespace. Tasks that run in a
     * namespace can use short names to connect to services in the namespace. Tasks can connect to services across all
     * of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics
     * for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For
     * more information, see [Service
     * Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic
     * Container Service Developer Guide*. The Service Connect configuration of your Amazon ECS service. The
     * configuration for this service to discover and connect to services, and be discovered by, and connected from,
     * other services within a namespace. Tasks that run in a namespace can use short names to connect to services in
     * the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a
     * managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS
     * services create are supported with Service Connect. For more information, see [Service
     * Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic
     * Container Service Developer Guide*.
     * 
     * @return the serviceConnectConfiguration value.
     */
    public ServiceConnectConfiguration serviceConnectConfiguration() {
        return this.serviceConnectConfiguration;
    }

    /**
     * Set the serviceConnectConfiguration property: The configuration for this service to discover and connect to
     * services, and be discovered by, and connected from, other services within a namespace. Tasks that run in a
     * namespace can use short names to connect to services in the namespace. Tasks can connect to services across all
     * of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics
     * for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For
     * more information, see [Service
     * Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic
     * Container Service Developer Guide*. The Service Connect configuration of your Amazon ECS service. The
     * configuration for this service to discover and connect to services, and be discovered by, and connected from,
     * other services within a namespace. Tasks that run in a namespace can use short names to connect to services in
     * the namespace. Tasks can connect to services across all of the clusters in the namespace. Tasks connect through a
     * managed proxy container that collects logs and metrics for increased visibility. Only the tasks that Amazon ECS
     * services create are supported with Service Connect. For more information, see [Service
     * Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic
     * Container Service Developer Guide*.
     * 
     * @param serviceConnectConfiguration the serviceConnectConfiguration value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties
        withServiceConnectConfiguration(ServiceConnectConfiguration serviceConnectConfiguration) {
        this.serviceConnectConfiguration = serviceConnectConfiguration;
        return this;
    }

    /**
     * Get the serviceName property: The name of your service. Up to 255 letters (uppercase and lowercase), numbers,
     * underscores, and hyphens are allowed. Service names must be unique within a cluster, but you can have similarly
     * named services in multiple clusters within a Region or across multiple Regions. The stack update fails if you
     * change any properties that require replacement and the ``ServiceName`` is configured. This is because AWS
     * CloudFormation creates the replacement service first, but each ``ServiceName`` must be unique in the cluster.
     * 
     * @return the serviceName value.
     */
    public String serviceName() {
        return this.serviceName;
    }

    /**
     * Set the serviceName property: The name of your service. Up to 255 letters (uppercase and lowercase), numbers,
     * underscores, and hyphens are allowed. Service names must be unique within a cluster, but you can have similarly
     * named services in multiple clusters within a Region or across multiple Regions. The stack update fails if you
     * change any properties that require replacement and the ``ServiceName`` is configured. This is because AWS
     * CloudFormation creates the replacement service first, but each ``ServiceName`` must be unique in the cluster.
     * 
     * @param serviceName the serviceName value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withServiceName(String serviceName) {
        this.serviceName = serviceName;
        return this;
    }

    /**
     * Get the serviceRegistries property: The details of the service discovery registry to associate with this service.
     * For more information, see [Service
     * discovery](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html). Each service may
     * be associated with one service registry. Multiple service registries for each service isn't supported.
     * 
     * @return the serviceRegistries value.
     */
    public List<ServiceRegistry> serviceRegistries() {
        return this.serviceRegistries;
    }

    /**
     * Set the serviceRegistries property: The details of the service discovery registry to associate with this service.
     * For more information, see [Service
     * discovery](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-discovery.html). Each service may
     * be associated with one service registry. Multiple service registries for each service isn't supported.
     * 
     * @param serviceRegistries the serviceRegistries value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withServiceRegistries(List<ServiceRegistry> serviceRegistries) {
        this.serviceRegistries = serviceRegistries;
        return this;
    }

    /**
     * Get the tags property: The metadata that you apply to the service to help you categorize and organize them. Each
     * tag consists of a key and an optional value, both of which you define. When a service is deleted, the tags are
     * deleted as well. The following basic restrictions apply to tags: + Maximum number of tags per resource - 50 + For
     * each resource, each tag key must be unique, and each tag key can have only one value. + Maximum key length - 128
     * Unicode characters in UTF-8 + Maximum value length - 256 Unicode characters in UTF-8 + If your tagging schema is
     * used across multiple services and resources, remember that other services may have restrictions on allowed
     * characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the
     * following characters: + - = . _ : / &#064;. + Tag keys and values are case-sensitive. + Do not use ``aws:``,
     * ``AWS:``, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved
     * for AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count
     * against your tags per resource limit.
     * 
     * @return the tags value.
     */
    public List<TagAutoGenerated26> tags() {
        return this.tags;
    }

    /**
     * Set the tags property: The metadata that you apply to the service to help you categorize and organize them. Each
     * tag consists of a key and an optional value, both of which you define. When a service is deleted, the tags are
     * deleted as well. The following basic restrictions apply to tags: + Maximum number of tags per resource - 50 + For
     * each resource, each tag key must be unique, and each tag key can have only one value. + Maximum key length - 128
     * Unicode characters in UTF-8 + Maximum value length - 256 Unicode characters in UTF-8 + If your tagging schema is
     * used across multiple services and resources, remember that other services may have restrictions on allowed
     * characters. Generally allowed characters are: letters, numbers, and spaces representable in UTF-8, and the
     * following characters: + - = . _ : / &#064;. + Tag keys and values are case-sensitive. + Do not use ``aws:``,
     * ``AWS:``, or any upper or lowercase combination of such as a prefix for either keys or values as it is reserved
     * for AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not count
     * against your tags per resource limit.
     * 
     * @param tags the tags value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withTags(List<TagAutoGenerated26> tags) {
        this.tags = tags;
        return this;
    }

    /**
     * Get the taskDefinition property: The ``family`` and ``revision`` (``family:revision``) or full ARN of the task
     * definition to run in your service. If a ``revision`` isn't specified, the latest ``ACTIVE`` revision is used. A
     * task definition must be specified if the service uses either the ``ECS`` or ``CODE_DEPLOY`` deployment
     * controllers. For more information about deployment types, see [Amazon ECS deployment
     * types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html).
     * 
     * @return the taskDefinition value.
     */
    public String taskDefinition() {
        return this.taskDefinition;
    }

    /**
     * Set the taskDefinition property: The ``family`` and ``revision`` (``family:revision``) or full ARN of the task
     * definition to run in your service. If a ``revision`` isn't specified, the latest ``ACTIVE`` revision is used. A
     * task definition must be specified if the service uses either the ``ECS`` or ``CODE_DEPLOY`` deployment
     * controllers. For more information about deployment types, see [Amazon ECS deployment
     * types](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html).
     * 
     * @param taskDefinition the taskDefinition value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withTaskDefinition(String taskDefinition) {
        this.taskDefinition = taskDefinition;
        return this;
    }

    /**
     * Get the volumeConfigurations property: The configuration for a volume specified in the task definition as a
     * volume that is configured at launch time. Currently, the only supported volume type is an Amazon EBS volume.
     * 
     * @return the volumeConfigurations value.
     */
    public List<ServiceVolumeConfiguration> volumeConfigurations() {
        return this.volumeConfigurations;
    }

    /**
     * Set the volumeConfigurations property: The configuration for a volume specified in the task definition as a
     * volume that is configured at launch time. Currently, the only supported volume type is an Amazon EBS volume.
     * 
     * @param volumeConfigurations the volumeConfigurations value to set.
     * @return the AwsEcsServiceProperties object itself.
     */
    public AwsEcsServiceProperties withVolumeConfigurations(List<ServiceVolumeConfiguration> volumeConfigurations) {
        this.volumeConfigurations = volumeConfigurations;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (capacityProviderStrategy() != null) {
            capacityProviderStrategy().forEach(e -> e.validate());
        }
        if (deploymentConfiguration() != null) {
            deploymentConfiguration().validate();
        }
        if (deploymentController() != null) {
            deploymentController().validate();
        }
        if (loadBalancers() != null) {
            loadBalancers().forEach(e -> e.validate());
        }
        if (networkConfiguration() != null) {
            networkConfiguration().validate();
        }
        if (placementConstraints() != null) {
            placementConstraints().forEach(e -> e.validate());
        }
        if (placementStrategies() != null) {
            placementStrategies().forEach(e -> e.validate());
        }
        if (serviceConnectConfiguration() != null) {
            serviceConnectConfiguration().validate();
        }
        if (serviceRegistries() != null) {
            serviceRegistries().forEach(e -> e.validate());
        }
        if (tags() != null) {
            tags().forEach(e -> e.validate());
        }
        if (volumeConfigurations() != null) {
            volumeConfigurations().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("capacityProviderStrategy", this.capacityProviderStrategy,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("cluster", this.cluster);
        jsonWriter.writeJsonField("deploymentConfiguration", this.deploymentConfiguration);
        jsonWriter.writeJsonField("deploymentController", this.deploymentController);
        jsonWriter.writeNumberField("desiredCount", this.desiredCount);
        jsonWriter.writeBooleanField("enableECSManagedTags", this.enableEcsManagedTags);
        jsonWriter.writeBooleanField("enableExecuteCommand", this.enableExecuteCommand);
        jsonWriter.writeNumberField("healthCheckGracePeriodSeconds", this.healthCheckGracePeriodSeconds);
        jsonWriter.writeStringField("launchType", this.launchType == null ? null : this.launchType.toString());
        jsonWriter.writeArrayField("loadBalancers", this.loadBalancers, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeJsonField("networkConfiguration", this.networkConfiguration);
        jsonWriter.writeArrayField("placementConstraints", this.placementConstraints,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("placementStrategies", this.placementStrategies,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("platformVersion", this.platformVersion);
        jsonWriter.writeStringField("propagateTags", this.propagateTags == null ? null : this.propagateTags.toString());
        jsonWriter.writeStringField("role", this.role);
        jsonWriter.writeStringField("schedulingStrategy",
            this.schedulingStrategy == null ? null : this.schedulingStrategy.toString());
        jsonWriter.writeStringField("serviceArn", this.serviceArn);
        jsonWriter.writeJsonField("serviceConnectConfiguration", this.serviceConnectConfiguration);
        jsonWriter.writeStringField("serviceName", this.serviceName);
        jsonWriter.writeArrayField("serviceRegistries", this.serviceRegistries,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("tags", this.tags, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("taskDefinition", this.taskDefinition);
        jsonWriter.writeArrayField("volumeConfigurations", this.volumeConfigurations,
            (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of AwsEcsServiceProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of AwsEcsServiceProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the AwsEcsServiceProperties.
     */
    public static AwsEcsServiceProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            AwsEcsServiceProperties deserializedAwsEcsServiceProperties = new AwsEcsServiceProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("capacityProviderStrategy".equals(fieldName)) {
                    List<CapacityProviderStrategyItem> capacityProviderStrategy
                        = reader.readArray(reader1 -> CapacityProviderStrategyItem.fromJson(reader1));
                    deserializedAwsEcsServiceProperties.capacityProviderStrategy = capacityProviderStrategy;
                } else if ("cluster".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.cluster = reader.getString();
                } else if ("deploymentConfiguration".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.deploymentConfiguration
                        = DeploymentConfiguration.fromJson(reader);
                } else if ("deploymentController".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.deploymentController = DeploymentController.fromJson(reader);
                } else if ("desiredCount".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.desiredCount = reader.getNullable(JsonReader::getInt);
                } else if ("enableECSManagedTags".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.enableEcsManagedTags
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("enableExecuteCommand".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.enableExecuteCommand
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("healthCheckGracePeriodSeconds".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.healthCheckGracePeriodSeconds
                        = reader.getNullable(JsonReader::getInt);
                } else if ("launchType".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.launchType = LaunchType.fromString(reader.getString());
                } else if ("loadBalancers".equals(fieldName)) {
                    List<LoadBalancer> loadBalancers = reader.readArray(reader1 -> LoadBalancer.fromJson(reader1));
                    deserializedAwsEcsServiceProperties.loadBalancers = loadBalancers;
                } else if ("name".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.name = reader.getString();
                } else if ("networkConfiguration".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.networkConfiguration = NetworkConfiguration.fromJson(reader);
                } else if ("placementConstraints".equals(fieldName)) {
                    List<PlacementConstraint> placementConstraints
                        = reader.readArray(reader1 -> PlacementConstraint.fromJson(reader1));
                    deserializedAwsEcsServiceProperties.placementConstraints = placementConstraints;
                } else if ("placementStrategies".equals(fieldName)) {
                    List<PlacementStrategy> placementStrategies
                        = reader.readArray(reader1 -> PlacementStrategy.fromJson(reader1));
                    deserializedAwsEcsServiceProperties.placementStrategies = placementStrategies;
                } else if ("platformVersion".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.platformVersion = reader.getString();
                } else if ("propagateTags".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.propagateTags = PropagateTags.fromString(reader.getString());
                } else if ("role".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.role = reader.getString();
                } else if ("schedulingStrategy".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.schedulingStrategy
                        = SchedulingStrategy.fromString(reader.getString());
                } else if ("serviceArn".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.serviceArn = reader.getString();
                } else if ("serviceConnectConfiguration".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.serviceConnectConfiguration
                        = ServiceConnectConfiguration.fromJson(reader);
                } else if ("serviceName".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.serviceName = reader.getString();
                } else if ("serviceRegistries".equals(fieldName)) {
                    List<ServiceRegistry> serviceRegistries
                        = reader.readArray(reader1 -> ServiceRegistry.fromJson(reader1));
                    deserializedAwsEcsServiceProperties.serviceRegistries = serviceRegistries;
                } else if ("tags".equals(fieldName)) {
                    List<TagAutoGenerated26> tags = reader.readArray(reader1 -> TagAutoGenerated26.fromJson(reader1));
                    deserializedAwsEcsServiceProperties.tags = tags;
                } else if ("taskDefinition".equals(fieldName)) {
                    deserializedAwsEcsServiceProperties.taskDefinition = reader.getString();
                } else if ("volumeConfigurations".equals(fieldName)) {
                    List<ServiceVolumeConfiguration> volumeConfigurations
                        = reader.readArray(reader1 -> ServiceVolumeConfiguration.fromJson(reader1));
                    deserializedAwsEcsServiceProperties.volumeConfigurations = volumeConfigurations;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedAwsEcsServiceProperties;
        });
    }
}
