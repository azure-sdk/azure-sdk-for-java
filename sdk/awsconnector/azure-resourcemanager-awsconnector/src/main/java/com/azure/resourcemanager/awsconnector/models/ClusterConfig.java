// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Definition of ClusterConfig.
 */
@Fluent
public final class ClusterConfig implements JsonSerializable<ClusterConfig> {
    /*
     * <p>Container for cold storage configuration options.</p>
     */
    private ColdStorageOptions coldStorageOptions;

    /*
     * <p>Number of dedicated master nodes in the cluster. This number must be greater than 2 and not 4, otherwise you
     * receive a validation exception.</p>
     */
    private Integer dedicatedMasterCount;

    /*
     * <p>Indicates whether dedicated master nodes are enabled for the cluster.<code>True</code> if the cluster will use
     * a dedicated master node.<code>False</code> if the cluster will not.</p>
     */
    private Boolean dedicatedMasterEnabled;

    /*
     * <p>OpenSearch Service instance type of the dedicated master nodes in the cluster.</p>
     */
    private OpenSearchPartitionInstanceTypeEnumValue dedicatedMasterType;

    /*
     * <p>Number of data nodes in the cluster. This number must be greater than 1, otherwise you receive a validation
     * exception.</p>
     */
    private Integer instanceCount;

    /*
     * <p>Instance type of data nodes in the cluster.</p>
     */
    private OpenSearchPartitionInstanceTypeEnumValue instanceType;

    /*
     * <p>A boolean that indicates whether a multi-AZ domain is turned on with a standby AZ. For more information, see
     * <a href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html'>
     * Configuring a multi-AZ domain in Amazon OpenSearch Service</a>. </p>
     */
    private Boolean multiAZWithStandbyEnabled;

    /*
     * <p>The number of warm nodes in the cluster.</p>
     */
    private Integer warmCount;

    /*
     * <p>Whether to enable warm storage for the cluster.</p>
     */
    private Boolean warmEnabled;

    /*
     * <p>The instance type for the cluster's warm nodes.</p>
     */
    private OpenSearchWarmPartitionInstanceTypeEnumValue warmType;

    /*
     * <p>Container for zone awareness configuration options. Only required if <code>ZoneAwarenessEnabled</code> is
     * <code>true</code>.</p>
     */
    private ZoneAwarenessConfig zoneAwarenessConfig;

    /*
     * <p>Indicates whether multiple Availability Zones are enabled. For more information, see <a
     * href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html'>
     * Configuring a multi-AZ domain in Amazon OpenSearch Service</a>.</p>
     */
    private Boolean zoneAwarenessEnabled;

    /**
     * Creates an instance of ClusterConfig class.
     */
    public ClusterConfig() {
    }

    /**
     * Get the coldStorageOptions property: &lt;p&gt;Container for cold storage configuration options.&lt;/p&gt;.
     * 
     * @return the coldStorageOptions value.
     */
    public ColdStorageOptions coldStorageOptions() {
        return this.coldStorageOptions;
    }

    /**
     * Set the coldStorageOptions property: &lt;p&gt;Container for cold storage configuration options.&lt;/p&gt;.
     * 
     * @param coldStorageOptions the coldStorageOptions value to set.
     * @return the ClusterConfig object itself.
     */
    public ClusterConfig withColdStorageOptions(ColdStorageOptions coldStorageOptions) {
        this.coldStorageOptions = coldStorageOptions;
        return this;
    }

    /**
     * Get the dedicatedMasterCount property: &lt;p&gt;Number of dedicated master nodes in the cluster. This number must
     * be greater than 2 and not 4, otherwise you receive a validation exception.&lt;/p&gt;.
     * 
     * @return the dedicatedMasterCount value.
     */
    public Integer dedicatedMasterCount() {
        return this.dedicatedMasterCount;
    }

    /**
     * Set the dedicatedMasterCount property: &lt;p&gt;Number of dedicated master nodes in the cluster. This number must
     * be greater than 2 and not 4, otherwise you receive a validation exception.&lt;/p&gt;.
     * 
     * @param dedicatedMasterCount the dedicatedMasterCount value to set.
     * @return the ClusterConfig object itself.
     */
    public ClusterConfig withDedicatedMasterCount(Integer dedicatedMasterCount) {
        this.dedicatedMasterCount = dedicatedMasterCount;
        return this;
    }

    /**
     * Get the dedicatedMasterEnabled property: &lt;p&gt;Indicates whether dedicated master nodes are enabled for the
     * cluster.&lt;code&gt;True&lt;/code&gt; if the cluster will use a dedicated master
     * node.&lt;code&gt;False&lt;/code&gt; if the cluster will not.&lt;/p&gt;.
     * 
     * @return the dedicatedMasterEnabled value.
     */
    public Boolean dedicatedMasterEnabled() {
        return this.dedicatedMasterEnabled;
    }

    /**
     * Set the dedicatedMasterEnabled property: &lt;p&gt;Indicates whether dedicated master nodes are enabled for the
     * cluster.&lt;code&gt;True&lt;/code&gt; if the cluster will use a dedicated master
     * node.&lt;code&gt;False&lt;/code&gt; if the cluster will not.&lt;/p&gt;.
     * 
     * @param dedicatedMasterEnabled the dedicatedMasterEnabled value to set.
     * @return the ClusterConfig object itself.
     */
    public ClusterConfig withDedicatedMasterEnabled(Boolean dedicatedMasterEnabled) {
        this.dedicatedMasterEnabled = dedicatedMasterEnabled;
        return this;
    }

    /**
     * Get the dedicatedMasterType property: &lt;p&gt;OpenSearch Service instance type of the dedicated master nodes in
     * the cluster.&lt;/p&gt;.
     * 
     * @return the dedicatedMasterType value.
     */
    public OpenSearchPartitionInstanceTypeEnumValue dedicatedMasterType() {
        return this.dedicatedMasterType;
    }

    /**
     * Set the dedicatedMasterType property: &lt;p&gt;OpenSearch Service instance type of the dedicated master nodes in
     * the cluster.&lt;/p&gt;.
     * 
     * @param dedicatedMasterType the dedicatedMasterType value to set.
     * @return the ClusterConfig object itself.
     */
    public ClusterConfig withDedicatedMasterType(OpenSearchPartitionInstanceTypeEnumValue dedicatedMasterType) {
        this.dedicatedMasterType = dedicatedMasterType;
        return this;
    }

    /**
     * Get the instanceCount property: &lt;p&gt;Number of data nodes in the cluster. This number must be greater than 1,
     * otherwise you receive a validation exception.&lt;/p&gt;.
     * 
     * @return the instanceCount value.
     */
    public Integer instanceCount() {
        return this.instanceCount;
    }

    /**
     * Set the instanceCount property: &lt;p&gt;Number of data nodes in the cluster. This number must be greater than 1,
     * otherwise you receive a validation exception.&lt;/p&gt;.
     * 
     * @param instanceCount the instanceCount value to set.
     * @return the ClusterConfig object itself.
     */
    public ClusterConfig withInstanceCount(Integer instanceCount) {
        this.instanceCount = instanceCount;
        return this;
    }

    /**
     * Get the instanceType property: &lt;p&gt;Instance type of data nodes in the cluster.&lt;/p&gt;.
     * 
     * @return the instanceType value.
     */
    public OpenSearchPartitionInstanceTypeEnumValue instanceType() {
        return this.instanceType;
    }

    /**
     * Set the instanceType property: &lt;p&gt;Instance type of data nodes in the cluster.&lt;/p&gt;.
     * 
     * @param instanceType the instanceType value to set.
     * @return the ClusterConfig object itself.
     */
    public ClusterConfig withInstanceType(OpenSearchPartitionInstanceTypeEnumValue instanceType) {
        this.instanceType = instanceType;
        return this;
    }

    /**
     * Get the multiAZWithStandbyEnabled property: &lt;p&gt;A boolean that indicates whether a multi-AZ domain is turned
     * on with a standby AZ. For more information, see &lt;a
     * href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html'&gt;Configuring
     * a multi-AZ domain in Amazon OpenSearch Service&lt;/a&gt;. &lt;/p&gt;.
     * 
     * @return the multiAZWithStandbyEnabled value.
     */
    public Boolean multiAZWithStandbyEnabled() {
        return this.multiAZWithStandbyEnabled;
    }

    /**
     * Set the multiAZWithStandbyEnabled property: &lt;p&gt;A boolean that indicates whether a multi-AZ domain is turned
     * on with a standby AZ. For more information, see &lt;a
     * href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html'&gt;Configuring
     * a multi-AZ domain in Amazon OpenSearch Service&lt;/a&gt;. &lt;/p&gt;.
     * 
     * @param multiAZWithStandbyEnabled the multiAZWithStandbyEnabled value to set.
     * @return the ClusterConfig object itself.
     */
    public ClusterConfig withMultiAZWithStandbyEnabled(Boolean multiAZWithStandbyEnabled) {
        this.multiAZWithStandbyEnabled = multiAZWithStandbyEnabled;
        return this;
    }

    /**
     * Get the warmCount property: &lt;p&gt;The number of warm nodes in the cluster.&lt;/p&gt;.
     * 
     * @return the warmCount value.
     */
    public Integer warmCount() {
        return this.warmCount;
    }

    /**
     * Set the warmCount property: &lt;p&gt;The number of warm nodes in the cluster.&lt;/p&gt;.
     * 
     * @param warmCount the warmCount value to set.
     * @return the ClusterConfig object itself.
     */
    public ClusterConfig withWarmCount(Integer warmCount) {
        this.warmCount = warmCount;
        return this;
    }

    /**
     * Get the warmEnabled property: &lt;p&gt;Whether to enable warm storage for the cluster.&lt;/p&gt;.
     * 
     * @return the warmEnabled value.
     */
    public Boolean warmEnabled() {
        return this.warmEnabled;
    }

    /**
     * Set the warmEnabled property: &lt;p&gt;Whether to enable warm storage for the cluster.&lt;/p&gt;.
     * 
     * @param warmEnabled the warmEnabled value to set.
     * @return the ClusterConfig object itself.
     */
    public ClusterConfig withWarmEnabled(Boolean warmEnabled) {
        this.warmEnabled = warmEnabled;
        return this;
    }

    /**
     * Get the warmType property: &lt;p&gt;The instance type for the cluster's warm nodes.&lt;/p&gt;.
     * 
     * @return the warmType value.
     */
    public OpenSearchWarmPartitionInstanceTypeEnumValue warmType() {
        return this.warmType;
    }

    /**
     * Set the warmType property: &lt;p&gt;The instance type for the cluster's warm nodes.&lt;/p&gt;.
     * 
     * @param warmType the warmType value to set.
     * @return the ClusterConfig object itself.
     */
    public ClusterConfig withWarmType(OpenSearchWarmPartitionInstanceTypeEnumValue warmType) {
        this.warmType = warmType;
        return this;
    }

    /**
     * Get the zoneAwarenessConfig property: &lt;p&gt;Container for zone awareness configuration options. Only required
     * if &lt;code&gt;ZoneAwarenessEnabled&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;.
     * 
     * @return the zoneAwarenessConfig value.
     */
    public ZoneAwarenessConfig zoneAwarenessConfig() {
        return this.zoneAwarenessConfig;
    }

    /**
     * Set the zoneAwarenessConfig property: &lt;p&gt;Container for zone awareness configuration options. Only required
     * if &lt;code&gt;ZoneAwarenessEnabled&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;.
     * 
     * @param zoneAwarenessConfig the zoneAwarenessConfig value to set.
     * @return the ClusterConfig object itself.
     */
    public ClusterConfig withZoneAwarenessConfig(ZoneAwarenessConfig zoneAwarenessConfig) {
        this.zoneAwarenessConfig = zoneAwarenessConfig;
        return this;
    }

    /**
     * Get the zoneAwarenessEnabled property: &lt;p&gt;Indicates whether multiple Availability Zones are enabled. For
     * more information, see &lt;a
     * href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html'&gt;Configuring
     * a multi-AZ domain in Amazon OpenSearch Service&lt;/a&gt;.&lt;/p&gt;.
     * 
     * @return the zoneAwarenessEnabled value.
     */
    public Boolean zoneAwarenessEnabled() {
        return this.zoneAwarenessEnabled;
    }

    /**
     * Set the zoneAwarenessEnabled property: &lt;p&gt;Indicates whether multiple Availability Zones are enabled. For
     * more information, see &lt;a
     * href='https://docs.aws.amazon.com/opensearch-service/latest/developerguide/managedomains-multiaz.html'&gt;Configuring
     * a multi-AZ domain in Amazon OpenSearch Service&lt;/a&gt;.&lt;/p&gt;.
     * 
     * @param zoneAwarenessEnabled the zoneAwarenessEnabled value to set.
     * @return the ClusterConfig object itself.
     */
    public ClusterConfig withZoneAwarenessEnabled(Boolean zoneAwarenessEnabled) {
        this.zoneAwarenessEnabled = zoneAwarenessEnabled;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (coldStorageOptions() != null) {
            coldStorageOptions().validate();
        }
        if (dedicatedMasterType() != null) {
            dedicatedMasterType().validate();
        }
        if (instanceType() != null) {
            instanceType().validate();
        }
        if (warmType() != null) {
            warmType().validate();
        }
        if (zoneAwarenessConfig() != null) {
            zoneAwarenessConfig().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("coldStorageOptions", this.coldStorageOptions);
        jsonWriter.writeNumberField("dedicatedMasterCount", this.dedicatedMasterCount);
        jsonWriter.writeBooleanField("dedicatedMasterEnabled", this.dedicatedMasterEnabled);
        jsonWriter.writeJsonField("dedicatedMasterType", this.dedicatedMasterType);
        jsonWriter.writeNumberField("instanceCount", this.instanceCount);
        jsonWriter.writeJsonField("instanceType", this.instanceType);
        jsonWriter.writeBooleanField("multiAZWithStandbyEnabled", this.multiAZWithStandbyEnabled);
        jsonWriter.writeNumberField("warmCount", this.warmCount);
        jsonWriter.writeBooleanField("warmEnabled", this.warmEnabled);
        jsonWriter.writeJsonField("warmType", this.warmType);
        jsonWriter.writeJsonField("zoneAwarenessConfig", this.zoneAwarenessConfig);
        jsonWriter.writeBooleanField("zoneAwarenessEnabled", this.zoneAwarenessEnabled);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ClusterConfig from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ClusterConfig if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the ClusterConfig.
     */
    public static ClusterConfig fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ClusterConfig deserializedClusterConfig = new ClusterConfig();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("coldStorageOptions".equals(fieldName)) {
                    deserializedClusterConfig.coldStorageOptions = ColdStorageOptions.fromJson(reader);
                } else if ("dedicatedMasterCount".equals(fieldName)) {
                    deserializedClusterConfig.dedicatedMasterCount = reader.getNullable(JsonReader::getInt);
                } else if ("dedicatedMasterEnabled".equals(fieldName)) {
                    deserializedClusterConfig.dedicatedMasterEnabled = reader.getNullable(JsonReader::getBoolean);
                } else if ("dedicatedMasterType".equals(fieldName)) {
                    deserializedClusterConfig.dedicatedMasterType
                        = OpenSearchPartitionInstanceTypeEnumValue.fromJson(reader);
                } else if ("instanceCount".equals(fieldName)) {
                    deserializedClusterConfig.instanceCount = reader.getNullable(JsonReader::getInt);
                } else if ("instanceType".equals(fieldName)) {
                    deserializedClusterConfig.instanceType = OpenSearchPartitionInstanceTypeEnumValue.fromJson(reader);
                } else if ("multiAZWithStandbyEnabled".equals(fieldName)) {
                    deserializedClusterConfig.multiAZWithStandbyEnabled = reader.getNullable(JsonReader::getBoolean);
                } else if ("warmCount".equals(fieldName)) {
                    deserializedClusterConfig.warmCount = reader.getNullable(JsonReader::getInt);
                } else if ("warmEnabled".equals(fieldName)) {
                    deserializedClusterConfig.warmEnabled = reader.getNullable(JsonReader::getBoolean);
                } else if ("warmType".equals(fieldName)) {
                    deserializedClusterConfig.warmType = OpenSearchWarmPartitionInstanceTypeEnumValue.fromJson(reader);
                } else if ("zoneAwarenessConfig".equals(fieldName)) {
                    deserializedClusterConfig.zoneAwarenessConfig = ZoneAwarenessConfig.fromJson(reader);
                } else if ("zoneAwarenessEnabled".equals(fieldName)) {
                    deserializedClusterConfig.zoneAwarenessEnabled = reader.getNullable(JsonReader::getBoolean);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedClusterConfig;
        });
    }
}
