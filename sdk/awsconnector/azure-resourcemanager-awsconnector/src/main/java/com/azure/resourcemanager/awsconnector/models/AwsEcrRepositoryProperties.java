// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Definition of awsEcrRepository.
 */
@Fluent
public final class AwsEcrRepositoryProperties implements JsonSerializable<AwsEcrRepositoryProperties> {
    /*
     * Property arn
     */
    private String arn;

    /*
     * If true, deleting the repository force deletes the contents of the repository. If false, the repository must be
     * empty before attempting to delete it. If true, deleting the repository force deletes the contents of the
     * repository. Without a force delete, you can only delete empty repositories.
     */
    private Boolean emptyOnDelete;

    /*
     * The encryption configuration for the repository. This determines how the contents of your repository are
     * encrypted at rest. The encryption configuration for the repository. This determines how the contents of your
     * repository are encrypted at rest. By default, when no encryption configuration is set or the ``AES256``
     * encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which
     * encrypts your data at rest using an AES-256 encryption algorithm. This does not require any action on your part.
     * For more control over the encryption of the contents of your repository, you can use server-side encryption with
     * KMSlong key stored in KMSlong (KMS) to encrypt your images. For more information, see [Amazon ECR encryption at
     * rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic
     * Container Registry User Guide*.
     */
    private EncryptionConfiguration encryptionConfiguration;

    /*
     * The image scanning configuration for the repository. This determines whether images are scanned for known
     * vulnerabilities after being pushed to the repository. The image scanning configuration for a repository.
     */
    private ImageScanningConfiguration imageScanningConfiguration;

    /*
     * The tag mutability setting for the repository. If this parameter is omitted, the default setting of ``MUTABLE``
     * will be used which will allow image tags to be overwritten. If ``IMMUTABLE`` is specified, all image tags within
     * the repository will be immutable which will prevent them from being overwritten.
     */
    private ImageTagMutability imageTagMutability;

    /*
     * Creates or updates a lifecycle policy. For information about lifecycle policy syntax, see [Lifecycle policy
     * template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html). The ``LifecyclePolicy``
     * property type specifies a lifecycle policy. For information about lifecycle policy syntax, see [Lifecycle policy
     * template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html) in the *Amazon ECR User
     * Guide*.
     */
    private LifecyclePolicy lifecyclePolicy;

    /*
     * The name to use for the repository. The repository name may be specified on its own (such as ``nginx-web-app``)
     * or it can be prepended with a namespace to group the repository into a category (such as
     * ``project-a/nginx-web-app``). If you don't specify a name, CFNlong generates a unique physical ID and uses that
     * ID for the repository name. For more information, see [Name
     * type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html). The repository
     * name must start with a letter and can only contain lowercase letters, numbers, hyphens, underscores, and forward
     * slashes. If you specify a name, you cannot perform updates that require replacement of this resource. You can
     * perform updates that require no or some interruption. If you must replace the resource, specify a new name.
     */
    private String repositoryName;

    /*
     * The JSON repository policy text to apply to the repository. For more information, see [Amazon ECR repository
     * policies](https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html) in the *Amazon
     * Elastic Container Registry User Guide*.
     */
    private Map<String, Object> repositoryPolicyText;

    /*
     * Property repositoryUri
     */
    private String repositoryUri;

    /*
     * An array of key-value pairs to apply to this resource.
     */
    private List<TagAutoGenerated24> tags;

    /**
     * Creates an instance of AwsEcrRepositoryProperties class.
     */
    public AwsEcrRepositoryProperties() {
    }

    /**
     * Get the arn property: Property arn.
     * 
     * @return the arn value.
     */
    public String arn() {
        return this.arn;
    }

    /**
     * Set the arn property: Property arn.
     * 
     * @param arn the arn value to set.
     * @return the AwsEcrRepositoryProperties object itself.
     */
    public AwsEcrRepositoryProperties withArn(String arn) {
        this.arn = arn;
        return this;
    }

    /**
     * Get the emptyOnDelete property: If true, deleting the repository force deletes the contents of the repository. If
     * false, the repository must be empty before attempting to delete it. If true, deleting the repository force
     * deletes the contents of the repository. Without a force delete, you can only delete empty repositories.
     * 
     * @return the emptyOnDelete value.
     */
    public Boolean emptyOnDelete() {
        return this.emptyOnDelete;
    }

    /**
     * Set the emptyOnDelete property: If true, deleting the repository force deletes the contents of the repository. If
     * false, the repository must be empty before attempting to delete it. If true, deleting the repository force
     * deletes the contents of the repository. Without a force delete, you can only delete empty repositories.
     * 
     * @param emptyOnDelete the emptyOnDelete value to set.
     * @return the AwsEcrRepositoryProperties object itself.
     */
    public AwsEcrRepositoryProperties withEmptyOnDelete(Boolean emptyOnDelete) {
        this.emptyOnDelete = emptyOnDelete;
        return this;
    }

    /**
     * Get the encryptionConfiguration property: The encryption configuration for the repository. This determines how
     * the contents of your repository are encrypted at rest. The encryption configuration for the repository. This
     * determines how the contents of your repository are encrypted at rest. By default, when no encryption
     * configuration is set or the ``AES256`` encryption type is used, Amazon ECR uses server-side encryption with
     * Amazon S3-managed encryption keys which encrypts your data at rest using an AES-256 encryption algorithm. This
     * does not require any action on your part. For more control over the encryption of the contents of your
     * repository, you can use server-side encryption with KMSlong key stored in KMSlong (KMS) to encrypt your images.
     * For more information, see [Amazon ECR encryption at
     * rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic
     * Container Registry User Guide*.
     * 
     * @return the encryptionConfiguration value.
     */
    public EncryptionConfiguration encryptionConfiguration() {
        return this.encryptionConfiguration;
    }

    /**
     * Set the encryptionConfiguration property: The encryption configuration for the repository. This determines how
     * the contents of your repository are encrypted at rest. The encryption configuration for the repository. This
     * determines how the contents of your repository are encrypted at rest. By default, when no encryption
     * configuration is set or the ``AES256`` encryption type is used, Amazon ECR uses server-side encryption with
     * Amazon S3-managed encryption keys which encrypts your data at rest using an AES-256 encryption algorithm. This
     * does not require any action on your part. For more control over the encryption of the contents of your
     * repository, you can use server-side encryption with KMSlong key stored in KMSlong (KMS) to encrypt your images.
     * For more information, see [Amazon ECR encryption at
     * rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the *Amazon Elastic
     * Container Registry User Guide*.
     * 
     * @param encryptionConfiguration the encryptionConfiguration value to set.
     * @return the AwsEcrRepositoryProperties object itself.
     */
    public AwsEcrRepositoryProperties withEncryptionConfiguration(EncryptionConfiguration encryptionConfiguration) {
        this.encryptionConfiguration = encryptionConfiguration;
        return this;
    }

    /**
     * Get the imageScanningConfiguration property: The image scanning configuration for the repository. This determines
     * whether images are scanned for known vulnerabilities after being pushed to the repository. The image scanning
     * configuration for a repository.
     * 
     * @return the imageScanningConfiguration value.
     */
    public ImageScanningConfiguration imageScanningConfiguration() {
        return this.imageScanningConfiguration;
    }

    /**
     * Set the imageScanningConfiguration property: The image scanning configuration for the repository. This determines
     * whether images are scanned for known vulnerabilities after being pushed to the repository. The image scanning
     * configuration for a repository.
     * 
     * @param imageScanningConfiguration the imageScanningConfiguration value to set.
     * @return the AwsEcrRepositoryProperties object itself.
     */
    public AwsEcrRepositoryProperties
        withImageScanningConfiguration(ImageScanningConfiguration imageScanningConfiguration) {
        this.imageScanningConfiguration = imageScanningConfiguration;
        return this;
    }

    /**
     * Get the imageTagMutability property: The tag mutability setting for the repository. If this parameter is omitted,
     * the default setting of ``MUTABLE`` will be used which will allow image tags to be overwritten. If ``IMMUTABLE``
     * is specified, all image tags within the repository will be immutable which will prevent them from being
     * overwritten.
     * 
     * @return the imageTagMutability value.
     */
    public ImageTagMutability imageTagMutability() {
        return this.imageTagMutability;
    }

    /**
     * Set the imageTagMutability property: The tag mutability setting for the repository. If this parameter is omitted,
     * the default setting of ``MUTABLE`` will be used which will allow image tags to be overwritten. If ``IMMUTABLE``
     * is specified, all image tags within the repository will be immutable which will prevent them from being
     * overwritten.
     * 
     * @param imageTagMutability the imageTagMutability value to set.
     * @return the AwsEcrRepositoryProperties object itself.
     */
    public AwsEcrRepositoryProperties withImageTagMutability(ImageTagMutability imageTagMutability) {
        this.imageTagMutability = imageTagMutability;
        return this;
    }

    /**
     * Get the lifecyclePolicy property: Creates or updates a lifecycle policy. For information about lifecycle policy
     * syntax, see [Lifecycle policy
     * template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html). The ``LifecyclePolicy``
     * property type specifies a lifecycle policy. For information about lifecycle policy syntax, see [Lifecycle policy
     * template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html) in the *Amazon ECR User
     * Guide*.
     * 
     * @return the lifecyclePolicy value.
     */
    public LifecyclePolicy lifecyclePolicy() {
        return this.lifecyclePolicy;
    }

    /**
     * Set the lifecyclePolicy property: Creates or updates a lifecycle policy. For information about lifecycle policy
     * syntax, see [Lifecycle policy
     * template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html). The ``LifecyclePolicy``
     * property type specifies a lifecycle policy. For information about lifecycle policy syntax, see [Lifecycle policy
     * template](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html) in the *Amazon ECR User
     * Guide*.
     * 
     * @param lifecyclePolicy the lifecyclePolicy value to set.
     * @return the AwsEcrRepositoryProperties object itself.
     */
    public AwsEcrRepositoryProperties withLifecyclePolicy(LifecyclePolicy lifecyclePolicy) {
        this.lifecyclePolicy = lifecyclePolicy;
        return this;
    }

    /**
     * Get the repositoryName property: The name to use for the repository. The repository name may be specified on its
     * own (such as ``nginx-web-app``) or it can be prepended with a namespace to group the repository into a category
     * (such as ``project-a/nginx-web-app``). If you don't specify a name, CFNlong generates a unique physical ID and
     * uses that ID for the repository name. For more information, see [Name
     * type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html). The repository
     * name must start with a letter and can only contain lowercase letters, numbers, hyphens, underscores, and forward
     * slashes. If you specify a name, you cannot perform updates that require replacement of this resource. You can
     * perform updates that require no or some interruption. If you must replace the resource, specify a new name.
     * 
     * @return the repositoryName value.
     */
    public String repositoryName() {
        return this.repositoryName;
    }

    /**
     * Set the repositoryName property: The name to use for the repository. The repository name may be specified on its
     * own (such as ``nginx-web-app``) or it can be prepended with a namespace to group the repository into a category
     * (such as ``project-a/nginx-web-app``). If you don't specify a name, CFNlong generates a unique physical ID and
     * uses that ID for the repository name. For more information, see [Name
     * type](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-name.html). The repository
     * name must start with a letter and can only contain lowercase letters, numbers, hyphens, underscores, and forward
     * slashes. If you specify a name, you cannot perform updates that require replacement of this resource. You can
     * perform updates that require no or some interruption. If you must replace the resource, specify a new name.
     * 
     * @param repositoryName the repositoryName value to set.
     * @return the AwsEcrRepositoryProperties object itself.
     */
    public AwsEcrRepositoryProperties withRepositoryName(String repositoryName) {
        this.repositoryName = repositoryName;
        return this;
    }

    /**
     * Get the repositoryPolicyText property: The JSON repository policy text to apply to the repository. For more
     * information, see [Amazon ECR repository
     * policies](https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html) in the *Amazon
     * Elastic Container Registry User Guide*.
     * 
     * @return the repositoryPolicyText value.
     */
    public Map<String, Object> repositoryPolicyText() {
        return this.repositoryPolicyText;
    }

    /**
     * Set the repositoryPolicyText property: The JSON repository policy text to apply to the repository. For more
     * information, see [Amazon ECR repository
     * policies](https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html) in the *Amazon
     * Elastic Container Registry User Guide*.
     * 
     * @param repositoryPolicyText the repositoryPolicyText value to set.
     * @return the AwsEcrRepositoryProperties object itself.
     */
    public AwsEcrRepositoryProperties withRepositoryPolicyText(Map<String, Object> repositoryPolicyText) {
        this.repositoryPolicyText = repositoryPolicyText;
        return this;
    }

    /**
     * Get the repositoryUri property: Property repositoryUri.
     * 
     * @return the repositoryUri value.
     */
    public String repositoryUri() {
        return this.repositoryUri;
    }

    /**
     * Set the repositoryUri property: Property repositoryUri.
     * 
     * @param repositoryUri the repositoryUri value to set.
     * @return the AwsEcrRepositoryProperties object itself.
     */
    public AwsEcrRepositoryProperties withRepositoryUri(String repositoryUri) {
        this.repositoryUri = repositoryUri;
        return this;
    }

    /**
     * Get the tags property: An array of key-value pairs to apply to this resource.
     * 
     * @return the tags value.
     */
    public List<TagAutoGenerated24> tags() {
        return this.tags;
    }

    /**
     * Set the tags property: An array of key-value pairs to apply to this resource.
     * 
     * @param tags the tags value to set.
     * @return the AwsEcrRepositoryProperties object itself.
     */
    public AwsEcrRepositoryProperties withTags(List<TagAutoGenerated24> tags) {
        this.tags = tags;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (encryptionConfiguration() != null) {
            encryptionConfiguration().validate();
        }
        if (imageScanningConfiguration() != null) {
            imageScanningConfiguration().validate();
        }
        if (lifecyclePolicy() != null) {
            lifecyclePolicy().validate();
        }
        if (tags() != null) {
            tags().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("arn", this.arn);
        jsonWriter.writeBooleanField("emptyOnDelete", this.emptyOnDelete);
        jsonWriter.writeJsonField("encryptionConfiguration", this.encryptionConfiguration);
        jsonWriter.writeJsonField("imageScanningConfiguration", this.imageScanningConfiguration);
        jsonWriter.writeStringField("imageTagMutability",
            this.imageTagMutability == null ? null : this.imageTagMutability.toString());
        jsonWriter.writeJsonField("lifecyclePolicy", this.lifecyclePolicy);
        jsonWriter.writeStringField("repositoryName", this.repositoryName);
        jsonWriter.writeMapField("repositoryPolicyText", this.repositoryPolicyText,
            (writer, element) -> writer.writeUntyped(element));
        jsonWriter.writeStringField("repositoryUri", this.repositoryUri);
        jsonWriter.writeArrayField("tags", this.tags, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of AwsEcrRepositoryProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of AwsEcrRepositoryProperties if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the AwsEcrRepositoryProperties.
     */
    public static AwsEcrRepositoryProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            AwsEcrRepositoryProperties deserializedAwsEcrRepositoryProperties = new AwsEcrRepositoryProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("arn".equals(fieldName)) {
                    deserializedAwsEcrRepositoryProperties.arn = reader.getString();
                } else if ("emptyOnDelete".equals(fieldName)) {
                    deserializedAwsEcrRepositoryProperties.emptyOnDelete = reader.getNullable(JsonReader::getBoolean);
                } else if ("encryptionConfiguration".equals(fieldName)) {
                    deserializedAwsEcrRepositoryProperties.encryptionConfiguration
                        = EncryptionConfiguration.fromJson(reader);
                } else if ("imageScanningConfiguration".equals(fieldName)) {
                    deserializedAwsEcrRepositoryProperties.imageScanningConfiguration
                        = ImageScanningConfiguration.fromJson(reader);
                } else if ("imageTagMutability".equals(fieldName)) {
                    deserializedAwsEcrRepositoryProperties.imageTagMutability
                        = ImageTagMutability.fromString(reader.getString());
                } else if ("lifecyclePolicy".equals(fieldName)) {
                    deserializedAwsEcrRepositoryProperties.lifecyclePolicy = LifecyclePolicy.fromJson(reader);
                } else if ("repositoryName".equals(fieldName)) {
                    deserializedAwsEcrRepositoryProperties.repositoryName = reader.getString();
                } else if ("repositoryPolicyText".equals(fieldName)) {
                    Map<String, Object> repositoryPolicyText = reader.readMap(reader1 -> reader1.readUntyped());
                    deserializedAwsEcrRepositoryProperties.repositoryPolicyText = repositoryPolicyText;
                } else if ("repositoryUri".equals(fieldName)) {
                    deserializedAwsEcrRepositoryProperties.repositoryUri = reader.getString();
                } else if ("tags".equals(fieldName)) {
                    List<TagAutoGenerated24> tags = reader.readArray(reader1 -> TagAutoGenerated24.fromJson(reader1));
                    deserializedAwsEcrRepositoryProperties.tags = tags;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedAwsEcrRepositoryProperties;
        });
    }
}
