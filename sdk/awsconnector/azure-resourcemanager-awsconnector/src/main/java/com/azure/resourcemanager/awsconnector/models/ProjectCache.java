// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Definition of ProjectCache.
 */
@Fluent
public final class ProjectCache implements JsonSerializable<ProjectCache> {
    /*
     * <p>Information about the cache location: </p> <ul> <li> <p> <code>NO_CACHE</code> or <code>LOCAL</code>: This
     * value is ignored.</p> </li> <li> <p> <code>S3</code>: This is the S3 bucket name/prefix.</p> </li> </ul>
     */
    private String location;

    /*
     * <p>An array of strings that specify the local cache modes. You can use one or more local cache modes at the same
     * time. This is only used for <code>LOCAL</code> cache types.</p> <p>Possible values are:</p> <dl>
     * <dt>LOCAL_SOURCE_CACHE</dt> <dd> <p>Caches Git metadata for primary and secondary sources. After the cache is
     * created, subsequent builds pull only the change between commits. This mode is a good choice for projects with a
     * clean working directory and a source that is a large Git repository. If you choose this option and your project
     * does not use a Git repository (GitHub, GitHub Enterprise, or Bitbucket), the option is ignored. </p> </dd>
     * <dt>LOCAL_DOCKER_LAYER_CACHE</dt> <dd> <p>Caches existing Docker layers. This mode is a good choice for projects
     * that build or pull large Docker images. It can prevent the performance issues caused by pulling large Docker
     * images down from the network. </p> <note> <ul> <li> <p>You can use a Docker layer cache in the Linux environment
     * only. </p> </li> <li> <p>The <code>privileged</code> flag must be set so that your project has the required
     * Docker permissions. </p> </li> <li> <p>You should consider the security implications before you use a Docker
     * layer cache. </p> </li> </ul> </note> </dd> <dt>LOCAL_CUSTOM_CACHE</dt> <dd> <p>Caches directories you specify in
     * the buildspec file. This mode is a good choice if your build scenario is not suited to one of the other three
     * local cache modes. If you use a custom cache: </p> <ul> <li> <p>Only directories can be specified for caching.
     * You cannot specify individual files. </p> </li> <li> <p>Symlinks are used to reference cached directories. </p>
     * </li> <li> <p>Cached directories are linked to your build before it downloads its project sources. Cached items
     * are overridden if a source item has the same name. Directories are specified using cache paths in the buildspec
     * file. </p> </li> </ul> </dd> </dl>
     */
    private List<CacheMode> modes;

    /*
     * <p>The type of cache used by the build project. Valid values include:</p> <ul> <li> <p> <code>NO_CACHE</code>:
     * The build project does not use any cache.</p> </li> <li> <p> <code>S3</code>: The build project reads and writes
     * from and to S3.</p> </li> <li> <p> <code>LOCAL</code>: The build project stores a cache locally on a build host
     * that is only available to that build host.</p> </li> </ul>
     */
    private CacheTypeEnumValue type;

    /**
     * Creates an instance of ProjectCache class.
     */
    public ProjectCache() {
    }

    /**
     * Get the location property: &lt;p&gt;Information about the cache location: &lt;/p&gt; &lt;ul&gt; &lt;li&gt;
     * &lt;p&gt; &lt;code&gt;NO_CACHE&lt;/code&gt; or &lt;code&gt;LOCAL&lt;/code&gt;: This value is ignored.&lt;/p&gt;
     * &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;S3&lt;/code&gt;: This is the S3 bucket name/prefix.&lt;/p&gt;
     * &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @return the location value.
     */
    public String location() {
        return this.location;
    }

    /**
     * Set the location property: &lt;p&gt;Information about the cache location: &lt;/p&gt; &lt;ul&gt; &lt;li&gt;
     * &lt;p&gt; &lt;code&gt;NO_CACHE&lt;/code&gt; or &lt;code&gt;LOCAL&lt;/code&gt;: This value is ignored.&lt;/p&gt;
     * &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;S3&lt;/code&gt;: This is the S3 bucket name/prefix.&lt;/p&gt;
     * &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @param location the location value to set.
     * @return the ProjectCache object itself.
     */
    public ProjectCache withLocation(String location) {
        this.location = location;
        return this;
    }

    /**
     * Get the modes property: &lt;p&gt;An array of strings that specify the local cache modes. You can use one or more
     * local cache modes at the same time. This is only used for &lt;code&gt;LOCAL&lt;/code&gt; cache types.&lt;/p&gt;
     * &lt;p&gt;Possible values are:&lt;/p&gt; &lt;dl&gt; &lt;dt&gt;LOCAL_SOURCE_CACHE&lt;/dt&gt; &lt;dd&gt;
     * &lt;p&gt;Caches Git metadata for primary and secondary sources. After the cache is created, subsequent builds
     * pull only the change between commits. This mode is a good choice for projects with a clean working directory and
     * a source that is a large Git repository. If you choose this option and your project does not use a Git repository
     * (GitHub, GitHub Enterprise, or Bitbucket), the option is ignored. &lt;/p&gt; &lt;/dd&gt;
     * &lt;dt&gt;LOCAL_DOCKER_LAYER_CACHE&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Caches existing Docker layers. This mode is a
     * good choice for projects that build or pull large Docker images. It can prevent the performance issues caused by
     * pulling large Docker images down from the network. &lt;/p&gt; &lt;note&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You can
     * use a Docker layer cache in the Linux environment only. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The
     * &lt;code&gt;privileged&lt;/code&gt; flag must be set so that your project has the required Docker permissions.
     * &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;You should consider the security implications before you use a Docker
     * layer cache. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/note&gt; &lt;/dd&gt; &lt;dt&gt;LOCAL_CUSTOM_CACHE&lt;/dt&gt;
     * &lt;dd&gt; &lt;p&gt;Caches directories you specify in the buildspec file. This mode is a good choice if your
     * build scenario is not suited to one of the other three local cache modes. If you use a custom cache: &lt;/p&gt;
     * &lt;ul&gt; &lt;li&gt; &lt;p&gt;Only directories can be specified for caching. You cannot specify individual
     * files. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Symlinks are used to reference cached directories. &lt;/p&gt;
     * &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cached directories are linked to your build before it downloads its project
     * sources. Cached items are overridden if a source item has the same name. Directories are specified using cache
     * paths in the buildspec file. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;/dl&gt;.
     * 
     * @return the modes value.
     */
    public List<CacheMode> modes() {
        return this.modes;
    }

    /**
     * Set the modes property: &lt;p&gt;An array of strings that specify the local cache modes. You can use one or more
     * local cache modes at the same time. This is only used for &lt;code&gt;LOCAL&lt;/code&gt; cache types.&lt;/p&gt;
     * &lt;p&gt;Possible values are:&lt;/p&gt; &lt;dl&gt; &lt;dt&gt;LOCAL_SOURCE_CACHE&lt;/dt&gt; &lt;dd&gt;
     * &lt;p&gt;Caches Git metadata for primary and secondary sources. After the cache is created, subsequent builds
     * pull only the change between commits. This mode is a good choice for projects with a clean working directory and
     * a source that is a large Git repository. If you choose this option and your project does not use a Git repository
     * (GitHub, GitHub Enterprise, or Bitbucket), the option is ignored. &lt;/p&gt; &lt;/dd&gt;
     * &lt;dt&gt;LOCAL_DOCKER_LAYER_CACHE&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;Caches existing Docker layers. This mode is a
     * good choice for projects that build or pull large Docker images. It can prevent the performance issues caused by
     * pulling large Docker images down from the network. &lt;/p&gt; &lt;note&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;You can
     * use a Docker layer cache in the Linux environment only. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;The
     * &lt;code&gt;privileged&lt;/code&gt; flag must be set so that your project has the required Docker permissions.
     * &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;You should consider the security implications before you use a Docker
     * layer cache. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/note&gt; &lt;/dd&gt; &lt;dt&gt;LOCAL_CUSTOM_CACHE&lt;/dt&gt;
     * &lt;dd&gt; &lt;p&gt;Caches directories you specify in the buildspec file. This mode is a good choice if your
     * build scenario is not suited to one of the other three local cache modes. If you use a custom cache: &lt;/p&gt;
     * &lt;ul&gt; &lt;li&gt; &lt;p&gt;Only directories can be specified for caching. You cannot specify individual
     * files. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;Symlinks are used to reference cached directories. &lt;/p&gt;
     * &lt;/li&gt; &lt;li&gt; &lt;p&gt;Cached directories are linked to your build before it downloads its project
     * sources. Cached items are overridden if a source item has the same name. Directories are specified using cache
     * paths in the buildspec file. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/dd&gt; &lt;/dl&gt;.
     * 
     * @param modes the modes value to set.
     * @return the ProjectCache object itself.
     */
    public ProjectCache withModes(List<CacheMode> modes) {
        this.modes = modes;
        return this;
    }

    /**
     * Get the type property: &lt;p&gt;The type of cache used by the build project. Valid values include:&lt;/p&gt;
     * &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;NO_CACHE&lt;/code&gt;: The build project does not use any
     * cache.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;S3&lt;/code&gt;: The build project reads and writes
     * from and to S3.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;LOCAL&lt;/code&gt;: The build project
     * stores a cache locally on a build host that is only available to that build host.&lt;/p&gt; &lt;/li&gt;
     * &lt;/ul&gt;.
     * 
     * @return the type value.
     */
    public CacheTypeEnumValue type() {
        return this.type;
    }

    /**
     * Set the type property: &lt;p&gt;The type of cache used by the build project. Valid values include:&lt;/p&gt;
     * &lt;ul&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;NO_CACHE&lt;/code&gt;: The build project does not use any
     * cache.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;S3&lt;/code&gt;: The build project reads and writes
     * from and to S3.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;LOCAL&lt;/code&gt;: The build project
     * stores a cache locally on a build host that is only available to that build host.&lt;/p&gt; &lt;/li&gt;
     * &lt;/ul&gt;.
     * 
     * @param type the type value to set.
     * @return the ProjectCache object itself.
     */
    public ProjectCache withType(CacheTypeEnumValue type) {
        this.type = type;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (type() != null) {
            type().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("location", this.location);
        jsonWriter.writeArrayField("modes", this.modes,
            (writer, element) -> writer.writeString(element == null ? null : element.toString()));
        jsonWriter.writeJsonField("type", this.type);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ProjectCache from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ProjectCache if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the ProjectCache.
     */
    public static ProjectCache fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ProjectCache deserializedProjectCache = new ProjectCache();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("location".equals(fieldName)) {
                    deserializedProjectCache.location = reader.getString();
                } else if ("modes".equals(fieldName)) {
                    List<CacheMode> modes = reader.readArray(reader1 -> CacheMode.fromString(reader1.getString()));
                    deserializedProjectCache.modes = modes;
                } else if ("type".equals(fieldName)) {
                    deserializedProjectCache.type = CacheTypeEnumValue.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedProjectCache;
        });
    }
}
