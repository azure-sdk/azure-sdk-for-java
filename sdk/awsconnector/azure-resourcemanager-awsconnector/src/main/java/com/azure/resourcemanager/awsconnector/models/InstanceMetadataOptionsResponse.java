// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Definition of InstanceMetadataOptionsResponse.
 */
@Fluent
public final class InstanceMetadataOptionsResponse implements JsonSerializable<InstanceMetadataOptionsResponse> {
    /*
     * <p>Indicates whether the HTTP metadata endpoint on your instances is enabled or disabled.</p> <p>If the value is
     * <code>disabled</code>, you cannot access your instance metadata.</p>
     */
    private InstanceMetadataEndpointStateEnumValue httpEndpoint;

    /*
     * <p>Indicates whether the IPv6 endpoint for the instance metadata service is enabled or disabled.</p> <p>Default:
     * <code>disabled</code> </p>
     */
    private InstanceMetadataProtocolStateEnumValue httpProtocolIpv6;

    /*
     * <p>The maximum number of hops that the metadata token can travel.</p> <p>Possible values: Integers from
     * <code>1</code> to <code>64</code> </p>
     */
    private Integer httpPutResponseHopLimit;

    /*
     * <p>Indicates whether IMDSv2 is required.</p> <ul> <li> <p> <code>optional</code> - IMDSv2 is optional, which
     * means that you can use either IMDSv2 or IMDSv1.</p> </li> <li> <p> <code>required</code> - IMDSv2 is required,
     * which means that IMDSv1 is disabled, and you must use IMDSv2.</p> </li> </ul>
     */
    private HttpTokensStateEnumValue httpTokens;

    /*
     * <p>Indicates whether access to instance tags from the instance metadata is enabled or disabled. For more
     * information, see <a
     * href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS'>Work with
     * instance tags using the instance metadata</a>.</p>
     */
    private InstanceMetadataTagsStateEnumValue instanceMetadataTags;

    /*
     * <p>The state of the metadata option changes.</p> <p> <code>pending</code> - The metadata options are being
     * updated and the instance is not ready to process metadata traffic with the new selection.</p> <p>
     * <code>applied</code> - The metadata options have been successfully applied on the instance.</p>
     */
    private InstanceMetadataOptionsStateEnumValue state;

    /**
     * Creates an instance of InstanceMetadataOptionsResponse class.
     */
    public InstanceMetadataOptionsResponse() {
    }

    /**
     * Get the httpEndpoint property: &lt;p&gt;Indicates whether the HTTP metadata endpoint on your instances is enabled
     * or disabled.&lt;/p&gt; &lt;p&gt;If the value is &lt;code&gt;disabled&lt;/code&gt;, you cannot access your
     * instance metadata.&lt;/p&gt;.
     * 
     * @return the httpEndpoint value.
     */
    public InstanceMetadataEndpointStateEnumValue httpEndpoint() {
        return this.httpEndpoint;
    }

    /**
     * Set the httpEndpoint property: &lt;p&gt;Indicates whether the HTTP metadata endpoint on your instances is enabled
     * or disabled.&lt;/p&gt; &lt;p&gt;If the value is &lt;code&gt;disabled&lt;/code&gt;, you cannot access your
     * instance metadata.&lt;/p&gt;.
     * 
     * @param httpEndpoint the httpEndpoint value to set.
     * @return the InstanceMetadataOptionsResponse object itself.
     */
    public InstanceMetadataOptionsResponse withHttpEndpoint(InstanceMetadataEndpointStateEnumValue httpEndpoint) {
        this.httpEndpoint = httpEndpoint;
        return this;
    }

    /**
     * Get the httpProtocolIpv6 property: &lt;p&gt;Indicates whether the IPv6 endpoint for the instance metadata service
     * is enabled or disabled.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;disabled&lt;/code&gt; &lt;/p&gt;.
     * 
     * @return the httpProtocolIpv6 value.
     */
    public InstanceMetadataProtocolStateEnumValue httpProtocolIpv6() {
        return this.httpProtocolIpv6;
    }

    /**
     * Set the httpProtocolIpv6 property: &lt;p&gt;Indicates whether the IPv6 endpoint for the instance metadata service
     * is enabled or disabled.&lt;/p&gt; &lt;p&gt;Default: &lt;code&gt;disabled&lt;/code&gt; &lt;/p&gt;.
     * 
     * @param httpProtocolIpv6 the httpProtocolIpv6 value to set.
     * @return the InstanceMetadataOptionsResponse object itself.
     */
    public InstanceMetadataOptionsResponse
        withHttpProtocolIpv6(InstanceMetadataProtocolStateEnumValue httpProtocolIpv6) {
        this.httpProtocolIpv6 = httpProtocolIpv6;
        return this;
    }

    /**
     * Get the httpPutResponseHopLimit property: &lt;p&gt;The maximum number of hops that the metadata token can
     * travel.&lt;/p&gt; &lt;p&gt;Possible values: Integers from &lt;code&gt;1&lt;/code&gt; to
     * &lt;code&gt;64&lt;/code&gt; &lt;/p&gt;.
     * 
     * @return the httpPutResponseHopLimit value.
     */
    public Integer httpPutResponseHopLimit() {
        return this.httpPutResponseHopLimit;
    }

    /**
     * Set the httpPutResponseHopLimit property: &lt;p&gt;The maximum number of hops that the metadata token can
     * travel.&lt;/p&gt; &lt;p&gt;Possible values: Integers from &lt;code&gt;1&lt;/code&gt; to
     * &lt;code&gt;64&lt;/code&gt; &lt;/p&gt;.
     * 
     * @param httpPutResponseHopLimit the httpPutResponseHopLimit value to set.
     * @return the InstanceMetadataOptionsResponse object itself.
     */
    public InstanceMetadataOptionsResponse withHttpPutResponseHopLimit(Integer httpPutResponseHopLimit) {
        this.httpPutResponseHopLimit = httpPutResponseHopLimit;
        return this;
    }

    /**
     * Get the httpTokens property: &lt;p&gt;Indicates whether IMDSv2 is required.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;
     * &lt;p&gt; &lt;code&gt;optional&lt;/code&gt; - IMDSv2 is optional, which means that you can use either IMDSv2 or
     * IMDSv1.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;required&lt;/code&gt; - IMDSv2 is required, which
     * means that IMDSv1 is disabled, and you must use IMDSv2.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @return the httpTokens value.
     */
    public HttpTokensStateEnumValue httpTokens() {
        return this.httpTokens;
    }

    /**
     * Set the httpTokens property: &lt;p&gt;Indicates whether IMDSv2 is required.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;
     * &lt;p&gt; &lt;code&gt;optional&lt;/code&gt; - IMDSv2 is optional, which means that you can use either IMDSv2 or
     * IMDSv1.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;required&lt;/code&gt; - IMDSv2 is required, which
     * means that IMDSv1 is disabled, and you must use IMDSv2.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @param httpTokens the httpTokens value to set.
     * @return the InstanceMetadataOptionsResponse object itself.
     */
    public InstanceMetadataOptionsResponse withHttpTokens(HttpTokensStateEnumValue httpTokens) {
        this.httpTokens = httpTokens;
        return this;
    }

    /**
     * Get the instanceMetadataTags property: &lt;p&gt;Indicates whether access to instance tags from the instance
     * metadata is enabled or disabled. For more information, see &lt;a
     * href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS'&gt;Work with
     * instance tags using the instance metadata&lt;/a&gt;.&lt;/p&gt;.
     * 
     * @return the instanceMetadataTags value.
     */
    public InstanceMetadataTagsStateEnumValue instanceMetadataTags() {
        return this.instanceMetadataTags;
    }

    /**
     * Set the instanceMetadataTags property: &lt;p&gt;Indicates whether access to instance tags from the instance
     * metadata is enabled or disabled. For more information, see &lt;a
     * href='https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html#work-with-tags-in-IMDS'&gt;Work with
     * instance tags using the instance metadata&lt;/a&gt;.&lt;/p&gt;.
     * 
     * @param instanceMetadataTags the instanceMetadataTags value to set.
     * @return the InstanceMetadataOptionsResponse object itself.
     */
    public InstanceMetadataOptionsResponse
        withInstanceMetadataTags(InstanceMetadataTagsStateEnumValue instanceMetadataTags) {
        this.instanceMetadataTags = instanceMetadataTags;
        return this;
    }

    /**
     * Get the state property: &lt;p&gt;The state of the metadata option changes.&lt;/p&gt; &lt;p&gt;
     * &lt;code&gt;pending&lt;/code&gt; - The metadata options are being updated and the instance is not ready to
     * process metadata traffic with the new selection.&lt;/p&gt; &lt;p&gt; &lt;code&gt;applied&lt;/code&gt; - The
     * metadata options have been successfully applied on the instance.&lt;/p&gt;.
     * 
     * @return the state value.
     */
    public InstanceMetadataOptionsStateEnumValue state() {
        return this.state;
    }

    /**
     * Set the state property: &lt;p&gt;The state of the metadata option changes.&lt;/p&gt; &lt;p&gt;
     * &lt;code&gt;pending&lt;/code&gt; - The metadata options are being updated and the instance is not ready to
     * process metadata traffic with the new selection.&lt;/p&gt; &lt;p&gt; &lt;code&gt;applied&lt;/code&gt; - The
     * metadata options have been successfully applied on the instance.&lt;/p&gt;.
     * 
     * @param state the state value to set.
     * @return the InstanceMetadataOptionsResponse object itself.
     */
    public InstanceMetadataOptionsResponse withState(InstanceMetadataOptionsStateEnumValue state) {
        this.state = state;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (httpEndpoint() != null) {
            httpEndpoint().validate();
        }
        if (httpProtocolIpv6() != null) {
            httpProtocolIpv6().validate();
        }
        if (httpTokens() != null) {
            httpTokens().validate();
        }
        if (instanceMetadataTags() != null) {
            instanceMetadataTags().validate();
        }
        if (state() != null) {
            state().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeJsonField("httpEndpoint", this.httpEndpoint);
        jsonWriter.writeJsonField("httpProtocolIpv6", this.httpProtocolIpv6);
        jsonWriter.writeNumberField("httpPutResponseHopLimit", this.httpPutResponseHopLimit);
        jsonWriter.writeJsonField("httpTokens", this.httpTokens);
        jsonWriter.writeJsonField("instanceMetadataTags", this.instanceMetadataTags);
        jsonWriter.writeJsonField("state", this.state);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of InstanceMetadataOptionsResponse from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of InstanceMetadataOptionsResponse if the JsonReader was pointing to an instance of it, or
     * null if it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the InstanceMetadataOptionsResponse.
     */
    public static InstanceMetadataOptionsResponse fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            InstanceMetadataOptionsResponse deserializedInstanceMetadataOptionsResponse
                = new InstanceMetadataOptionsResponse();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("httpEndpoint".equals(fieldName)) {
                    deserializedInstanceMetadataOptionsResponse.httpEndpoint
                        = InstanceMetadataEndpointStateEnumValue.fromJson(reader);
                } else if ("httpProtocolIpv6".equals(fieldName)) {
                    deserializedInstanceMetadataOptionsResponse.httpProtocolIpv6
                        = InstanceMetadataProtocolStateEnumValue.fromJson(reader);
                } else if ("httpPutResponseHopLimit".equals(fieldName)) {
                    deserializedInstanceMetadataOptionsResponse.httpPutResponseHopLimit
                        = reader.getNullable(JsonReader::getInt);
                } else if ("httpTokens".equals(fieldName)) {
                    deserializedInstanceMetadataOptionsResponse.httpTokens = HttpTokensStateEnumValue.fromJson(reader);
                } else if ("instanceMetadataTags".equals(fieldName)) {
                    deserializedInstanceMetadataOptionsResponse.instanceMetadataTags
                        = InstanceMetadataTagsStateEnumValue.fromJson(reader);
                } else if ("state".equals(fieldName)) {
                    deserializedInstanceMetadataOptionsResponse.state
                        = InstanceMetadataOptionsStateEnumValue.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedInstanceMetadataOptionsResponse;
        });
    }
}
