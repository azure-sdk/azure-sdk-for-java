// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Definition of Ec2InstanceAttributes.
 */
@Fluent
public final class Ec2InstanceAttributes implements JsonSerializable<Ec2InstanceAttributes> {
    /*
     * <p>A list of additional Amazon EC2 security group IDs for the master node.</p>
     */
    private List<String> additionalMasterSecurityGroups;

    /*
     * <p>A list of additional Amazon EC2 security group IDs for the core and task nodes.</p>
     */
    private List<String> additionalSlaveSecurityGroups;

    /*
     * <p>The Availability Zone in which the cluster will run. </p>
     */
    private String ec2AvailabilityZone;

    /*
     * <p>The name of the Amazon EC2 key pair to use when connecting with SSH into the master node as a user named
     * 'hadoop'.</p>
     */
    private String ec2KeyName;

    /*
     * <p>Set this parameter to the identifier of the Amazon VPC subnet where you want the cluster to launch. If you do
     * not specify this value, and your account supports EC2-Classic, the cluster launches in EC2-Classic.</p>
     */
    private String ec2SubnetId;

    /*
     * <p>The identifier of the Amazon EC2 security group for the master node.</p>
     */
    private String emrManagedMasterSecurityGroup;

    /*
     * <p>The identifier of the Amazon EC2 security group for the core and task nodes.</p>
     */
    private String emrManagedSlaveSecurityGroup;

    /*
     * <p>The IAM role that was specified when the cluster was launched. The Amazon EC2 instances of the cluster assume
     * this role.</p>
     */
    private String iamInstanceProfile;

    /*
     * <p>Applies to clusters configured with the instance fleets option. Specifies one or more Availability Zones in
     * which to launch Amazon EC2 cluster instances when the EC2-Classic network configuration is supported. Amazon EMR
     * chooses the Availability Zone with the best fit from among the list of
     * <code>RequestedEc2AvailabilityZones</code>, and then launches all cluster instances within that Availability
     * Zone. If you do not specify this value, Amazon EMR chooses the Availability Zone for you.
     * <code>RequestedEc2SubnetIDs</code> and <code>RequestedEc2AvailabilityZones</code> cannot be specified
     * together.</p>
     */
    private List<String> requestedEc2AvailabilityZones;

    /*
     * <p>Applies to clusters configured with the instance fleets option. Specifies the unique identifier of one or more
     * Amazon EC2 subnets in which to launch Amazon EC2 cluster instances. Subnets must exist within the same VPC.
     * Amazon EMR chooses the Amazon EC2 subnet with the best fit from among the list of
     * <code>RequestedEc2SubnetIds</code>, and then launches all cluster instances within that Subnet. If this value is
     * not specified, and the account and Region support EC2-Classic networks, the cluster launches instances in the
     * EC2-Classic network and uses <code>RequestedEc2AvailabilityZones</code> instead of this setting. If EC2-Classic
     * is not supported, and no Subnet is specified, Amazon EMR chooses the subnet for you.
     * <code>RequestedEc2SubnetIDs</code> and <code>RequestedEc2AvailabilityZones</code> cannot be specified
     * together.</p>
     */
    private List<String> requestedEc2SubnetIds;

    /*
     * <p>The identifier of the Amazon EC2 security group for the Amazon EMR service to access clusters in VPC private
     * subnets.</p>
     */
    private String serviceAccessSecurityGroup;

    /**
     * Creates an instance of Ec2InstanceAttributes class.
     */
    public Ec2InstanceAttributes() {
    }

    /**
     * Get the additionalMasterSecurityGroups property: &lt;p&gt;A list of additional Amazon EC2 security group IDs for
     * the master node.&lt;/p&gt;.
     * 
     * @return the additionalMasterSecurityGroups value.
     */
    public List<String> additionalMasterSecurityGroups() {
        return this.additionalMasterSecurityGroups;
    }

    /**
     * Set the additionalMasterSecurityGroups property: &lt;p&gt;A list of additional Amazon EC2 security group IDs for
     * the master node.&lt;/p&gt;.
     * 
     * @param additionalMasterSecurityGroups the additionalMasterSecurityGroups value to set.
     * @return the Ec2InstanceAttributes object itself.
     */
    public Ec2InstanceAttributes withAdditionalMasterSecurityGroups(List<String> additionalMasterSecurityGroups) {
        this.additionalMasterSecurityGroups = additionalMasterSecurityGroups;
        return this;
    }

    /**
     * Get the additionalSlaveSecurityGroups property: &lt;p&gt;A list of additional Amazon EC2 security group IDs for
     * the core and task nodes.&lt;/p&gt;.
     * 
     * @return the additionalSlaveSecurityGroups value.
     */
    public List<String> additionalSlaveSecurityGroups() {
        return this.additionalSlaveSecurityGroups;
    }

    /**
     * Set the additionalSlaveSecurityGroups property: &lt;p&gt;A list of additional Amazon EC2 security group IDs for
     * the core and task nodes.&lt;/p&gt;.
     * 
     * @param additionalSlaveSecurityGroups the additionalSlaveSecurityGroups value to set.
     * @return the Ec2InstanceAttributes object itself.
     */
    public Ec2InstanceAttributes withAdditionalSlaveSecurityGroups(List<String> additionalSlaveSecurityGroups) {
        this.additionalSlaveSecurityGroups = additionalSlaveSecurityGroups;
        return this;
    }

    /**
     * Get the ec2AvailabilityZone property: &lt;p&gt;The Availability Zone in which the cluster will run. &lt;/p&gt;.
     * 
     * @return the ec2AvailabilityZone value.
     */
    public String ec2AvailabilityZone() {
        return this.ec2AvailabilityZone;
    }

    /**
     * Set the ec2AvailabilityZone property: &lt;p&gt;The Availability Zone in which the cluster will run. &lt;/p&gt;.
     * 
     * @param ec2AvailabilityZone the ec2AvailabilityZone value to set.
     * @return the Ec2InstanceAttributes object itself.
     */
    public Ec2InstanceAttributes withEc2AvailabilityZone(String ec2AvailabilityZone) {
        this.ec2AvailabilityZone = ec2AvailabilityZone;
        return this;
    }

    /**
     * Get the ec2KeyName property: &lt;p&gt;The name of the Amazon EC2 key pair to use when connecting with SSH into
     * the master node as a user named 'hadoop'.&lt;/p&gt;.
     * 
     * @return the ec2KeyName value.
     */
    public String ec2KeyName() {
        return this.ec2KeyName;
    }

    /**
     * Set the ec2KeyName property: &lt;p&gt;The name of the Amazon EC2 key pair to use when connecting with SSH into
     * the master node as a user named 'hadoop'.&lt;/p&gt;.
     * 
     * @param ec2KeyName the ec2KeyName value to set.
     * @return the Ec2InstanceAttributes object itself.
     */
    public Ec2InstanceAttributes withEc2KeyName(String ec2KeyName) {
        this.ec2KeyName = ec2KeyName;
        return this;
    }

    /**
     * Get the ec2SubnetId property: &lt;p&gt;Set this parameter to the identifier of the Amazon VPC subnet where you
     * want the cluster to launch. If you do not specify this value, and your account supports EC2-Classic, the cluster
     * launches in EC2-Classic.&lt;/p&gt;.
     * 
     * @return the ec2SubnetId value.
     */
    public String ec2SubnetId() {
        return this.ec2SubnetId;
    }

    /**
     * Set the ec2SubnetId property: &lt;p&gt;Set this parameter to the identifier of the Amazon VPC subnet where you
     * want the cluster to launch. If you do not specify this value, and your account supports EC2-Classic, the cluster
     * launches in EC2-Classic.&lt;/p&gt;.
     * 
     * @param ec2SubnetId the ec2SubnetId value to set.
     * @return the Ec2InstanceAttributes object itself.
     */
    public Ec2InstanceAttributes withEc2SubnetId(String ec2SubnetId) {
        this.ec2SubnetId = ec2SubnetId;
        return this;
    }

    /**
     * Get the emrManagedMasterSecurityGroup property: &lt;p&gt;The identifier of the Amazon EC2 security group for the
     * master node.&lt;/p&gt;.
     * 
     * @return the emrManagedMasterSecurityGroup value.
     */
    public String emrManagedMasterSecurityGroup() {
        return this.emrManagedMasterSecurityGroup;
    }

    /**
     * Set the emrManagedMasterSecurityGroup property: &lt;p&gt;The identifier of the Amazon EC2 security group for the
     * master node.&lt;/p&gt;.
     * 
     * @param emrManagedMasterSecurityGroup the emrManagedMasterSecurityGroup value to set.
     * @return the Ec2InstanceAttributes object itself.
     */
    public Ec2InstanceAttributes withEmrManagedMasterSecurityGroup(String emrManagedMasterSecurityGroup) {
        this.emrManagedMasterSecurityGroup = emrManagedMasterSecurityGroup;
        return this;
    }

    /**
     * Get the emrManagedSlaveSecurityGroup property: &lt;p&gt;The identifier of the Amazon EC2 security group for the
     * core and task nodes.&lt;/p&gt;.
     * 
     * @return the emrManagedSlaveSecurityGroup value.
     */
    public String emrManagedSlaveSecurityGroup() {
        return this.emrManagedSlaveSecurityGroup;
    }

    /**
     * Set the emrManagedSlaveSecurityGroup property: &lt;p&gt;The identifier of the Amazon EC2 security group for the
     * core and task nodes.&lt;/p&gt;.
     * 
     * @param emrManagedSlaveSecurityGroup the emrManagedSlaveSecurityGroup value to set.
     * @return the Ec2InstanceAttributes object itself.
     */
    public Ec2InstanceAttributes withEmrManagedSlaveSecurityGroup(String emrManagedSlaveSecurityGroup) {
        this.emrManagedSlaveSecurityGroup = emrManagedSlaveSecurityGroup;
        return this;
    }

    /**
     * Get the iamInstanceProfile property: &lt;p&gt;The IAM role that was specified when the cluster was launched. The
     * Amazon EC2 instances of the cluster assume this role.&lt;/p&gt;.
     * 
     * @return the iamInstanceProfile value.
     */
    public String iamInstanceProfile() {
        return this.iamInstanceProfile;
    }

    /**
     * Set the iamInstanceProfile property: &lt;p&gt;The IAM role that was specified when the cluster was launched. The
     * Amazon EC2 instances of the cluster assume this role.&lt;/p&gt;.
     * 
     * @param iamInstanceProfile the iamInstanceProfile value to set.
     * @return the Ec2InstanceAttributes object itself.
     */
    public Ec2InstanceAttributes withIamInstanceProfile(String iamInstanceProfile) {
        this.iamInstanceProfile = iamInstanceProfile;
        return this;
    }

    /**
     * Get the requestedEc2AvailabilityZones property: &lt;p&gt;Applies to clusters configured with the instance fleets
     * option. Specifies one or more Availability Zones in which to launch Amazon EC2 cluster instances when the
     * EC2-Classic network configuration is supported. Amazon EMR chooses the Availability Zone with the best fit from
     * among the list of &lt;code&gt;RequestedEc2AvailabilityZones&lt;/code&gt;, and then launches all cluster instances
     * within that Availability Zone. If you do not specify this value, Amazon EMR chooses the Availability Zone for
     * you. &lt;code&gt;RequestedEc2SubnetIDs&lt;/code&gt; and &lt;code&gt;RequestedEc2AvailabilityZones&lt;/code&gt;
     * cannot be specified together.&lt;/p&gt;.
     * 
     * @return the requestedEc2AvailabilityZones value.
     */
    public List<String> requestedEc2AvailabilityZones() {
        return this.requestedEc2AvailabilityZones;
    }

    /**
     * Set the requestedEc2AvailabilityZones property: &lt;p&gt;Applies to clusters configured with the instance fleets
     * option. Specifies one or more Availability Zones in which to launch Amazon EC2 cluster instances when the
     * EC2-Classic network configuration is supported. Amazon EMR chooses the Availability Zone with the best fit from
     * among the list of &lt;code&gt;RequestedEc2AvailabilityZones&lt;/code&gt;, and then launches all cluster instances
     * within that Availability Zone. If you do not specify this value, Amazon EMR chooses the Availability Zone for
     * you. &lt;code&gt;RequestedEc2SubnetIDs&lt;/code&gt; and &lt;code&gt;RequestedEc2AvailabilityZones&lt;/code&gt;
     * cannot be specified together.&lt;/p&gt;.
     * 
     * @param requestedEc2AvailabilityZones the requestedEc2AvailabilityZones value to set.
     * @return the Ec2InstanceAttributes object itself.
     */
    public Ec2InstanceAttributes withRequestedEc2AvailabilityZones(List<String> requestedEc2AvailabilityZones) {
        this.requestedEc2AvailabilityZones = requestedEc2AvailabilityZones;
        return this;
    }

    /**
     * Get the requestedEc2SubnetIds property: &lt;p&gt;Applies to clusters configured with the instance fleets option.
     * Specifies the unique identifier of one or more Amazon EC2 subnets in which to launch Amazon EC2 cluster
     * instances. Subnets must exist within the same VPC. Amazon EMR chooses the Amazon EC2 subnet with the best fit
     * from among the list of &lt;code&gt;RequestedEc2SubnetIds&lt;/code&gt;, and then launches all cluster instances
     * within that Subnet. If this value is not specified, and the account and Region support EC2-Classic networks, the
     * cluster launches instances in the EC2-Classic network and uses
     * &lt;code&gt;RequestedEc2AvailabilityZones&lt;/code&gt; instead of this setting. If EC2-Classic is not supported,
     * and no Subnet is specified, Amazon EMR chooses the subnet for you. &lt;code&gt;RequestedEc2SubnetIDs&lt;/code&gt;
     * and &lt;code&gt;RequestedEc2AvailabilityZones&lt;/code&gt; cannot be specified together.&lt;/p&gt;.
     * 
     * @return the requestedEc2SubnetIds value.
     */
    public List<String> requestedEc2SubnetIds() {
        return this.requestedEc2SubnetIds;
    }

    /**
     * Set the requestedEc2SubnetIds property: &lt;p&gt;Applies to clusters configured with the instance fleets option.
     * Specifies the unique identifier of one or more Amazon EC2 subnets in which to launch Amazon EC2 cluster
     * instances. Subnets must exist within the same VPC. Amazon EMR chooses the Amazon EC2 subnet with the best fit
     * from among the list of &lt;code&gt;RequestedEc2SubnetIds&lt;/code&gt;, and then launches all cluster instances
     * within that Subnet. If this value is not specified, and the account and Region support EC2-Classic networks, the
     * cluster launches instances in the EC2-Classic network and uses
     * &lt;code&gt;RequestedEc2AvailabilityZones&lt;/code&gt; instead of this setting. If EC2-Classic is not supported,
     * and no Subnet is specified, Amazon EMR chooses the subnet for you. &lt;code&gt;RequestedEc2SubnetIDs&lt;/code&gt;
     * and &lt;code&gt;RequestedEc2AvailabilityZones&lt;/code&gt; cannot be specified together.&lt;/p&gt;.
     * 
     * @param requestedEc2SubnetIds the requestedEc2SubnetIds value to set.
     * @return the Ec2InstanceAttributes object itself.
     */
    public Ec2InstanceAttributes withRequestedEc2SubnetIds(List<String> requestedEc2SubnetIds) {
        this.requestedEc2SubnetIds = requestedEc2SubnetIds;
        return this;
    }

    /**
     * Get the serviceAccessSecurityGroup property: &lt;p&gt;The identifier of the Amazon EC2 security group for the
     * Amazon EMR service to access clusters in VPC private subnets.&lt;/p&gt;.
     * 
     * @return the serviceAccessSecurityGroup value.
     */
    public String serviceAccessSecurityGroup() {
        return this.serviceAccessSecurityGroup;
    }

    /**
     * Set the serviceAccessSecurityGroup property: &lt;p&gt;The identifier of the Amazon EC2 security group for the
     * Amazon EMR service to access clusters in VPC private subnets.&lt;/p&gt;.
     * 
     * @param serviceAccessSecurityGroup the serviceAccessSecurityGroup value to set.
     * @return the Ec2InstanceAttributes object itself.
     */
    public Ec2InstanceAttributes withServiceAccessSecurityGroup(String serviceAccessSecurityGroup) {
        this.serviceAccessSecurityGroup = serviceAccessSecurityGroup;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("additionalMasterSecurityGroups", this.additionalMasterSecurityGroups,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("additionalSlaveSecurityGroups", this.additionalSlaveSecurityGroups,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("ec2AvailabilityZone", this.ec2AvailabilityZone);
        jsonWriter.writeStringField("ec2KeyName", this.ec2KeyName);
        jsonWriter.writeStringField("ec2SubnetId", this.ec2SubnetId);
        jsonWriter.writeStringField("emrManagedMasterSecurityGroup", this.emrManagedMasterSecurityGroup);
        jsonWriter.writeStringField("emrManagedSlaveSecurityGroup", this.emrManagedSlaveSecurityGroup);
        jsonWriter.writeStringField("iamInstanceProfile", this.iamInstanceProfile);
        jsonWriter.writeArrayField("requestedEc2AvailabilityZones", this.requestedEc2AvailabilityZones,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("requestedEc2SubnetIds", this.requestedEc2SubnetIds,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("serviceAccessSecurityGroup", this.serviceAccessSecurityGroup);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of Ec2InstanceAttributes from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of Ec2InstanceAttributes if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the Ec2InstanceAttributes.
     */
    public static Ec2InstanceAttributes fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            Ec2InstanceAttributes deserializedEc2InstanceAttributes = new Ec2InstanceAttributes();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("additionalMasterSecurityGroups".equals(fieldName)) {
                    List<String> additionalMasterSecurityGroups = reader.readArray(reader1 -> reader1.getString());
                    deserializedEc2InstanceAttributes.additionalMasterSecurityGroups = additionalMasterSecurityGroups;
                } else if ("additionalSlaveSecurityGroups".equals(fieldName)) {
                    List<String> additionalSlaveSecurityGroups = reader.readArray(reader1 -> reader1.getString());
                    deserializedEc2InstanceAttributes.additionalSlaveSecurityGroups = additionalSlaveSecurityGroups;
                } else if ("ec2AvailabilityZone".equals(fieldName)) {
                    deserializedEc2InstanceAttributes.ec2AvailabilityZone = reader.getString();
                } else if ("ec2KeyName".equals(fieldName)) {
                    deserializedEc2InstanceAttributes.ec2KeyName = reader.getString();
                } else if ("ec2SubnetId".equals(fieldName)) {
                    deserializedEc2InstanceAttributes.ec2SubnetId = reader.getString();
                } else if ("emrManagedMasterSecurityGroup".equals(fieldName)) {
                    deserializedEc2InstanceAttributes.emrManagedMasterSecurityGroup = reader.getString();
                } else if ("emrManagedSlaveSecurityGroup".equals(fieldName)) {
                    deserializedEc2InstanceAttributes.emrManagedSlaveSecurityGroup = reader.getString();
                } else if ("iamInstanceProfile".equals(fieldName)) {
                    deserializedEc2InstanceAttributes.iamInstanceProfile = reader.getString();
                } else if ("requestedEc2AvailabilityZones".equals(fieldName)) {
                    List<String> requestedEc2AvailabilityZones = reader.readArray(reader1 -> reader1.getString());
                    deserializedEc2InstanceAttributes.requestedEc2AvailabilityZones = requestedEc2AvailabilityZones;
                } else if ("requestedEc2SubnetIds".equals(fieldName)) {
                    List<String> requestedEc2SubnetIds = reader.readArray(reader1 -> reader1.getString());
                    deserializedEc2InstanceAttributes.requestedEc2SubnetIds = requestedEc2SubnetIds;
                } else if ("serviceAccessSecurityGroup".equals(fieldName)) {
                    deserializedEc2InstanceAttributes.serviceAccessSecurityGroup = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedEc2InstanceAttributes;
        });
    }
}
