// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Definition of awsElasticLoadBalancingV2TargetGroup.
 */
@Fluent
public final class AwsElasticLoadBalancingV2TargetGroupProperties
    implements JsonSerializable<AwsElasticLoadBalancingV2TargetGroupProperties> {
    /*
     * Indicates whether health checks are enabled. If the target type is lambda, health checks are disabled by default
     * but can be enabled. If the target type is instance, ip, or alb, health checks are always enabled and cannot be
     * disabled.
     */
    private Boolean healthCheckEnabled;

    /*
     * The approximate amount of time, in seconds, between health checks of an individual target.
     */
    private Integer healthCheckIntervalSeconds;

    /*
     * [HTTP/HTTPS health checks] The destination for health checks on the targets. [HTTP1 or HTTP2 protocol version]
     * The ping path. The default is /. [GRPC protocol version] The path of a custom health check method with the format
     * /package.service/method. The default is /AWS.ALB/healthcheck.
     */
    private String healthCheckPath;

    /*
     * The port the load balancer uses when performing health checks on targets.
     */
    private String healthCheckPort;

    /*
     * The protocol the load balancer uses when performing health checks on targets.
     */
    private String healthCheckProtocol;

    /*
     * The amount of time, in seconds, during which no response from a target means a failed health check.
     */
    private Integer healthCheckTimeoutSeconds;

    /*
     * The number of consecutive health checks successes required before considering an unhealthy target healthy.
     */
    private Integer healthyThresholdCount;

    /*
     * The type of IP address used for this target group. The possible values are ipv4 and ipv6.
     */
    private String ipAddressType;

    /*
     * The Amazon Resource Names (ARNs) of the load balancers that route traffic to this target group.
     */
    private List<String> loadBalancerArns;

    /*
     * [HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful response from a target.
     */
    private Matcher matcher;

    /*
     * The name of the target group.
     */
    private String name;

    /*
     * The port on which the targets receive traffic. This port is used unless you specify a port override when
     * registering the target. If the target is a Lambda function, this parameter does not apply. If the protocol is
     * GENEVE, the supported port is 6081.
     */
    private Integer port;

    /*
     * The protocol to use for routing traffic to the targets.
     */
    private String protocol;

    /*
     * [HTTP/HTTPS protocol] The protocol version. The possible values are GRPC, HTTP1, and HTTP2.
     */
    private String protocolVersion;

    /*
     * The tags.
     */
    private List<TagAutoGenerated30> tags;

    /*
     * The ARN of the Target Group
     */
    private String targetGroupArn;

    /*
     * The attributes.
     */
    private List<TargetGroupAttribute> targetGroupAttributes;

    /*
     * The full name of the target group.
     */
    private String targetGroupFullName;

    /*
     * The name of the target group.
     */
    private String targetGroupName;

    /*
     * The type of target that you must specify when registering targets with this target group. You can't specify
     * targets for a target group using more than one target type.
     */
    private String targetType;

    /*
     * The targets.
     */
    private List<TargetDescription> targets;

    /*
     * The number of consecutive health check failures required before considering a target unhealthy.
     */
    private Integer unhealthyThresholdCount;

    /*
     * The identifier of the virtual private cloud (VPC). If the target is a Lambda function, this parameter does not
     * apply.
     */
    private String vpcId;

    /**
     * Creates an instance of AwsElasticLoadBalancingV2TargetGroupProperties class.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties() {
    }

    /**
     * Get the healthCheckEnabled property: Indicates whether health checks are enabled. If the target type is lambda,
     * health checks are disabled by default but can be enabled. If the target type is instance, ip, or alb, health
     * checks are always enabled and cannot be disabled.
     * 
     * @return the healthCheckEnabled value.
     */
    public Boolean healthCheckEnabled() {
        return this.healthCheckEnabled;
    }

    /**
     * Set the healthCheckEnabled property: Indicates whether health checks are enabled. If the target type is lambda,
     * health checks are disabled by default but can be enabled. If the target type is instance, ip, or alb, health
     * checks are always enabled and cannot be disabled.
     * 
     * @param healthCheckEnabled the healthCheckEnabled value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withHealthCheckEnabled(Boolean healthCheckEnabled) {
        this.healthCheckEnabled = healthCheckEnabled;
        return this;
    }

    /**
     * Get the healthCheckIntervalSeconds property: The approximate amount of time, in seconds, between health checks of
     * an individual target.
     * 
     * @return the healthCheckIntervalSeconds value.
     */
    public Integer healthCheckIntervalSeconds() {
        return this.healthCheckIntervalSeconds;
    }

    /**
     * Set the healthCheckIntervalSeconds property: The approximate amount of time, in seconds, between health checks of
     * an individual target.
     * 
     * @param healthCheckIntervalSeconds the healthCheckIntervalSeconds value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties
        withHealthCheckIntervalSeconds(Integer healthCheckIntervalSeconds) {
        this.healthCheckIntervalSeconds = healthCheckIntervalSeconds;
        return this;
    }

    /**
     * Get the healthCheckPath property: [HTTP/HTTPS health checks] The destination for health checks on the targets.
     * [HTTP1 or HTTP2 protocol version] The ping path. The default is /. [GRPC protocol version] The path of a custom
     * health check method with the format /package.service/method. The default is /AWS.ALB/healthcheck.
     * 
     * @return the healthCheckPath value.
     */
    public String healthCheckPath() {
        return this.healthCheckPath;
    }

    /**
     * Set the healthCheckPath property: [HTTP/HTTPS health checks] The destination for health checks on the targets.
     * [HTTP1 or HTTP2 protocol version] The ping path. The default is /. [GRPC protocol version] The path of a custom
     * health check method with the format /package.service/method. The default is /AWS.ALB/healthcheck.
     * 
     * @param healthCheckPath the healthCheckPath value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withHealthCheckPath(String healthCheckPath) {
        this.healthCheckPath = healthCheckPath;
        return this;
    }

    /**
     * Get the healthCheckPort property: The port the load balancer uses when performing health checks on targets.
     * 
     * @return the healthCheckPort value.
     */
    public String healthCheckPort() {
        return this.healthCheckPort;
    }

    /**
     * Set the healthCheckPort property: The port the load balancer uses when performing health checks on targets.
     * 
     * @param healthCheckPort the healthCheckPort value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withHealthCheckPort(String healthCheckPort) {
        this.healthCheckPort = healthCheckPort;
        return this;
    }

    /**
     * Get the healthCheckProtocol property: The protocol the load balancer uses when performing health checks on
     * targets.
     * 
     * @return the healthCheckProtocol value.
     */
    public String healthCheckProtocol() {
        return this.healthCheckProtocol;
    }

    /**
     * Set the healthCheckProtocol property: The protocol the load balancer uses when performing health checks on
     * targets.
     * 
     * @param healthCheckProtocol the healthCheckProtocol value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withHealthCheckProtocol(String healthCheckProtocol) {
        this.healthCheckProtocol = healthCheckProtocol;
        return this;
    }

    /**
     * Get the healthCheckTimeoutSeconds property: The amount of time, in seconds, during which no response from a
     * target means a failed health check.
     * 
     * @return the healthCheckTimeoutSeconds value.
     */
    public Integer healthCheckTimeoutSeconds() {
        return this.healthCheckTimeoutSeconds;
    }

    /**
     * Set the healthCheckTimeoutSeconds property: The amount of time, in seconds, during which no response from a
     * target means a failed health check.
     * 
     * @param healthCheckTimeoutSeconds the healthCheckTimeoutSeconds value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties
        withHealthCheckTimeoutSeconds(Integer healthCheckTimeoutSeconds) {
        this.healthCheckTimeoutSeconds = healthCheckTimeoutSeconds;
        return this;
    }

    /**
     * Get the healthyThresholdCount property: The number of consecutive health checks successes required before
     * considering an unhealthy target healthy.
     * 
     * @return the healthyThresholdCount value.
     */
    public Integer healthyThresholdCount() {
        return this.healthyThresholdCount;
    }

    /**
     * Set the healthyThresholdCount property: The number of consecutive health checks successes required before
     * considering an unhealthy target healthy.
     * 
     * @param healthyThresholdCount the healthyThresholdCount value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withHealthyThresholdCount(Integer healthyThresholdCount) {
        this.healthyThresholdCount = healthyThresholdCount;
        return this;
    }

    /**
     * Get the ipAddressType property: The type of IP address used for this target group. The possible values are ipv4
     * and ipv6.
     * 
     * @return the ipAddressType value.
     */
    public String ipAddressType() {
        return this.ipAddressType;
    }

    /**
     * Set the ipAddressType property: The type of IP address used for this target group. The possible values are ipv4
     * and ipv6.
     * 
     * @param ipAddressType the ipAddressType value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withIpAddressType(String ipAddressType) {
        this.ipAddressType = ipAddressType;
        return this;
    }

    /**
     * Get the loadBalancerArns property: The Amazon Resource Names (ARNs) of the load balancers that route traffic to
     * this target group.
     * 
     * @return the loadBalancerArns value.
     */
    public List<String> loadBalancerArns() {
        return this.loadBalancerArns;
    }

    /**
     * Set the loadBalancerArns property: The Amazon Resource Names (ARNs) of the load balancers that route traffic to
     * this target group.
     * 
     * @param loadBalancerArns the loadBalancerArns value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withLoadBalancerArns(List<String> loadBalancerArns) {
        this.loadBalancerArns = loadBalancerArns;
        return this;
    }

    /**
     * Get the matcher property: [HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful
     * response from a target.
     * 
     * @return the matcher value.
     */
    public Matcher matcher() {
        return this.matcher;
    }

    /**
     * Set the matcher property: [HTTP/HTTPS health checks] The HTTP or gRPC codes to use when checking for a successful
     * response from a target.
     * 
     * @param matcher the matcher value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withMatcher(Matcher matcher) {
        this.matcher = matcher;
        return this;
    }

    /**
     * Get the name property: The name of the target group.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Set the name property: The name of the target group.
     * 
     * @param name the name value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get the port property: The port on which the targets receive traffic. This port is used unless you specify a port
     * override when registering the target. If the target is a Lambda function, this parameter does not apply. If the
     * protocol is GENEVE, the supported port is 6081.
     * 
     * @return the port value.
     */
    public Integer port() {
        return this.port;
    }

    /**
     * Set the port property: The port on which the targets receive traffic. This port is used unless you specify a port
     * override when registering the target. If the target is a Lambda function, this parameter does not apply. If the
     * protocol is GENEVE, the supported port is 6081.
     * 
     * @param port the port value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withPort(Integer port) {
        this.port = port;
        return this;
    }

    /**
     * Get the protocol property: The protocol to use for routing traffic to the targets.
     * 
     * @return the protocol value.
     */
    public String protocol() {
        return this.protocol;
    }

    /**
     * Set the protocol property: The protocol to use for routing traffic to the targets.
     * 
     * @param protocol the protocol value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withProtocol(String protocol) {
        this.protocol = protocol;
        return this;
    }

    /**
     * Get the protocolVersion property: [HTTP/HTTPS protocol] The protocol version. The possible values are GRPC,
     * HTTP1, and HTTP2.
     * 
     * @return the protocolVersion value.
     */
    public String protocolVersion() {
        return this.protocolVersion;
    }

    /**
     * Set the protocolVersion property: [HTTP/HTTPS protocol] The protocol version. The possible values are GRPC,
     * HTTP1, and HTTP2.
     * 
     * @param protocolVersion the protocolVersion value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withProtocolVersion(String protocolVersion) {
        this.protocolVersion = protocolVersion;
        return this;
    }

    /**
     * Get the tags property: The tags.
     * 
     * @return the tags value.
     */
    public List<TagAutoGenerated30> tags() {
        return this.tags;
    }

    /**
     * Set the tags property: The tags.
     * 
     * @param tags the tags value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withTags(List<TagAutoGenerated30> tags) {
        this.tags = tags;
        return this;
    }

    /**
     * Get the targetGroupArn property: The ARN of the Target Group.
     * 
     * @return the targetGroupArn value.
     */
    public String targetGroupArn() {
        return this.targetGroupArn;
    }

    /**
     * Set the targetGroupArn property: The ARN of the Target Group.
     * 
     * @param targetGroupArn the targetGroupArn value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withTargetGroupArn(String targetGroupArn) {
        this.targetGroupArn = targetGroupArn;
        return this;
    }

    /**
     * Get the targetGroupAttributes property: The attributes.
     * 
     * @return the targetGroupAttributes value.
     */
    public List<TargetGroupAttribute> targetGroupAttributes() {
        return this.targetGroupAttributes;
    }

    /**
     * Set the targetGroupAttributes property: The attributes.
     * 
     * @param targetGroupAttributes the targetGroupAttributes value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties
        withTargetGroupAttributes(List<TargetGroupAttribute> targetGroupAttributes) {
        this.targetGroupAttributes = targetGroupAttributes;
        return this;
    }

    /**
     * Get the targetGroupFullName property: The full name of the target group.
     * 
     * @return the targetGroupFullName value.
     */
    public String targetGroupFullName() {
        return this.targetGroupFullName;
    }

    /**
     * Set the targetGroupFullName property: The full name of the target group.
     * 
     * @param targetGroupFullName the targetGroupFullName value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withTargetGroupFullName(String targetGroupFullName) {
        this.targetGroupFullName = targetGroupFullName;
        return this;
    }

    /**
     * Get the targetGroupName property: The name of the target group.
     * 
     * @return the targetGroupName value.
     */
    public String targetGroupName() {
        return this.targetGroupName;
    }

    /**
     * Set the targetGroupName property: The name of the target group.
     * 
     * @param targetGroupName the targetGroupName value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withTargetGroupName(String targetGroupName) {
        this.targetGroupName = targetGroupName;
        return this;
    }

    /**
     * Get the targetType property: The type of target that you must specify when registering targets with this target
     * group. You can't specify targets for a target group using more than one target type.
     * 
     * @return the targetType value.
     */
    public String targetType() {
        return this.targetType;
    }

    /**
     * Set the targetType property: The type of target that you must specify when registering targets with this target
     * group. You can't specify targets for a target group using more than one target type.
     * 
     * @param targetType the targetType value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withTargetType(String targetType) {
        this.targetType = targetType;
        return this;
    }

    /**
     * Get the targets property: The targets.
     * 
     * @return the targets value.
     */
    public List<TargetDescription> targets() {
        return this.targets;
    }

    /**
     * Set the targets property: The targets.
     * 
     * @param targets the targets value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withTargets(List<TargetDescription> targets) {
        this.targets = targets;
        return this;
    }

    /**
     * Get the unhealthyThresholdCount property: The number of consecutive health check failures required before
     * considering a target unhealthy.
     * 
     * @return the unhealthyThresholdCount value.
     */
    public Integer unhealthyThresholdCount() {
        return this.unhealthyThresholdCount;
    }

    /**
     * Set the unhealthyThresholdCount property: The number of consecutive health check failures required before
     * considering a target unhealthy.
     * 
     * @param unhealthyThresholdCount the unhealthyThresholdCount value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withUnhealthyThresholdCount(Integer unhealthyThresholdCount) {
        this.unhealthyThresholdCount = unhealthyThresholdCount;
        return this;
    }

    /**
     * Get the vpcId property: The identifier of the virtual private cloud (VPC). If the target is a Lambda function,
     * this parameter does not apply.
     * 
     * @return the vpcId value.
     */
    public String vpcId() {
        return this.vpcId;
    }

    /**
     * Set the vpcId property: The identifier of the virtual private cloud (VPC). If the target is a Lambda function,
     * this parameter does not apply.
     * 
     * @param vpcId the vpcId value to set.
     * @return the AwsElasticLoadBalancingV2TargetGroupProperties object itself.
     */
    public AwsElasticLoadBalancingV2TargetGroupProperties withVpcId(String vpcId) {
        this.vpcId = vpcId;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (matcher() != null) {
            matcher().validate();
        }
        if (tags() != null) {
            tags().forEach(e -> e.validate());
        }
        if (targetGroupAttributes() != null) {
            targetGroupAttributes().forEach(e -> e.validate());
        }
        if (targets() != null) {
            targets().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeBooleanField("healthCheckEnabled", this.healthCheckEnabled);
        jsonWriter.writeNumberField("healthCheckIntervalSeconds", this.healthCheckIntervalSeconds);
        jsonWriter.writeStringField("healthCheckPath", this.healthCheckPath);
        jsonWriter.writeStringField("healthCheckPort", this.healthCheckPort);
        jsonWriter.writeStringField("healthCheckProtocol", this.healthCheckProtocol);
        jsonWriter.writeNumberField("healthCheckTimeoutSeconds", this.healthCheckTimeoutSeconds);
        jsonWriter.writeNumberField("healthyThresholdCount", this.healthyThresholdCount);
        jsonWriter.writeStringField("ipAddressType", this.ipAddressType);
        jsonWriter.writeArrayField("loadBalancerArns", this.loadBalancerArns,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("matcher", this.matcher);
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeNumberField("port", this.port);
        jsonWriter.writeStringField("protocol", this.protocol);
        jsonWriter.writeStringField("protocolVersion", this.protocolVersion);
        jsonWriter.writeArrayField("tags", this.tags, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("targetGroupArn", this.targetGroupArn);
        jsonWriter.writeArrayField("targetGroupAttributes", this.targetGroupAttributes,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("targetGroupFullName", this.targetGroupFullName);
        jsonWriter.writeStringField("targetGroupName", this.targetGroupName);
        jsonWriter.writeStringField("targetType", this.targetType);
        jsonWriter.writeArrayField("targets", this.targets, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeNumberField("unhealthyThresholdCount", this.unhealthyThresholdCount);
        jsonWriter.writeStringField("vpcId", this.vpcId);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of AwsElasticLoadBalancingV2TargetGroupProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of AwsElasticLoadBalancingV2TargetGroupProperties if the JsonReader was pointing to an
     * instance of it, or null if it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the AwsElasticLoadBalancingV2TargetGroupProperties.
     */
    public static AwsElasticLoadBalancingV2TargetGroupProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            AwsElasticLoadBalancingV2TargetGroupProperties deserializedAwsElasticLoadBalancingV2TargetGroupProperties
                = new AwsElasticLoadBalancingV2TargetGroupProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("healthCheckEnabled".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.healthCheckEnabled
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("healthCheckIntervalSeconds".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.healthCheckIntervalSeconds
                        = reader.getNullable(JsonReader::getInt);
                } else if ("healthCheckPath".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.healthCheckPath = reader.getString();
                } else if ("healthCheckPort".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.healthCheckPort = reader.getString();
                } else if ("healthCheckProtocol".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.healthCheckProtocol = reader.getString();
                } else if ("healthCheckTimeoutSeconds".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.healthCheckTimeoutSeconds
                        = reader.getNullable(JsonReader::getInt);
                } else if ("healthyThresholdCount".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.healthyThresholdCount
                        = reader.getNullable(JsonReader::getInt);
                } else if ("ipAddressType".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.ipAddressType = reader.getString();
                } else if ("loadBalancerArns".equals(fieldName)) {
                    List<String> loadBalancerArns = reader.readArray(reader1 -> reader1.getString());
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.loadBalancerArns = loadBalancerArns;
                } else if ("matcher".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.matcher = Matcher.fromJson(reader);
                } else if ("name".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.name = reader.getString();
                } else if ("port".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.port
                        = reader.getNullable(JsonReader::getInt);
                } else if ("protocol".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.protocol = reader.getString();
                } else if ("protocolVersion".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.protocolVersion = reader.getString();
                } else if ("tags".equals(fieldName)) {
                    List<TagAutoGenerated30> tags = reader.readArray(reader1 -> TagAutoGenerated30.fromJson(reader1));
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.tags = tags;
                } else if ("targetGroupArn".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.targetGroupArn = reader.getString();
                } else if ("targetGroupAttributes".equals(fieldName)) {
                    List<TargetGroupAttribute> targetGroupAttributes
                        = reader.readArray(reader1 -> TargetGroupAttribute.fromJson(reader1));
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.targetGroupAttributes
                        = targetGroupAttributes;
                } else if ("targetGroupFullName".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.targetGroupFullName = reader.getString();
                } else if ("targetGroupName".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.targetGroupName = reader.getString();
                } else if ("targetType".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.targetType = reader.getString();
                } else if ("targets".equals(fieldName)) {
                    List<TargetDescription> targets = reader.readArray(reader1 -> TargetDescription.fromJson(reader1));
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.targets = targets;
                } else if ("unhealthyThresholdCount".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.unhealthyThresholdCount
                        = reader.getNullable(JsonReader::getInt);
                } else if ("vpcId".equals(fieldName)) {
                    deserializedAwsElasticLoadBalancingV2TargetGroupProperties.vpcId = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedAwsElasticLoadBalancingV2TargetGroupProperties;
        });
    }
}
