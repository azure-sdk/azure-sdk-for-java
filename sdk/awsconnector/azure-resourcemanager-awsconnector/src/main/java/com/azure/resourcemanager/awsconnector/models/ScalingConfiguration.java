// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Definition of ScalingConfiguration.
 */
@Fluent
public final class ScalingConfiguration implements JsonSerializable<ScalingConfiguration> {
    /*
     * A value that indicates whether to allow or disallow automatic pause for an Aurora DB cluster in serverless DB
     * engine mode. A DB cluster can be paused only when it's idle (it has no connections).
     */
    private Boolean autoPause;

    /*
     * The maximum capacity for an Aurora DB cluster in serverless DB engine mode.For Aurora MySQL, valid capacity
     * values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32,
     * 64, 192, and 384.The maximum capacity must be greater than or equal to the minimum capacity.
     */
    private Integer maxCapacity;

    /*
     * The minimum capacity for an Aurora DB cluster in serverless DB engine mode.For Aurora MySQL, valid capacity
     * values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.For Aurora PostgreSQL, valid capacity values are 2, 4, 8, 16, 32,
     * 64, 192, and 384.The minimum capacity must be less than or equal to the maximum capacity.
     */
    private Integer minCapacity;

    /*
     * The amount of time, in seconds, that Aurora Serverless v1 tries to find a scaling point to perform seamless
     * scaling before enforcing the timeout action.The default is 300.
     */
    private Integer secondsBeforeTimeout;

    /*
     * The time, in seconds, before an Aurora DB cluster in serverless mode is paused.
     */
    private Integer secondsUntilAutoPause;

    /*
     * The action to take when the timeout is reached, either ForceApplyCapacityChange or
     * RollbackCapacityChange.ForceApplyCapacityChange sets the capacity to the specified value as soon as
     * possible.RollbackCapacityChange, the default, ignores the capacity change if a scaling point isn't found in the
     * timeout period.For more information, see Autoscaling for Aurora Serverless v1 in the Amazon Aurora User Guide.
     */
    private String timeoutAction;

    /**
     * Creates an instance of ScalingConfiguration class.
     */
    public ScalingConfiguration() {
    }

    /**
     * Get the autoPause property: A value that indicates whether to allow or disallow automatic pause for an Aurora DB
     * cluster in serverless DB engine mode. A DB cluster can be paused only when it's idle (it has no connections).
     * 
     * @return the autoPause value.
     */
    public Boolean autoPause() {
        return this.autoPause;
    }

    /**
     * Set the autoPause property: A value that indicates whether to allow or disallow automatic pause for an Aurora DB
     * cluster in serverless DB engine mode. A DB cluster can be paused only when it's idle (it has no connections).
     * 
     * @param autoPause the autoPause value to set.
     * @return the ScalingConfiguration object itself.
     */
    public ScalingConfiguration withAutoPause(Boolean autoPause) {
        this.autoPause = autoPause;
        return this;
    }

    /**
     * Get the maxCapacity property: The maximum capacity for an Aurora DB cluster in serverless DB engine mode.For
     * Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.For Aurora PostgreSQL, valid
     * capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.The maximum capacity must be greater than or equal to the
     * minimum capacity.
     * 
     * @return the maxCapacity value.
     */
    public Integer maxCapacity() {
        return this.maxCapacity;
    }

    /**
     * Set the maxCapacity property: The maximum capacity for an Aurora DB cluster in serverless DB engine mode.For
     * Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.For Aurora PostgreSQL, valid
     * capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.The maximum capacity must be greater than or equal to the
     * minimum capacity.
     * 
     * @param maxCapacity the maxCapacity value to set.
     * @return the ScalingConfiguration object itself.
     */
    public ScalingConfiguration withMaxCapacity(Integer maxCapacity) {
        this.maxCapacity = maxCapacity;
        return this;
    }

    /**
     * Get the minCapacity property: The minimum capacity for an Aurora DB cluster in serverless DB engine mode.For
     * Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.For Aurora PostgreSQL, valid
     * capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.The minimum capacity must be less than or equal to the
     * maximum capacity.
     * 
     * @return the minCapacity value.
     */
    public Integer minCapacity() {
        return this.minCapacity;
    }

    /**
     * Set the minCapacity property: The minimum capacity for an Aurora DB cluster in serverless DB engine mode.For
     * Aurora MySQL, valid capacity values are 1, 2, 4, 8, 16, 32, 64, 128, and 256.For Aurora PostgreSQL, valid
     * capacity values are 2, 4, 8, 16, 32, 64, 192, and 384.The minimum capacity must be less than or equal to the
     * maximum capacity.
     * 
     * @param minCapacity the minCapacity value to set.
     * @return the ScalingConfiguration object itself.
     */
    public ScalingConfiguration withMinCapacity(Integer minCapacity) {
        this.minCapacity = minCapacity;
        return this;
    }

    /**
     * Get the secondsBeforeTimeout property: The amount of time, in seconds, that Aurora Serverless v1 tries to find a
     * scaling point to perform seamless scaling before enforcing the timeout action.The default is 300.
     * 
     * @return the secondsBeforeTimeout value.
     */
    public Integer secondsBeforeTimeout() {
        return this.secondsBeforeTimeout;
    }

    /**
     * Set the secondsBeforeTimeout property: The amount of time, in seconds, that Aurora Serverless v1 tries to find a
     * scaling point to perform seamless scaling before enforcing the timeout action.The default is 300.
     * 
     * @param secondsBeforeTimeout the secondsBeforeTimeout value to set.
     * @return the ScalingConfiguration object itself.
     */
    public ScalingConfiguration withSecondsBeforeTimeout(Integer secondsBeforeTimeout) {
        this.secondsBeforeTimeout = secondsBeforeTimeout;
        return this;
    }

    /**
     * Get the secondsUntilAutoPause property: The time, in seconds, before an Aurora DB cluster in serverless mode is
     * paused.
     * 
     * @return the secondsUntilAutoPause value.
     */
    public Integer secondsUntilAutoPause() {
        return this.secondsUntilAutoPause;
    }

    /**
     * Set the secondsUntilAutoPause property: The time, in seconds, before an Aurora DB cluster in serverless mode is
     * paused.
     * 
     * @param secondsUntilAutoPause the secondsUntilAutoPause value to set.
     * @return the ScalingConfiguration object itself.
     */
    public ScalingConfiguration withSecondsUntilAutoPause(Integer secondsUntilAutoPause) {
        this.secondsUntilAutoPause = secondsUntilAutoPause;
        return this;
    }

    /**
     * Get the timeoutAction property: The action to take when the timeout is reached, either ForceApplyCapacityChange
     * or RollbackCapacityChange.ForceApplyCapacityChange sets the capacity to the specified value as soon as
     * possible.RollbackCapacityChange, the default, ignores the capacity change if a scaling point isn't found in the
     * timeout period.For more information, see Autoscaling for Aurora Serverless v1 in the Amazon Aurora User Guide.
     * 
     * @return the timeoutAction value.
     */
    public String timeoutAction() {
        return this.timeoutAction;
    }

    /**
     * Set the timeoutAction property: The action to take when the timeout is reached, either ForceApplyCapacityChange
     * or RollbackCapacityChange.ForceApplyCapacityChange sets the capacity to the specified value as soon as
     * possible.RollbackCapacityChange, the default, ignores the capacity change if a scaling point isn't found in the
     * timeout period.For more information, see Autoscaling for Aurora Serverless v1 in the Amazon Aurora User Guide.
     * 
     * @param timeoutAction the timeoutAction value to set.
     * @return the ScalingConfiguration object itself.
     */
    public ScalingConfiguration withTimeoutAction(String timeoutAction) {
        this.timeoutAction = timeoutAction;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeBooleanField("autoPause", this.autoPause);
        jsonWriter.writeNumberField("maxCapacity", this.maxCapacity);
        jsonWriter.writeNumberField("minCapacity", this.minCapacity);
        jsonWriter.writeNumberField("secondsBeforeTimeout", this.secondsBeforeTimeout);
        jsonWriter.writeNumberField("secondsUntilAutoPause", this.secondsUntilAutoPause);
        jsonWriter.writeStringField("timeoutAction", this.timeoutAction);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ScalingConfiguration from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ScalingConfiguration if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the ScalingConfiguration.
     */
    public static ScalingConfiguration fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ScalingConfiguration deserializedScalingConfiguration = new ScalingConfiguration();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("autoPause".equals(fieldName)) {
                    deserializedScalingConfiguration.autoPause = reader.getNullable(JsonReader::getBoolean);
                } else if ("maxCapacity".equals(fieldName)) {
                    deserializedScalingConfiguration.maxCapacity = reader.getNullable(JsonReader::getInt);
                } else if ("minCapacity".equals(fieldName)) {
                    deserializedScalingConfiguration.minCapacity = reader.getNullable(JsonReader::getInt);
                } else if ("secondsBeforeTimeout".equals(fieldName)) {
                    deserializedScalingConfiguration.secondsBeforeTimeout = reader.getNullable(JsonReader::getInt);
                } else if ("secondsUntilAutoPause".equals(fieldName)) {
                    deserializedScalingConfiguration.secondsUntilAutoPause = reader.getNullable(JsonReader::getInt);
                } else if ("timeoutAction".equals(fieldName)) {
                    deserializedScalingConfiguration.timeoutAction = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedScalingConfiguration;
        });
    }
}
