// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * Definition of Webhook.
 */
@Fluent
public final class Webhook implements JsonSerializable<Webhook> {
    /*
     * <p>A regular expression used to determine which repository branches are built when a webhook is triggered. If the
     * name of a branch matches the regular expression, then it is built. If <code>branchFilter</code> is empty, then
     * all branches are built.</p> <note> <p>It is recommended that you use <code>filterGroups</code> instead of
     * <code>branchFilter</code>. </p> </note>
     */
    private String branchFilter;

    /*
     * <p>Specifies the type of build this webhook will trigger.</p>
     */
    private WebhookBuildTypeEnumValue buildType;

    /*
     * <p>An array of arrays of <code>WebhookFilter</code> objects used to determine which webhooks are triggered. At
     * least one <code>WebhookFilter</code> in the array must specify <code>EVENT</code> as its <code>type</code>. </p>
     * <p>For a build to be triggered, at least one filter group in the <code>filterGroups</code> array must pass. For a
     * filter group to pass, each of its filters must pass. </p>
     */
    private List<FilterGroup> filterGroups;

    /*
     * <p>A timestamp that indicates the last time a repository's secret token was modified. </p>
     */
    private OffsetDateTime lastModifiedSecret;

    /*
     * <p>The CodeBuild endpoint where webhook events are sent.</p>
     */
    private String payloadUrl;

    /*
     * <p>The secret token of the associated repository. </p> <note> <p>A Bitbucket webhook does not support
     * <code>secret</code>. </p> </note>
     */
    private String secret;

    /*
     * <p>The URL to the webhook.</p>
     */
    private String url;

    /**
     * Creates an instance of Webhook class.
     */
    public Webhook() {
    }

    /**
     * Get the branchFilter property: &lt;p&gt;A regular expression used to determine which repository branches are
     * built when a webhook is triggered. If the name of a branch matches the regular expression, then it is built. If
     * &lt;code&gt;branchFilter&lt;/code&gt; is empty, then all branches are built.&lt;/p&gt; &lt;note&gt; &lt;p&gt;It
     * is recommended that you use &lt;code&gt;filterGroups&lt;/code&gt; instead of
     * &lt;code&gt;branchFilter&lt;/code&gt;. &lt;/p&gt; &lt;/note&gt;.
     * 
     * @return the branchFilter value.
     */
    public String branchFilter() {
        return this.branchFilter;
    }

    /**
     * Set the branchFilter property: &lt;p&gt;A regular expression used to determine which repository branches are
     * built when a webhook is triggered. If the name of a branch matches the regular expression, then it is built. If
     * &lt;code&gt;branchFilter&lt;/code&gt; is empty, then all branches are built.&lt;/p&gt; &lt;note&gt; &lt;p&gt;It
     * is recommended that you use &lt;code&gt;filterGroups&lt;/code&gt; instead of
     * &lt;code&gt;branchFilter&lt;/code&gt;. &lt;/p&gt; &lt;/note&gt;.
     * 
     * @param branchFilter the branchFilter value to set.
     * @return the Webhook object itself.
     */
    public Webhook withBranchFilter(String branchFilter) {
        this.branchFilter = branchFilter;
        return this;
    }

    /**
     * Get the buildType property: &lt;p&gt;Specifies the type of build this webhook will trigger.&lt;/p&gt;.
     * 
     * @return the buildType value.
     */
    public WebhookBuildTypeEnumValue buildType() {
        return this.buildType;
    }

    /**
     * Set the buildType property: &lt;p&gt;Specifies the type of build this webhook will trigger.&lt;/p&gt;.
     * 
     * @param buildType the buildType value to set.
     * @return the Webhook object itself.
     */
    public Webhook withBuildType(WebhookBuildTypeEnumValue buildType) {
        this.buildType = buildType;
        return this;
    }

    /**
     * Get the filterGroups property: &lt;p&gt;An array of arrays of &lt;code&gt;WebhookFilter&lt;/code&gt; objects used
     * to determine which webhooks are triggered. At least one &lt;code&gt;WebhookFilter&lt;/code&gt; in the array must
     * specify &lt;code&gt;EVENT&lt;/code&gt; as its &lt;code&gt;type&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;For a build to
     * be triggered, at least one filter group in the &lt;code&gt;filterGroups&lt;/code&gt; array must pass. For a
     * filter group to pass, each of its filters must pass. &lt;/p&gt;.
     * 
     * @return the filterGroups value.
     */
    public List<FilterGroup> filterGroups() {
        return this.filterGroups;
    }

    /**
     * Set the filterGroups property: &lt;p&gt;An array of arrays of &lt;code&gt;WebhookFilter&lt;/code&gt; objects used
     * to determine which webhooks are triggered. At least one &lt;code&gt;WebhookFilter&lt;/code&gt; in the array must
     * specify &lt;code&gt;EVENT&lt;/code&gt; as its &lt;code&gt;type&lt;/code&gt;. &lt;/p&gt; &lt;p&gt;For a build to
     * be triggered, at least one filter group in the &lt;code&gt;filterGroups&lt;/code&gt; array must pass. For a
     * filter group to pass, each of its filters must pass. &lt;/p&gt;.
     * 
     * @param filterGroups the filterGroups value to set.
     * @return the Webhook object itself.
     */
    public Webhook withFilterGroups(List<FilterGroup> filterGroups) {
        this.filterGroups = filterGroups;
        return this;
    }

    /**
     * Get the lastModifiedSecret property: &lt;p&gt;A timestamp that indicates the last time a repository's secret
     * token was modified. &lt;/p&gt;.
     * 
     * @return the lastModifiedSecret value.
     */
    public OffsetDateTime lastModifiedSecret() {
        return this.lastModifiedSecret;
    }

    /**
     * Set the lastModifiedSecret property: &lt;p&gt;A timestamp that indicates the last time a repository's secret
     * token was modified. &lt;/p&gt;.
     * 
     * @param lastModifiedSecret the lastModifiedSecret value to set.
     * @return the Webhook object itself.
     */
    public Webhook withLastModifiedSecret(OffsetDateTime lastModifiedSecret) {
        this.lastModifiedSecret = lastModifiedSecret;
        return this;
    }

    /**
     * Get the payloadUrl property: &lt;p&gt;The CodeBuild endpoint where webhook events are sent.&lt;/p&gt;.
     * 
     * @return the payloadUrl value.
     */
    public String payloadUrl() {
        return this.payloadUrl;
    }

    /**
     * Set the payloadUrl property: &lt;p&gt;The CodeBuild endpoint where webhook events are sent.&lt;/p&gt;.
     * 
     * @param payloadUrl the payloadUrl value to set.
     * @return the Webhook object itself.
     */
    public Webhook withPayloadUrl(String payloadUrl) {
        this.payloadUrl = payloadUrl;
        return this;
    }

    /**
     * Get the secret property: &lt;p&gt;The secret token of the associated repository. &lt;/p&gt; &lt;note&gt;
     * &lt;p&gt;A Bitbucket webhook does not support &lt;code&gt;secret&lt;/code&gt;. &lt;/p&gt; &lt;/note&gt;.
     * 
     * @return the secret value.
     */
    public String secret() {
        return this.secret;
    }

    /**
     * Set the secret property: &lt;p&gt;The secret token of the associated repository. &lt;/p&gt; &lt;note&gt;
     * &lt;p&gt;A Bitbucket webhook does not support &lt;code&gt;secret&lt;/code&gt;. &lt;/p&gt; &lt;/note&gt;.
     * 
     * @param secret the secret value to set.
     * @return the Webhook object itself.
     */
    public Webhook withSecret(String secret) {
        this.secret = secret;
        return this;
    }

    /**
     * Get the url property: &lt;p&gt;The URL to the webhook.&lt;/p&gt;.
     * 
     * @return the url value.
     */
    public String url() {
        return this.url;
    }

    /**
     * Set the url property: &lt;p&gt;The URL to the webhook.&lt;/p&gt;.
     * 
     * @param url the url value to set.
     * @return the Webhook object itself.
     */
    public Webhook withUrl(String url) {
        this.url = url;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (buildType() != null) {
            buildType().validate();
        }
        if (filterGroups() != null) {
            filterGroups().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("branchFilter", this.branchFilter);
        jsonWriter.writeJsonField("buildType", this.buildType);
        jsonWriter.writeArrayField("filterGroups", this.filterGroups, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("lastModifiedSecret",
            this.lastModifiedSecret == null
                ? null
                : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.lastModifiedSecret));
        jsonWriter.writeStringField("payloadUrl", this.payloadUrl);
        jsonWriter.writeStringField("secret", this.secret);
        jsonWriter.writeStringField("url", this.url);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of Webhook from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of Webhook if the JsonReader was pointing to an instance of it, or null if it was pointing to
     * JSON null.
     * @throws IOException If an error occurs while reading the Webhook.
     */
    public static Webhook fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            Webhook deserializedWebhook = new Webhook();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("branchFilter".equals(fieldName)) {
                    deserializedWebhook.branchFilter = reader.getString();
                } else if ("buildType".equals(fieldName)) {
                    deserializedWebhook.buildType = WebhookBuildTypeEnumValue.fromJson(reader);
                } else if ("filterGroups".equals(fieldName)) {
                    List<FilterGroup> filterGroups = reader.readArray(reader1 -> FilterGroup.fromJson(reader1));
                    deserializedWebhook.filterGroups = filterGroups;
                } else if ("lastModifiedSecret".equals(fieldName)) {
                    deserializedWebhook.lastModifiedSecret = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("payloadUrl".equals(fieldName)) {
                    deserializedWebhook.payloadUrl = reader.getString();
                } else if ("secret".equals(fieldName)) {
                    deserializedWebhook.secret = reader.getString();
                } else if ("url".equals(fieldName)) {
                    deserializedWebhook.url = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedWebhook;
        });
    }
}
