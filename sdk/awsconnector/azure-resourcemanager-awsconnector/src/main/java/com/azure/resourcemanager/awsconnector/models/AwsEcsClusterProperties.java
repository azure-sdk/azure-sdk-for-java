// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Definition of awsEcsCluster.
 */
@Fluent
public final class AwsEcsClusterProperties implements JsonSerializable<AwsEcsClusterProperties> {
    /*
     * Property arn
     */
    private String arn;

    /*
     * The short name of one or more capacity providers to associate with the cluster. A capacity provider must be
     * associated with a cluster before it can be included as part of the default capacity provider strategy of the
     * cluster or used in a capacity provider strategy when calling the
     * [CreateService](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html) or
     * [RunTask](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) actions. If specifying a
     * capacity provider that uses an Auto Scaling group, the capacity provider must be created but not associated with
     * another cluster. New Auto Scaling group capacity providers can be created with the
     * [CreateCapacityProvider](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateCapacityProvider.
     * html) API operation. To use a FARGATElong capacity provider, specify either the ``FARGATE`` or ``FARGATE_SPOT``
     * capacity providers. The FARGATElong capacity providers are available to all accounts and only need to be
     * associated with a cluster to be used. The
     * [PutCapacityProvider](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutCapacityProvider.html) API
     * operation is used to update the list of available capacity providers for a cluster after the cluster is created.
     */
    private List<String> capacityProviders;

    /*
     * A user-generated string that you use to identify your cluster. If you don't specify a name, CFNlong generates a
     * unique physical ID for the name.
     */
    private String clusterName;

    /*
     * The settings to use when creating a cluster. This parameter is used to turn on CloudWatch Container Insights for
     * a cluster.
     */
    private List<ClusterSettings> clusterSettings;

    /*
     * The execute command configuration for the cluster. The execute command configuration for the cluster.
     */
    private ClusterConfiguration configuration;

    /*
     * The default capacity provider strategy for the cluster. When services or tasks are run in the cluster with no
     * launch type or capacity provider strategy specified, the default capacity provider strategy is used.
     */
    private List<CapacityProviderStrategyItem> defaultCapacityProviderStrategy;

    /*
     * Use this parameter to set a default Service Connect namespace. After you set a default Service Connect namespace,
     * any new services with Service Connect turned on that are created in the cluster are added as client services in
     * the namespace. This setting only applies to new services that set the ``enabled`` parameter to ``true`` in the
     * ``ServiceConnectConfiguration``. You can set the namespace of each service individually in the
     * ``ServiceConnectConfiguration`` to override this default parameter. Tasks that run in a namespace can use short
     * names to connect to services in the namespace. Tasks can connect to services across all of the clusters in the
     * namespace. Tasks connect through a managed proxy container that collects logs and metrics for increased
     * visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For more
     * information, see [Service
     * Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic
     * Container Service Developer Guide*. Use this parameter to set a default Service Connect namespace. After you set
     * a default Service Connect namespace, any new services with Service Connect turned on that are created in the
     * cluster are added as client services in the namespace. This setting only applies to new services that set the
     * ``enabled`` parameter to ``true`` in the ``ServiceConnectConfiguration``. You can set the namespace of each
     * service individually in the ``ServiceConnectConfiguration`` to override this default parameter. Tasks that run in
     * a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all
     * of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics
     * for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For
     * more information, see [Service
     * Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic
     * Container Service Developer Guide*.
     */
    private ServiceConnectDefaults serviceConnectDefaults;

    /*
     * The metadata that you apply to the cluster to help you categorize and organize them. Each tag consists of a key
     * and an optional value. You define both. The following basic restrictions apply to tags: + Maximum number of tags
     * per resource - 50 + For each resource, each tag key must be unique, and each tag key can have only one value. +
     * Maximum key length - 128 Unicode characters in UTF-8 + Maximum value length - 256 Unicode characters in UTF-8 +
     * If your tagging schema is used across multiple services and resources, remember that other services may have
     * restrictions on allowed characters. Generally allowed characters are: letters, numbers, and spaces representable
     * in UTF-8, and the following characters: + - = . _ : / @. + Tag keys and values are case-sensitive. + Do not use
     * ``aws:``, ``AWS:``, or any upper or lowercase combination of such as a prefix for either keys or values as it is
     * reserved for AWS use. You cannot edit or delete tag keys or values with this prefix. Tags with this prefix do not
     * count against your tags per resource limit.
     */
    private List<TagAutoGenerated25> tags;

    /**
     * Creates an instance of AwsEcsClusterProperties class.
     */
    public AwsEcsClusterProperties() {
    }

    /**
     * Get the arn property: Property arn.
     * 
     * @return the arn value.
     */
    public String arn() {
        return this.arn;
    }

    /**
     * Set the arn property: Property arn.
     * 
     * @param arn the arn value to set.
     * @return the AwsEcsClusterProperties object itself.
     */
    public AwsEcsClusterProperties withArn(String arn) {
        this.arn = arn;
        return this;
    }

    /**
     * Get the capacityProviders property: The short name of one or more capacity providers to associate with the
     * cluster. A capacity provider must be associated with a cluster before it can be included as part of the default
     * capacity provider strategy of the cluster or used in a capacity provider strategy when calling the
     * [CreateService](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html) or
     * [RunTask](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) actions. If specifying a
     * capacity provider that uses an Auto Scaling group, the capacity provider must be created but not associated with
     * another cluster. New Auto Scaling group capacity providers can be created with the
     * [CreateCapacityProvider](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateCapacityProvider.html)
     * API operation. To use a FARGATElong capacity provider, specify either the ``FARGATE`` or ``FARGATE_SPOT``
     * capacity providers. The FARGATElong capacity providers are available to all accounts and only need to be
     * associated with a cluster to be used. The
     * [PutCapacityProvider](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutCapacityProvider.html) API
     * operation is used to update the list of available capacity providers for a cluster after the cluster is created.
     * 
     * @return the capacityProviders value.
     */
    public List<String> capacityProviders() {
        return this.capacityProviders;
    }

    /**
     * Set the capacityProviders property: The short name of one or more capacity providers to associate with the
     * cluster. A capacity provider must be associated with a cluster before it can be included as part of the default
     * capacity provider strategy of the cluster or used in a capacity provider strategy when calling the
     * [CreateService](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateService.html) or
     * [RunTask](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RunTask.html) actions. If specifying a
     * capacity provider that uses an Auto Scaling group, the capacity provider must be created but not associated with
     * another cluster. New Auto Scaling group capacity providers can be created with the
     * [CreateCapacityProvider](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_CreateCapacityProvider.html)
     * API operation. To use a FARGATElong capacity provider, specify either the ``FARGATE`` or ``FARGATE_SPOT``
     * capacity providers. The FARGATElong capacity providers are available to all accounts and only need to be
     * associated with a cluster to be used. The
     * [PutCapacityProvider](https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_PutCapacityProvider.html) API
     * operation is used to update the list of available capacity providers for a cluster after the cluster is created.
     * 
     * @param capacityProviders the capacityProviders value to set.
     * @return the AwsEcsClusterProperties object itself.
     */
    public AwsEcsClusterProperties withCapacityProviders(List<String> capacityProviders) {
        this.capacityProviders = capacityProviders;
        return this;
    }

    /**
     * Get the clusterName property: A user-generated string that you use to identify your cluster. If you don't specify
     * a name, CFNlong generates a unique physical ID for the name.
     * 
     * @return the clusterName value.
     */
    public String clusterName() {
        return this.clusterName;
    }

    /**
     * Set the clusterName property: A user-generated string that you use to identify your cluster. If you don't specify
     * a name, CFNlong generates a unique physical ID for the name.
     * 
     * @param clusterName the clusterName value to set.
     * @return the AwsEcsClusterProperties object itself.
     */
    public AwsEcsClusterProperties withClusterName(String clusterName) {
        this.clusterName = clusterName;
        return this;
    }

    /**
     * Get the clusterSettings property: The settings to use when creating a cluster. This parameter is used to turn on
     * CloudWatch Container Insights for a cluster.
     * 
     * @return the clusterSettings value.
     */
    public List<ClusterSettings> clusterSettings() {
        return this.clusterSettings;
    }

    /**
     * Set the clusterSettings property: The settings to use when creating a cluster. This parameter is used to turn on
     * CloudWatch Container Insights for a cluster.
     * 
     * @param clusterSettings the clusterSettings value to set.
     * @return the AwsEcsClusterProperties object itself.
     */
    public AwsEcsClusterProperties withClusterSettings(List<ClusterSettings> clusterSettings) {
        this.clusterSettings = clusterSettings;
        return this;
    }

    /**
     * Get the configuration property: The execute command configuration for the cluster. The execute command
     * configuration for the cluster.
     * 
     * @return the configuration value.
     */
    public ClusterConfiguration configuration() {
        return this.configuration;
    }

    /**
     * Set the configuration property: The execute command configuration for the cluster. The execute command
     * configuration for the cluster.
     * 
     * @param configuration the configuration value to set.
     * @return the AwsEcsClusterProperties object itself.
     */
    public AwsEcsClusterProperties withConfiguration(ClusterConfiguration configuration) {
        this.configuration = configuration;
        return this;
    }

    /**
     * Get the defaultCapacityProviderStrategy property: The default capacity provider strategy for the cluster. When
     * services or tasks are run in the cluster with no launch type or capacity provider strategy specified, the default
     * capacity provider strategy is used.
     * 
     * @return the defaultCapacityProviderStrategy value.
     */
    public List<CapacityProviderStrategyItem> defaultCapacityProviderStrategy() {
        return this.defaultCapacityProviderStrategy;
    }

    /**
     * Set the defaultCapacityProviderStrategy property: The default capacity provider strategy for the cluster. When
     * services or tasks are run in the cluster with no launch type or capacity provider strategy specified, the default
     * capacity provider strategy is used.
     * 
     * @param defaultCapacityProviderStrategy the defaultCapacityProviderStrategy value to set.
     * @return the AwsEcsClusterProperties object itself.
     */
    public AwsEcsClusterProperties
        withDefaultCapacityProviderStrategy(List<CapacityProviderStrategyItem> defaultCapacityProviderStrategy) {
        this.defaultCapacityProviderStrategy = defaultCapacityProviderStrategy;
        return this;
    }

    /**
     * Get the serviceConnectDefaults property: Use this parameter to set a default Service Connect namespace. After you
     * set a default Service Connect namespace, any new services with Service Connect turned on that are created in the
     * cluster are added as client services in the namespace. This setting only applies to new services that set the
     * ``enabled`` parameter to ``true`` in the ``ServiceConnectConfiguration``. You can set the namespace of each
     * service individually in the ``ServiceConnectConfiguration`` to override this default parameter. Tasks that run in
     * a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all
     * of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics
     * for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For
     * more information, see [Service
     * Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic
     * Container Service Developer Guide*. Use this parameter to set a default Service Connect namespace. After you set
     * a default Service Connect namespace, any new services with Service Connect turned on that are created in the
     * cluster are added as client services in the namespace. This setting only applies to new services that set the
     * ``enabled`` parameter to ``true`` in the ``ServiceConnectConfiguration``. You can set the namespace of each
     * service individually in the ``ServiceConnectConfiguration`` to override this default parameter. Tasks that run in
     * a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all
     * of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics
     * for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For
     * more information, see [Service
     * Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic
     * Container Service Developer Guide*.
     * 
     * @return the serviceConnectDefaults value.
     */
    public ServiceConnectDefaults serviceConnectDefaults() {
        return this.serviceConnectDefaults;
    }

    /**
     * Set the serviceConnectDefaults property: Use this parameter to set a default Service Connect namespace. After you
     * set a default Service Connect namespace, any new services with Service Connect turned on that are created in the
     * cluster are added as client services in the namespace. This setting only applies to new services that set the
     * ``enabled`` parameter to ``true`` in the ``ServiceConnectConfiguration``. You can set the namespace of each
     * service individually in the ``ServiceConnectConfiguration`` to override this default parameter. Tasks that run in
     * a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all
     * of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics
     * for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For
     * more information, see [Service
     * Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic
     * Container Service Developer Guide*. Use this parameter to set a default Service Connect namespace. After you set
     * a default Service Connect namespace, any new services with Service Connect turned on that are created in the
     * cluster are added as client services in the namespace. This setting only applies to new services that set the
     * ``enabled`` parameter to ``true`` in the ``ServiceConnectConfiguration``. You can set the namespace of each
     * service individually in the ``ServiceConnectConfiguration`` to override this default parameter. Tasks that run in
     * a namespace can use short names to connect to services in the namespace. Tasks can connect to services across all
     * of the clusters in the namespace. Tasks connect through a managed proxy container that collects logs and metrics
     * for increased visibility. Only the tasks that Amazon ECS services create are supported with Service Connect. For
     * more information, see [Service
     * Connect](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/service-connect.html) in the *Amazon Elastic
     * Container Service Developer Guide*.
     * 
     * @param serviceConnectDefaults the serviceConnectDefaults value to set.
     * @return the AwsEcsClusterProperties object itself.
     */
    public AwsEcsClusterProperties withServiceConnectDefaults(ServiceConnectDefaults serviceConnectDefaults) {
        this.serviceConnectDefaults = serviceConnectDefaults;
        return this;
    }

    /**
     * Get the tags property: The metadata that you apply to the cluster to help you categorize and organize them. Each
     * tag consists of a key and an optional value. You define both. The following basic restrictions apply to tags: +
     * Maximum number of tags per resource - 50 + For each resource, each tag key must be unique, and each tag key can
     * have only one value. + Maximum key length - 128 Unicode characters in UTF-8 + Maximum value length - 256 Unicode
     * characters in UTF-8 + If your tagging schema is used across multiple services and resources, remember that other
     * services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and
     * spaces representable in UTF-8, and the following characters: + - = . _ : / &#064;. + Tag keys and values are
     * case-sensitive. + Do not use ``aws:``, ``AWS:``, or any upper or lowercase combination of such as a prefix for
     * either keys or values as it is reserved for AWS use. You cannot edit or delete tag keys or values with this
     * prefix. Tags with this prefix do not count against your tags per resource limit.
     * 
     * @return the tags value.
     */
    public List<TagAutoGenerated25> tags() {
        return this.tags;
    }

    /**
     * Set the tags property: The metadata that you apply to the cluster to help you categorize and organize them. Each
     * tag consists of a key and an optional value. You define both. The following basic restrictions apply to tags: +
     * Maximum number of tags per resource - 50 + For each resource, each tag key must be unique, and each tag key can
     * have only one value. + Maximum key length - 128 Unicode characters in UTF-8 + Maximum value length - 256 Unicode
     * characters in UTF-8 + If your tagging schema is used across multiple services and resources, remember that other
     * services may have restrictions on allowed characters. Generally allowed characters are: letters, numbers, and
     * spaces representable in UTF-8, and the following characters: + - = . _ : / &#064;. + Tag keys and values are
     * case-sensitive. + Do not use ``aws:``, ``AWS:``, or any upper or lowercase combination of such as a prefix for
     * either keys or values as it is reserved for AWS use. You cannot edit or delete tag keys or values with this
     * prefix. Tags with this prefix do not count against your tags per resource limit.
     * 
     * @param tags the tags value to set.
     * @return the AwsEcsClusterProperties object itself.
     */
    public AwsEcsClusterProperties withTags(List<TagAutoGenerated25> tags) {
        this.tags = tags;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (clusterSettings() != null) {
            clusterSettings().forEach(e -> e.validate());
        }
        if (configuration() != null) {
            configuration().validate();
        }
        if (defaultCapacityProviderStrategy() != null) {
            defaultCapacityProviderStrategy().forEach(e -> e.validate());
        }
        if (serviceConnectDefaults() != null) {
            serviceConnectDefaults().validate();
        }
        if (tags() != null) {
            tags().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("arn", this.arn);
        jsonWriter.writeArrayField("capacityProviders", this.capacityProviders,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("clusterName", this.clusterName);
        jsonWriter.writeArrayField("clusterSettings", this.clusterSettings,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeJsonField("configuration", this.configuration);
        jsonWriter.writeArrayField("defaultCapacityProviderStrategy", this.defaultCapacityProviderStrategy,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeJsonField("serviceConnectDefaults", this.serviceConnectDefaults);
        jsonWriter.writeArrayField("tags", this.tags, (writer, element) -> writer.writeJson(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of AwsEcsClusterProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of AwsEcsClusterProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IOException If an error occurs while reading the AwsEcsClusterProperties.
     */
    public static AwsEcsClusterProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            AwsEcsClusterProperties deserializedAwsEcsClusterProperties = new AwsEcsClusterProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("arn".equals(fieldName)) {
                    deserializedAwsEcsClusterProperties.arn = reader.getString();
                } else if ("capacityProviders".equals(fieldName)) {
                    List<String> capacityProviders = reader.readArray(reader1 -> reader1.getString());
                    deserializedAwsEcsClusterProperties.capacityProviders = capacityProviders;
                } else if ("clusterName".equals(fieldName)) {
                    deserializedAwsEcsClusterProperties.clusterName = reader.getString();
                } else if ("clusterSettings".equals(fieldName)) {
                    List<ClusterSettings> clusterSettings
                        = reader.readArray(reader1 -> ClusterSettings.fromJson(reader1));
                    deserializedAwsEcsClusterProperties.clusterSettings = clusterSettings;
                } else if ("configuration".equals(fieldName)) {
                    deserializedAwsEcsClusterProperties.configuration = ClusterConfiguration.fromJson(reader);
                } else if ("defaultCapacityProviderStrategy".equals(fieldName)) {
                    List<CapacityProviderStrategyItem> defaultCapacityProviderStrategy
                        = reader.readArray(reader1 -> CapacityProviderStrategyItem.fromJson(reader1));
                    deserializedAwsEcsClusterProperties.defaultCapacityProviderStrategy
                        = defaultCapacityProviderStrategy;
                } else if ("serviceConnectDefaults".equals(fieldName)) {
                    deserializedAwsEcsClusterProperties.serviceConnectDefaults
                        = ServiceConnectDefaults.fromJson(reader);
                } else if ("tags".equals(fieldName)) {
                    List<TagAutoGenerated25> tags = reader.readArray(reader1 -> TagAutoGenerated25.fromJson(reader1));
                    deserializedAwsEcsClusterProperties.tags = tags;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedAwsEcsClusterProperties;
        });
    }
}
