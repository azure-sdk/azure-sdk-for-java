// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Definition of VpcConfigResponse.
 */
@Fluent
public final class VpcConfigResponse implements JsonSerializable<VpcConfigResponse> {
    /*
     * <p>The cluster security group that was created by Amazon EKS for the cluster. Managed node groups use this
     * security group for control-plane-to-data-plane communication.</p>
     */
    private String clusterSecurityGroupId;

    /*
     * <p>This parameter indicates whether the Amazon EKS private API server endpoint is enabled. If the Amazon EKS
     * private API server endpoint is enabled, Kubernetes API requests that originate from within your cluster's VPC use
     * the private VPC endpoint instead of traversing the internet. If this value is disabled and you have nodes or
     * Fargate pods in the cluster, then ensure that <code>publicAccessCidrs</code> includes the necessary CIDR blocks
     * for communication with the nodes or Fargate pods. For more information, see <a
     * href='https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html'>Amazon EKS cluster endpoint access
     * control</a> in the <i> <i>Amazon EKS User Guide</i> </i>.</p>
     */
    private Boolean endpointPrivateAccess;

    /*
     * <p>Whether the public API server endpoint is enabled.</p>
     */
    private Boolean endpointPublicAccess;

    /*
     * <p>The CIDR blocks that are allowed access to your cluster's public Kubernetes API server endpoint.</p>
     */
    private List<String> publicAccessCidrs;

    /*
     * <p>The security groups associated with the cross-account elastic network interfaces that are used to allow
     * communication between your nodes and the Kubernetes control plane.</p>
     */
    private List<String> securityGroupIds;

    /*
     * <p>The subnets associated with your cluster.</p>
     */
    private List<String> subnetIds;

    /*
     * <p>The VPC associated with your cluster.</p>
     */
    private String vpcId;

    /**
     * Creates an instance of VpcConfigResponse class.
     */
    public VpcConfigResponse() {
    }

    /**
     * Get the clusterSecurityGroupId property: &lt;p&gt;The cluster security group that was created by Amazon EKS for
     * the cluster. Managed node groups use this security group for control-plane-to-data-plane
     * communication.&lt;/p&gt;.
     * 
     * @return the clusterSecurityGroupId value.
     */
    public String clusterSecurityGroupId() {
        return this.clusterSecurityGroupId;
    }

    /**
     * Set the clusterSecurityGroupId property: &lt;p&gt;The cluster security group that was created by Amazon EKS for
     * the cluster. Managed node groups use this security group for control-plane-to-data-plane
     * communication.&lt;/p&gt;.
     * 
     * @param clusterSecurityGroupId the clusterSecurityGroupId value to set.
     * @return the VpcConfigResponse object itself.
     */
    public VpcConfigResponse withClusterSecurityGroupId(String clusterSecurityGroupId) {
        this.clusterSecurityGroupId = clusterSecurityGroupId;
        return this;
    }

    /**
     * Get the endpointPrivateAccess property: &lt;p&gt;This parameter indicates whether the Amazon EKS private API
     * server endpoint is enabled. If the Amazon EKS private API server endpoint is enabled, Kubernetes API requests
     * that originate from within your cluster's VPC use the private VPC endpoint instead of traversing the internet. If
     * this value is disabled and you have nodes or Fargate pods in the cluster, then ensure that
     * &lt;code&gt;publicAccessCidrs&lt;/code&gt; includes the necessary CIDR blocks for communication with the nodes or
     * Fargate pods. For more information, see &lt;a
     * href='https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html'&gt;Amazon EKS cluster endpoint
     * access control&lt;/a&gt; in the &lt;i&gt; &lt;i&gt;Amazon EKS User Guide&lt;/i&gt; &lt;/i&gt;.&lt;/p&gt;.
     * 
     * @return the endpointPrivateAccess value.
     */
    public Boolean endpointPrivateAccess() {
        return this.endpointPrivateAccess;
    }

    /**
     * Set the endpointPrivateAccess property: &lt;p&gt;This parameter indicates whether the Amazon EKS private API
     * server endpoint is enabled. If the Amazon EKS private API server endpoint is enabled, Kubernetes API requests
     * that originate from within your cluster's VPC use the private VPC endpoint instead of traversing the internet. If
     * this value is disabled and you have nodes or Fargate pods in the cluster, then ensure that
     * &lt;code&gt;publicAccessCidrs&lt;/code&gt; includes the necessary CIDR blocks for communication with the nodes or
     * Fargate pods. For more information, see &lt;a
     * href='https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html'&gt;Amazon EKS cluster endpoint
     * access control&lt;/a&gt; in the &lt;i&gt; &lt;i&gt;Amazon EKS User Guide&lt;/i&gt; &lt;/i&gt;.&lt;/p&gt;.
     * 
     * @param endpointPrivateAccess the endpointPrivateAccess value to set.
     * @return the VpcConfigResponse object itself.
     */
    public VpcConfigResponse withEndpointPrivateAccess(Boolean endpointPrivateAccess) {
        this.endpointPrivateAccess = endpointPrivateAccess;
        return this;
    }

    /**
     * Get the endpointPublicAccess property: &lt;p&gt;Whether the public API server endpoint is enabled.&lt;/p&gt;.
     * 
     * @return the endpointPublicAccess value.
     */
    public Boolean endpointPublicAccess() {
        return this.endpointPublicAccess;
    }

    /**
     * Set the endpointPublicAccess property: &lt;p&gt;Whether the public API server endpoint is enabled.&lt;/p&gt;.
     * 
     * @param endpointPublicAccess the endpointPublicAccess value to set.
     * @return the VpcConfigResponse object itself.
     */
    public VpcConfigResponse withEndpointPublicAccess(Boolean endpointPublicAccess) {
        this.endpointPublicAccess = endpointPublicAccess;
        return this;
    }

    /**
     * Get the publicAccessCidrs property: &lt;p&gt;The CIDR blocks that are allowed access to your cluster's public
     * Kubernetes API server endpoint.&lt;/p&gt;.
     * 
     * @return the publicAccessCidrs value.
     */
    public List<String> publicAccessCidrs() {
        return this.publicAccessCidrs;
    }

    /**
     * Set the publicAccessCidrs property: &lt;p&gt;The CIDR blocks that are allowed access to your cluster's public
     * Kubernetes API server endpoint.&lt;/p&gt;.
     * 
     * @param publicAccessCidrs the publicAccessCidrs value to set.
     * @return the VpcConfigResponse object itself.
     */
    public VpcConfigResponse withPublicAccessCidrs(List<String> publicAccessCidrs) {
        this.publicAccessCidrs = publicAccessCidrs;
        return this;
    }

    /**
     * Get the securityGroupIds property: &lt;p&gt;The security groups associated with the cross-account elastic network
     * interfaces that are used to allow communication between your nodes and the Kubernetes control plane.&lt;/p&gt;.
     * 
     * @return the securityGroupIds value.
     */
    public List<String> securityGroupIds() {
        return this.securityGroupIds;
    }

    /**
     * Set the securityGroupIds property: &lt;p&gt;The security groups associated with the cross-account elastic network
     * interfaces that are used to allow communication between your nodes and the Kubernetes control plane.&lt;/p&gt;.
     * 
     * @param securityGroupIds the securityGroupIds value to set.
     * @return the VpcConfigResponse object itself.
     */
    public VpcConfigResponse withSecurityGroupIds(List<String> securityGroupIds) {
        this.securityGroupIds = securityGroupIds;
        return this;
    }

    /**
     * Get the subnetIds property: &lt;p&gt;The subnets associated with your cluster.&lt;/p&gt;.
     * 
     * @return the subnetIds value.
     */
    public List<String> subnetIds() {
        return this.subnetIds;
    }

    /**
     * Set the subnetIds property: &lt;p&gt;The subnets associated with your cluster.&lt;/p&gt;.
     * 
     * @param subnetIds the subnetIds value to set.
     * @return the VpcConfigResponse object itself.
     */
    public VpcConfigResponse withSubnetIds(List<String> subnetIds) {
        this.subnetIds = subnetIds;
        return this;
    }

    /**
     * Get the vpcId property: &lt;p&gt;The VPC associated with your cluster.&lt;/p&gt;.
     * 
     * @return the vpcId value.
     */
    public String vpcId() {
        return this.vpcId;
    }

    /**
     * Set the vpcId property: &lt;p&gt;The VPC associated with your cluster.&lt;/p&gt;.
     * 
     * @param vpcId the vpcId value to set.
     * @return the VpcConfigResponse object itself.
     */
    public VpcConfigResponse withVpcId(String vpcId) {
        this.vpcId = vpcId;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("clusterSecurityGroupId", this.clusterSecurityGroupId);
        jsonWriter.writeBooleanField("endpointPrivateAccess", this.endpointPrivateAccess);
        jsonWriter.writeBooleanField("endpointPublicAccess", this.endpointPublicAccess);
        jsonWriter.writeArrayField("publicAccessCidrs", this.publicAccessCidrs,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("securityGroupIds", this.securityGroupIds,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("subnetIds", this.subnetIds, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("vpcId", this.vpcId);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of VpcConfigResponse from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of VpcConfigResponse if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the VpcConfigResponse.
     */
    public static VpcConfigResponse fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            VpcConfigResponse deserializedVpcConfigResponse = new VpcConfigResponse();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("clusterSecurityGroupId".equals(fieldName)) {
                    deserializedVpcConfigResponse.clusterSecurityGroupId = reader.getString();
                } else if ("endpointPrivateAccess".equals(fieldName)) {
                    deserializedVpcConfigResponse.endpointPrivateAccess = reader.getNullable(JsonReader::getBoolean);
                } else if ("endpointPublicAccess".equals(fieldName)) {
                    deserializedVpcConfigResponse.endpointPublicAccess = reader.getNullable(JsonReader::getBoolean);
                } else if ("publicAccessCidrs".equals(fieldName)) {
                    List<String> publicAccessCidrs = reader.readArray(reader1 -> reader1.getString());
                    deserializedVpcConfigResponse.publicAccessCidrs = publicAccessCidrs;
                } else if ("securityGroupIds".equals(fieldName)) {
                    List<String> securityGroupIds = reader.readArray(reader1 -> reader1.getString());
                    deserializedVpcConfigResponse.securityGroupIds = securityGroupIds;
                } else if ("subnetIds".equals(fieldName)) {
                    List<String> subnetIds = reader.readArray(reader1 -> reader1.getString());
                    deserializedVpcConfigResponse.subnetIds = subnetIds;
                } else if ("vpcId".equals(fieldName)) {
                    deserializedVpcConfigResponse.vpcId = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedVpcConfigResponse;
        });
    }
}
