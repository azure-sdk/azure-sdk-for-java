// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.awsconnector.models;

import com.azure.core.annotation.Fluent;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Definition of ProjectArtifacts.
 */
@Fluent
public final class ProjectArtifacts implements JsonSerializable<ProjectArtifacts> {
    /*
     * <p> An identifier for this artifact definition. </p>
     */
    private String artifactIdentifier;

    /*
     * Property bucketOwnerAccess
     */
    private BucketOwnerAccessEnumValue bucketOwnerAccess;

    /*
     * <p> Set to true if you do not want your output artifacts encrypted. This option is valid only if your artifacts
     * type is Amazon S3. If this is set with another artifacts type, an invalidInputException is thrown. </p>
     */
    private Boolean encryptionDisabled;

    /*
     * <p>Information about the build output artifact location:</p> <ul> <li> <p>If <code>type</code> is set to
     * <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its
     * build output locations instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to
     * <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li>
     * <li> <p>If <code>type</code> is set to <code>S3</code>, this is the name of the output bucket.</p> </li> </ul>
     */
    private String location;

    /*
     * <p>Along with <code>path</code> and <code>namespaceType</code>, the pattern that CodeBuild uses to name and store
     * the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline
     * ignores this value if specified. This is because CodePipeline manages its build output names instead of
     * CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if
     * specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>,
     * this is the name of the output artifact object. If you set the name to be a forward slash ('/'), the artifact is
     * stored in the root of the output bucket.</p> </li> </ul> <p>For example:</p> <ul> <li> <p> If <code>path</code>
     * is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>BUILD_ID</code>, and
     * <code>name</code> is set to <code>MyArtifact.zip</code>, then the output artifact is stored in
     * <code>MyArtifacts/&lt;build-ID&gt;/MyArtifact.zip</code>. </p> </li> <li> <p> If <code>path</code> is empty,
     * <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set to '<code>/</code>', the
     * output artifact is stored in the root of the output bucket. </p> </li> <li> <p> If <code>path</code> is set to
     * <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>BUILD_ID</code>, and <code>name</code> is
     * set to '<code>/</code>', the output artifact is stored in <code>MyArtifacts/&lt;build-ID&gt;</code>. </p> </li>
     * </ul>
     */
    private String name;

    /*
     * <p>Along with <code>path</code> and <code>name</code>, the pattern that CodeBuild uses to determine the name and
     * location to store the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>,
     * CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead
     * of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored
     * if specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to
     * <code>S3</code>, valid values include:</p> <ul> <li> <p> <code>BUILD_ID</code>: Include the build ID in the
     * location of the build output artifact.</p> </li> <li> <p> <code>NONE</code>: Do not include the build ID. This is
     * the default if <code>namespaceType</code> is not specified.</p> </li> </ul> </li> </ul> <p>For example, if
     * <code>path</code> is set to <code>MyArtifacts</code>, <code>namespaceType</code> is set to <code>BUILD_ID</code>,
     * and <code>name</code> is set to <code>MyArtifact.zip</code>, the output artifact is stored in
     * <code>MyArtifacts/&lt;build-ID&gt;/MyArtifact.zip</code>.</p>
     */
    private ArtifactNamespaceEnumValue namespaceType;

    /*
     * <p> If this flag is set, a name specified in the buildspec file overrides the artifact name. The name specified
     * in a buildspec file is calculated at build time and uses the Shell Command Language. For example, you can append
     * a date and time to your artifact name so that it is always unique. </p>
     */
    private Boolean overrideArtifactName;

    /*
     * <p>The type of build output artifact to create:</p> <ul> <li> <p>If <code>type</code> is set to
     * <code>CODEPIPELINE</code>, CodePipeline ignores this value if specified. This is because CodePipeline manages its
     * build output artifacts instead of CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to
     * <code>NO_ARTIFACTS</code>, this value is ignored if specified, because no build output is produced.</p> </li>
     * <li> <p>If <code>type</code> is set to <code>S3</code>, valid values include:</p> <ul> <li> <p>
     * <code>NONE</code>: CodeBuild creates in the output bucket a folder that contains the build output. This is the
     * default if <code>packaging</code> is not specified.</p> </li> <li> <p> <code>ZIP</code>: CodeBuild creates in the
     * output bucket a ZIP file that contains the build output.</p> </li> </ul> </li> </ul>
     */
    private ArtifactPackagingEnumValue packaging;

    /*
     * <p>Along with <code>namespaceType</code> and <code>name</code>, the pattern that CodeBuild uses to name and store
     * the output artifact:</p> <ul> <li> <p>If <code>type</code> is set to <code>CODEPIPELINE</code>, CodePipeline
     * ignores this value if specified. This is because CodePipeline manages its build output names instead of
     * CodeBuild.</p> </li> <li> <p>If <code>type</code> is set to <code>NO_ARTIFACTS</code>, this value is ignored if
     * specified, because no build output is produced.</p> </li> <li> <p>If <code>type</code> is set to <code>S3</code>,
     * this is the path to the output artifact. If <code>path</code> is not specified, <code>path</code> is not
     * used.</p> </li> </ul> <p>For example, if <code>path</code> is set to <code>MyArtifacts</code>,
     * <code>namespaceType</code> is set to <code>NONE</code>, and <code>name</code> is set to
     * <code>MyArtifact.zip</code>, the output artifact is stored in the output bucket at
     * <code>MyArtifacts/MyArtifact.zip</code>.</p>
     */
    private String path;

    /*
     * <p>The type of build output artifact. Valid values include:</p> <ul> <li> <p> <code>CODEPIPELINE</code>: The
     * build project has build output generated through CodePipeline. </p> <note> <p>The <code>CODEPIPELINE</code> type
     * is not supported for <code>secondaryArtifacts</code>.</p> </note> </li> <li> <p> <code>NO_ARTIFACTS</code>: The
     * build project does not produce any build output.</p> </li> <li> <p> <code>S3</code>: The build project stores
     * build output in Amazon S3.</p> </li> </ul>
     */
    private ArtifactsTypeEnumValue type;

    /**
     * Creates an instance of ProjectArtifacts class.
     */
    public ProjectArtifacts() {
    }

    /**
     * Get the artifactIdentifier property: &lt;p&gt; An identifier for this artifact definition. &lt;/p&gt;.
     * 
     * @return the artifactIdentifier value.
     */
    public String artifactIdentifier() {
        return this.artifactIdentifier;
    }

    /**
     * Set the artifactIdentifier property: &lt;p&gt; An identifier for this artifact definition. &lt;/p&gt;.
     * 
     * @param artifactIdentifier the artifactIdentifier value to set.
     * @return the ProjectArtifacts object itself.
     */
    public ProjectArtifacts withArtifactIdentifier(String artifactIdentifier) {
        this.artifactIdentifier = artifactIdentifier;
        return this;
    }

    /**
     * Get the bucketOwnerAccess property: Property bucketOwnerAccess.
     * 
     * @return the bucketOwnerAccess value.
     */
    public BucketOwnerAccessEnumValue bucketOwnerAccess() {
        return this.bucketOwnerAccess;
    }

    /**
     * Set the bucketOwnerAccess property: Property bucketOwnerAccess.
     * 
     * @param bucketOwnerAccess the bucketOwnerAccess value to set.
     * @return the ProjectArtifacts object itself.
     */
    public ProjectArtifacts withBucketOwnerAccess(BucketOwnerAccessEnumValue bucketOwnerAccess) {
        this.bucketOwnerAccess = bucketOwnerAccess;
        return this;
    }

    /**
     * Get the encryptionDisabled property: &lt;p&gt; Set to true if you do not want your output artifacts encrypted.
     * This option is valid only if your artifacts type is Amazon S3. If this is set with another artifacts type, an
     * invalidInputException is thrown. &lt;/p&gt;.
     * 
     * @return the encryptionDisabled value.
     */
    public Boolean encryptionDisabled() {
        return this.encryptionDisabled;
    }

    /**
     * Set the encryptionDisabled property: &lt;p&gt; Set to true if you do not want your output artifacts encrypted.
     * This option is valid only if your artifacts type is Amazon S3. If this is set with another artifacts type, an
     * invalidInputException is thrown. &lt;/p&gt;.
     * 
     * @param encryptionDisabled the encryptionDisabled value to set.
     * @return the ProjectArtifacts object itself.
     */
    public ProjectArtifacts withEncryptionDisabled(Boolean encryptionDisabled) {
        this.encryptionDisabled = encryptionDisabled;
        return this;
    }

    /**
     * Get the location property: &lt;p&gt;Information about the build output artifact location:&lt;/p&gt; &lt;ul&gt;
     * &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;CODEPIPELINE&lt;/code&gt;,
     * CodePipeline ignores this value if specified. This is because CodePipeline manages its build output locations
     * instead of CodeBuild.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;NO_ARTIFACTS&lt;/code&gt;, this value is ignored if specified, because no build output is
     * produced.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;S3&lt;/code&gt;, this is the name of the output bucket.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @return the location value.
     */
    public String location() {
        return this.location;
    }

    /**
     * Set the location property: &lt;p&gt;Information about the build output artifact location:&lt;/p&gt; &lt;ul&gt;
     * &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;CODEPIPELINE&lt;/code&gt;,
     * CodePipeline ignores this value if specified. This is because CodePipeline manages its build output locations
     * instead of CodeBuild.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;NO_ARTIFACTS&lt;/code&gt;, this value is ignored if specified, because no build output is
     * produced.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;S3&lt;/code&gt;, this is the name of the output bucket.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @param location the location value to set.
     * @return the ProjectArtifacts object itself.
     */
    public ProjectArtifacts withLocation(String location) {
        this.location = location;
        return this;
    }

    /**
     * Get the name property: &lt;p&gt;Along with &lt;code&gt;path&lt;/code&gt; and
     * &lt;code&gt;namespaceType&lt;/code&gt;, the pattern that CodeBuild uses to name and store the output
     * artifact:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;CODEPIPELINE&lt;/code&gt;, CodePipeline ignores this value if specified. This is because CodePipeline
     * manages its build output names instead of CodeBuild.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If
     * &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;NO_ARTIFACTS&lt;/code&gt;, this value is ignored if
     * specified, because no build output is produced.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If
     * &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;S3&lt;/code&gt;, this is the name of the output artifact
     * object. If you set the name to be a forward slash ('/'), the artifact is stored in the root of the output
     * bucket.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For example:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; If
     * &lt;code&gt;path&lt;/code&gt; is set to &lt;code&gt;MyArtifacts&lt;/code&gt;,
     * &lt;code&gt;namespaceType&lt;/code&gt; is set to &lt;code&gt;BUILD_ID&lt;/code&gt;, and
     * &lt;code&gt;name&lt;/code&gt; is set to &lt;code&gt;MyArtifact.zip&lt;/code&gt;, then the output artifact is
     * stored in &lt;code&gt;MyArtifacts/&amp;lt;build-ID&amp;gt;/MyArtifact.zip&lt;/code&gt;. &lt;/p&gt; &lt;/li&gt;
     * &lt;li&gt; &lt;p&gt; If &lt;code&gt;path&lt;/code&gt; is empty, &lt;code&gt;namespaceType&lt;/code&gt; is set to
     * &lt;code&gt;NONE&lt;/code&gt;, and &lt;code&gt;name&lt;/code&gt; is set to '&lt;code&gt;/&lt;/code&gt;', the
     * output artifact is stored in the root of the output bucket. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; If
     * &lt;code&gt;path&lt;/code&gt; is set to &lt;code&gt;MyArtifacts&lt;/code&gt;,
     * &lt;code&gt;namespaceType&lt;/code&gt; is set to &lt;code&gt;BUILD_ID&lt;/code&gt;, and
     * &lt;code&gt;name&lt;/code&gt; is set to '&lt;code&gt;/&lt;/code&gt;', the output artifact is stored in
     * &lt;code&gt;MyArtifacts/&amp;lt;build-ID&amp;gt;&lt;/code&gt;. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @return the name value.
     */
    public String name() {
        return this.name;
    }

    /**
     * Set the name property: &lt;p&gt;Along with &lt;code&gt;path&lt;/code&gt; and
     * &lt;code&gt;namespaceType&lt;/code&gt;, the pattern that CodeBuild uses to name and store the output
     * artifact:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;CODEPIPELINE&lt;/code&gt;, CodePipeline ignores this value if specified. This is because CodePipeline
     * manages its build output names instead of CodeBuild.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If
     * &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;NO_ARTIFACTS&lt;/code&gt;, this value is ignored if
     * specified, because no build output is produced.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If
     * &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;S3&lt;/code&gt;, this is the name of the output artifact
     * object. If you set the name to be a forward slash ('/'), the artifact is stored in the root of the output
     * bucket.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For example:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt; If
     * &lt;code&gt;path&lt;/code&gt; is set to &lt;code&gt;MyArtifacts&lt;/code&gt;,
     * &lt;code&gt;namespaceType&lt;/code&gt; is set to &lt;code&gt;BUILD_ID&lt;/code&gt;, and
     * &lt;code&gt;name&lt;/code&gt; is set to &lt;code&gt;MyArtifact.zip&lt;/code&gt;, then the output artifact is
     * stored in &lt;code&gt;MyArtifacts/&amp;lt;build-ID&amp;gt;/MyArtifact.zip&lt;/code&gt;. &lt;/p&gt; &lt;/li&gt;
     * &lt;li&gt; &lt;p&gt; If &lt;code&gt;path&lt;/code&gt; is empty, &lt;code&gt;namespaceType&lt;/code&gt; is set to
     * &lt;code&gt;NONE&lt;/code&gt;, and &lt;code&gt;name&lt;/code&gt; is set to '&lt;code&gt;/&lt;/code&gt;', the
     * output artifact is stored in the root of the output bucket. &lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; If
     * &lt;code&gt;path&lt;/code&gt; is set to &lt;code&gt;MyArtifacts&lt;/code&gt;,
     * &lt;code&gt;namespaceType&lt;/code&gt; is set to &lt;code&gt;BUILD_ID&lt;/code&gt;, and
     * &lt;code&gt;name&lt;/code&gt; is set to '&lt;code&gt;/&lt;/code&gt;', the output artifact is stored in
     * &lt;code&gt;MyArtifacts/&amp;lt;build-ID&amp;gt;&lt;/code&gt;. &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @param name the name value to set.
     * @return the ProjectArtifacts object itself.
     */
    public ProjectArtifacts withName(String name) {
        this.name = name;
        return this;
    }

    /**
     * Get the namespaceType property: &lt;p&gt;Along with &lt;code&gt;path&lt;/code&gt; and
     * &lt;code&gt;name&lt;/code&gt;, the pattern that CodeBuild uses to determine the name and location to store the
     * output artifact:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;CODEPIPELINE&lt;/code&gt;, CodePipeline ignores this value if specified. This is because CodePipeline
     * manages its build output names instead of CodeBuild.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If
     * &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;NO_ARTIFACTS&lt;/code&gt;, this value is ignored if
     * specified, because no build output is produced.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If
     * &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;S3&lt;/code&gt;, valid values include:&lt;/p&gt; &lt;ul&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;BUILD_ID&lt;/code&gt;: Include the build ID in the location of the build output
     * artifact.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;NONE&lt;/code&gt;: Do not include the build ID.
     * This is the default if &lt;code&gt;namespaceType&lt;/code&gt; is not specified.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For example, if &lt;code&gt;path&lt;/code&gt; is set to
     * &lt;code&gt;MyArtifacts&lt;/code&gt;, &lt;code&gt;namespaceType&lt;/code&gt; is set to
     * &lt;code&gt;BUILD_ID&lt;/code&gt;, and &lt;code&gt;name&lt;/code&gt; is set to
     * &lt;code&gt;MyArtifact.zip&lt;/code&gt;, the output artifact is stored in
     * &lt;code&gt;MyArtifacts/&amp;lt;build-ID&amp;gt;/MyArtifact.zip&lt;/code&gt;.&lt;/p&gt;.
     * 
     * @return the namespaceType value.
     */
    public ArtifactNamespaceEnumValue namespaceType() {
        return this.namespaceType;
    }

    /**
     * Set the namespaceType property: &lt;p&gt;Along with &lt;code&gt;path&lt;/code&gt; and
     * &lt;code&gt;name&lt;/code&gt;, the pattern that CodeBuild uses to determine the name and location to store the
     * output artifact:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;CODEPIPELINE&lt;/code&gt;, CodePipeline ignores this value if specified. This is because CodePipeline
     * manages its build output names instead of CodeBuild.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If
     * &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;NO_ARTIFACTS&lt;/code&gt;, this value is ignored if
     * specified, because no build output is produced.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If
     * &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;S3&lt;/code&gt;, valid values include:&lt;/p&gt; &lt;ul&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;BUILD_ID&lt;/code&gt;: Include the build ID in the location of the build output
     * artifact.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt; &lt;code&gt;NONE&lt;/code&gt;: Do not include the build ID.
     * This is the default if &lt;code&gt;namespaceType&lt;/code&gt; is not specified.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;
     * &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For example, if &lt;code&gt;path&lt;/code&gt; is set to
     * &lt;code&gt;MyArtifacts&lt;/code&gt;, &lt;code&gt;namespaceType&lt;/code&gt; is set to
     * &lt;code&gt;BUILD_ID&lt;/code&gt;, and &lt;code&gt;name&lt;/code&gt; is set to
     * &lt;code&gt;MyArtifact.zip&lt;/code&gt;, the output artifact is stored in
     * &lt;code&gt;MyArtifacts/&amp;lt;build-ID&amp;gt;/MyArtifact.zip&lt;/code&gt;.&lt;/p&gt;.
     * 
     * @param namespaceType the namespaceType value to set.
     * @return the ProjectArtifacts object itself.
     */
    public ProjectArtifacts withNamespaceType(ArtifactNamespaceEnumValue namespaceType) {
        this.namespaceType = namespaceType;
        return this;
    }

    /**
     * Get the overrideArtifactName property: &lt;p&gt; If this flag is set, a name specified in the buildspec file
     * overrides the artifact name. The name specified in a buildspec file is calculated at build time and uses the
     * Shell Command Language. For example, you can append a date and time to your artifact name so that it is always
     * unique. &lt;/p&gt;.
     * 
     * @return the overrideArtifactName value.
     */
    public Boolean overrideArtifactName() {
        return this.overrideArtifactName;
    }

    /**
     * Set the overrideArtifactName property: &lt;p&gt; If this flag is set, a name specified in the buildspec file
     * overrides the artifact name. The name specified in a buildspec file is calculated at build time and uses the
     * Shell Command Language. For example, you can append a date and time to your artifact name so that it is always
     * unique. &lt;/p&gt;.
     * 
     * @param overrideArtifactName the overrideArtifactName value to set.
     * @return the ProjectArtifacts object itself.
     */
    public ProjectArtifacts withOverrideArtifactName(Boolean overrideArtifactName) {
        this.overrideArtifactName = overrideArtifactName;
        return this;
    }

    /**
     * Get the packaging property: &lt;p&gt;The type of build output artifact to create:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;
     * &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;CODEPIPELINE&lt;/code&gt;, CodePipeline ignores
     * this value if specified. This is because CodePipeline manages its build output artifacts instead of
     * CodeBuild.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;NO_ARTIFACTS&lt;/code&gt;, this value is ignored if specified, because no build output is
     * produced.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;S3&lt;/code&gt;, valid values include:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;
     * &lt;code&gt;NONE&lt;/code&gt;: CodeBuild creates in the output bucket a folder that contains the build output.
     * This is the default if &lt;code&gt;packaging&lt;/code&gt; is not specified.&lt;/p&gt; &lt;/li&gt; &lt;li&gt;
     * &lt;p&gt; &lt;code&gt;ZIP&lt;/code&gt;: CodeBuild creates in the output bucket a ZIP file that contains the build
     * output.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @return the packaging value.
     */
    public ArtifactPackagingEnumValue packaging() {
        return this.packaging;
    }

    /**
     * Set the packaging property: &lt;p&gt;The type of build output artifact to create:&lt;/p&gt; &lt;ul&gt; &lt;li&gt;
     * &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;CODEPIPELINE&lt;/code&gt;, CodePipeline ignores
     * this value if specified. This is because CodePipeline manages its build output artifacts instead of
     * CodeBuild.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;NO_ARTIFACTS&lt;/code&gt;, this value is ignored if specified, because no build output is
     * produced.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;S3&lt;/code&gt;, valid values include:&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;
     * &lt;code&gt;NONE&lt;/code&gt;: CodeBuild creates in the output bucket a folder that contains the build output.
     * This is the default if &lt;code&gt;packaging&lt;/code&gt; is not specified.&lt;/p&gt; &lt;/li&gt; &lt;li&gt;
     * &lt;p&gt; &lt;code&gt;ZIP&lt;/code&gt;: CodeBuild creates in the output bucket a ZIP file that contains the build
     * output.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @param packaging the packaging value to set.
     * @return the ProjectArtifacts object itself.
     */
    public ProjectArtifacts withPackaging(ArtifactPackagingEnumValue packaging) {
        this.packaging = packaging;
        return this;
    }

    /**
     * Get the path property: &lt;p&gt;Along with &lt;code&gt;namespaceType&lt;/code&gt; and
     * &lt;code&gt;name&lt;/code&gt;, the pattern that CodeBuild uses to name and store the output artifact:&lt;/p&gt;
     * &lt;ul&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;CODEPIPELINE&lt;/code&gt;,
     * CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead
     * of CodeBuild.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;NO_ARTIFACTS&lt;/code&gt;, this value is ignored if specified, because no build output is
     * produced.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;S3&lt;/code&gt;, this is the path to the output artifact. If &lt;code&gt;path&lt;/code&gt; is not
     * specified, &lt;code&gt;path&lt;/code&gt; is not used.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For example, if
     * &lt;code&gt;path&lt;/code&gt; is set to &lt;code&gt;MyArtifacts&lt;/code&gt;,
     * &lt;code&gt;namespaceType&lt;/code&gt; is set to &lt;code&gt;NONE&lt;/code&gt;, and &lt;code&gt;name&lt;/code&gt;
     * is set to &lt;code&gt;MyArtifact.zip&lt;/code&gt;, the output artifact is stored in the output bucket at
     * &lt;code&gt;MyArtifacts/MyArtifact.zip&lt;/code&gt;.&lt;/p&gt;.
     * 
     * @return the path value.
     */
    public String path() {
        return this.path;
    }

    /**
     * Set the path property: &lt;p&gt;Along with &lt;code&gt;namespaceType&lt;/code&gt; and
     * &lt;code&gt;name&lt;/code&gt;, the pattern that CodeBuild uses to name and store the output artifact:&lt;/p&gt;
     * &lt;ul&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to &lt;code&gt;CODEPIPELINE&lt;/code&gt;,
     * CodePipeline ignores this value if specified. This is because CodePipeline manages its build output names instead
     * of CodeBuild.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;NO_ARTIFACTS&lt;/code&gt;, this value is ignored if specified, because no build output is
     * produced.&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;If &lt;code&gt;type&lt;/code&gt; is set to
     * &lt;code&gt;S3&lt;/code&gt;, this is the path to the output artifact. If &lt;code&gt;path&lt;/code&gt; is not
     * specified, &lt;code&gt;path&lt;/code&gt; is not used.&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;p&gt;For example, if
     * &lt;code&gt;path&lt;/code&gt; is set to &lt;code&gt;MyArtifacts&lt;/code&gt;,
     * &lt;code&gt;namespaceType&lt;/code&gt; is set to &lt;code&gt;NONE&lt;/code&gt;, and &lt;code&gt;name&lt;/code&gt;
     * is set to &lt;code&gt;MyArtifact.zip&lt;/code&gt;, the output artifact is stored in the output bucket at
     * &lt;code&gt;MyArtifacts/MyArtifact.zip&lt;/code&gt;.&lt;/p&gt;.
     * 
     * @param path the path value to set.
     * @return the ProjectArtifacts object itself.
     */
    public ProjectArtifacts withPath(String path) {
        this.path = path;
        return this;
    }

    /**
     * Get the type property: &lt;p&gt;The type of build output artifact. Valid values include:&lt;/p&gt; &lt;ul&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;CODEPIPELINE&lt;/code&gt;: The build project has build output generated through
     * CodePipeline. &lt;/p&gt; &lt;note&gt; &lt;p&gt;The &lt;code&gt;CODEPIPELINE&lt;/code&gt; type is not supported
     * for &lt;code&gt;secondaryArtifacts&lt;/code&gt;.&lt;/p&gt; &lt;/note&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;
     * &lt;code&gt;NO_ARTIFACTS&lt;/code&gt;: The build project does not produce any build output.&lt;/p&gt; &lt;/li&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;S3&lt;/code&gt;: The build project stores build output in Amazon S3.&lt;/p&gt;
     * &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @return the type value.
     */
    public ArtifactsTypeEnumValue type() {
        return this.type;
    }

    /**
     * Set the type property: &lt;p&gt;The type of build output artifact. Valid values include:&lt;/p&gt; &lt;ul&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;CODEPIPELINE&lt;/code&gt;: The build project has build output generated through
     * CodePipeline. &lt;/p&gt; &lt;note&gt; &lt;p&gt;The &lt;code&gt;CODEPIPELINE&lt;/code&gt; type is not supported
     * for &lt;code&gt;secondaryArtifacts&lt;/code&gt;.&lt;/p&gt; &lt;/note&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;
     * &lt;code&gt;NO_ARTIFACTS&lt;/code&gt;: The build project does not produce any build output.&lt;/p&gt; &lt;/li&gt;
     * &lt;li&gt; &lt;p&gt; &lt;code&gt;S3&lt;/code&gt;: The build project stores build output in Amazon S3.&lt;/p&gt;
     * &lt;/li&gt; &lt;/ul&gt;.
     * 
     * @param type the type value to set.
     * @return the ProjectArtifacts object itself.
     */
    public ProjectArtifacts withType(ArtifactsTypeEnumValue type) {
        this.type = type;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (bucketOwnerAccess() != null) {
            bucketOwnerAccess().validate();
        }
        if (namespaceType() != null) {
            namespaceType().validate();
        }
        if (packaging() != null) {
            packaging().validate();
        }
        if (type() != null) {
            type().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("artifactIdentifier", this.artifactIdentifier);
        jsonWriter.writeJsonField("bucketOwnerAccess", this.bucketOwnerAccess);
        jsonWriter.writeBooleanField("encryptionDisabled", this.encryptionDisabled);
        jsonWriter.writeStringField("location", this.location);
        jsonWriter.writeStringField("name", this.name);
        jsonWriter.writeJsonField("namespaceType", this.namespaceType);
        jsonWriter.writeBooleanField("overrideArtifactName", this.overrideArtifactName);
        jsonWriter.writeJsonField("packaging", this.packaging);
        jsonWriter.writeStringField("path", this.path);
        jsonWriter.writeJsonField("type", this.type);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ProjectArtifacts from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ProjectArtifacts if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the ProjectArtifacts.
     */
    public static ProjectArtifacts fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ProjectArtifacts deserializedProjectArtifacts = new ProjectArtifacts();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("artifactIdentifier".equals(fieldName)) {
                    deserializedProjectArtifacts.artifactIdentifier = reader.getString();
                } else if ("bucketOwnerAccess".equals(fieldName)) {
                    deserializedProjectArtifacts.bucketOwnerAccess = BucketOwnerAccessEnumValue.fromJson(reader);
                } else if ("encryptionDisabled".equals(fieldName)) {
                    deserializedProjectArtifacts.encryptionDisabled = reader.getNullable(JsonReader::getBoolean);
                } else if ("location".equals(fieldName)) {
                    deserializedProjectArtifacts.location = reader.getString();
                } else if ("name".equals(fieldName)) {
                    deserializedProjectArtifacts.name = reader.getString();
                } else if ("namespaceType".equals(fieldName)) {
                    deserializedProjectArtifacts.namespaceType = ArtifactNamespaceEnumValue.fromJson(reader);
                } else if ("overrideArtifactName".equals(fieldName)) {
                    deserializedProjectArtifacts.overrideArtifactName = reader.getNullable(JsonReader::getBoolean);
                } else if ("packaging".equals(fieldName)) {
                    deserializedProjectArtifacts.packaging = ArtifactPackagingEnumValue.fromJson(reader);
                } else if ("path".equals(fieldName)) {
                    deserializedProjectArtifacts.path = reader.getString();
                } else if ("type".equals(fieldName)) {
                    deserializedProjectArtifacts.type = ArtifactsTypeEnumValue.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedProjectArtifacts;
        });
    }
}
