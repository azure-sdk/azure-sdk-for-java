// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.hybriddatamanager.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;

/**
 * Encryption Key.
 */
@Fluent
public final class Key implements JsonSerializable<Key> {
    /*
     * Modulus of the encryption key.
     */
    private String keyModulus;

    /*
     * Exponent of the encryption key.
     */
    private String keyExponent;

    /*
     * The maximum byte size that can be encrypted by the key. For a key size larger than the size, break into chunks
     * and encrypt each chunk, append each encrypted chunk with : to mark the end of the chunk.
     */
    private int encryptionChunkSizeInBytes;

    /**
     * Creates an instance of Key class.
     */
    public Key() {
    }

    /**
     * Get the keyModulus property: Modulus of the encryption key.
     * 
     * @return the keyModulus value.
     */
    public String keyModulus() {
        return this.keyModulus;
    }

    /**
     * Set the keyModulus property: Modulus of the encryption key.
     * 
     * @param keyModulus the keyModulus value to set.
     * @return the Key object itself.
     */
    public Key withKeyModulus(String keyModulus) {
        this.keyModulus = keyModulus;
        return this;
    }

    /**
     * Get the keyExponent property: Exponent of the encryption key.
     * 
     * @return the keyExponent value.
     */
    public String keyExponent() {
        return this.keyExponent;
    }

    /**
     * Set the keyExponent property: Exponent of the encryption key.
     * 
     * @param keyExponent the keyExponent value to set.
     * @return the Key object itself.
     */
    public Key withKeyExponent(String keyExponent) {
        this.keyExponent = keyExponent;
        return this;
    }

    /**
     * Get the encryptionChunkSizeInBytes property: The maximum byte size that can be encrypted by the key. For a key
     * size larger than the size, break into chunks and encrypt each chunk, append each encrypted chunk with : to mark
     * the end of the chunk.
     * 
     * @return the encryptionChunkSizeInBytes value.
     */
    public int encryptionChunkSizeInBytes() {
        return this.encryptionChunkSizeInBytes;
    }

    /**
     * Set the encryptionChunkSizeInBytes property: The maximum byte size that can be encrypted by the key. For a key
     * size larger than the size, break into chunks and encrypt each chunk, append each encrypted chunk with : to mark
     * the end of the chunk.
     * 
     * @param encryptionChunkSizeInBytes the encryptionChunkSizeInBytes value to set.
     * @return the Key object itself.
     */
    public Key withEncryptionChunkSizeInBytes(int encryptionChunkSizeInBytes) {
        this.encryptionChunkSizeInBytes = encryptionChunkSizeInBytes;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (keyModulus() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property keyModulus in model Key"));
        }
        if (keyExponent() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property keyExponent in model Key"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(Key.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("keyModulus", this.keyModulus);
        jsonWriter.writeStringField("keyExponent", this.keyExponent);
        jsonWriter.writeIntField("encryptionChunkSizeInBytes", this.encryptionChunkSizeInBytes);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of Key from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of Key if the JsonReader was pointing to an instance of it, or null if it was pointing to
     * JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the Key.
     */
    public static Key fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            Key deserializedKey = new Key();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("keyModulus".equals(fieldName)) {
                    deserializedKey.keyModulus = reader.getString();
                } else if ("keyExponent".equals(fieldName)) {
                    deserializedKey.keyExponent = reader.getString();
                } else if ("encryptionChunkSizeInBytes".equals(fieldName)) {
                    deserializedKey.encryptionChunkSizeInBytes = reader.getInt();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedKey;
        });
    }
}
