// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.messagingconnectors.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;

/**
 * Configuration for ConfluentSourceConnector.
 */
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "connectorType")
@JsonTypeName("ConfluentSource")
@Fluent
public final class ConfluentSourceConnectorProperties extends ConnectorProperties {
    /*
     * bootstrapServers of the Confluent server.
     */
    @JsonProperty(value = "bootstrapServers", required = true)
    private String bootstrapServers;

    /*
     * Topic of the Confluent.
     */
    @JsonProperty(value = "topic", required = true)
    private String topic;

    /*
     * ConsumerGroup of the Confluent.
     */
    @JsonProperty(value = "consumerGroup", required = true)
    private String consumerGroup;

    /*
     * AutoOffsetReset policy of the Confluent consume.
     */
    @JsonProperty(value = "autoOffsetReset", required = true)
    private String autoOffsetReset;

    /*
     * User of the Confluent.
     */
    @JsonProperty(value = "user", required = true)
    private String user;

    /*
     * Password of the Confluent.
     */
    @JsonProperty(value = "password")
    private String password;

    /**
     * Creates an instance of ConfluentSourceConnectorProperties class.
     */
    public ConfluentSourceConnectorProperties() {
    }

    /**
     * Get the bootstrapServers property: bootstrapServers of the Confluent server.
     * 
     * @return the bootstrapServers value.
     */
    public String bootstrapServers() {
        return this.bootstrapServers;
    }

    /**
     * Set the bootstrapServers property: bootstrapServers of the Confluent server.
     * 
     * @param bootstrapServers the bootstrapServers value to set.
     * @return the ConfluentSourceConnectorProperties object itself.
     */
    public ConfluentSourceConnectorProperties withBootstrapServers(String bootstrapServers) {
        this.bootstrapServers = bootstrapServers;
        return this;
    }

    /**
     * Get the topic property: Topic of the Confluent.
     * 
     * @return the topic value.
     */
    public String topic() {
        return this.topic;
    }

    /**
     * Set the topic property: Topic of the Confluent.
     * 
     * @param topic the topic value to set.
     * @return the ConfluentSourceConnectorProperties object itself.
     */
    public ConfluentSourceConnectorProperties withTopic(String topic) {
        this.topic = topic;
        return this;
    }

    /**
     * Get the consumerGroup property: ConsumerGroup of the Confluent.
     * 
     * @return the consumerGroup value.
     */
    public String consumerGroup() {
        return this.consumerGroup;
    }

    /**
     * Set the consumerGroup property: ConsumerGroup of the Confluent.
     * 
     * @param consumerGroup the consumerGroup value to set.
     * @return the ConfluentSourceConnectorProperties object itself.
     */
    public ConfluentSourceConnectorProperties withConsumerGroup(String consumerGroup) {
        this.consumerGroup = consumerGroup;
        return this;
    }

    /**
     * Get the autoOffsetReset property: AutoOffsetReset policy of the Confluent consume.
     * 
     * @return the autoOffsetReset value.
     */
    public String autoOffsetReset() {
        return this.autoOffsetReset;
    }

    /**
     * Set the autoOffsetReset property: AutoOffsetReset policy of the Confluent consume.
     * 
     * @param autoOffsetReset the autoOffsetReset value to set.
     * @return the ConfluentSourceConnectorProperties object itself.
     */
    public ConfluentSourceConnectorProperties withAutoOffsetReset(String autoOffsetReset) {
        this.autoOffsetReset = autoOffsetReset;
        return this;
    }

    /**
     * Get the user property: User of the Confluent.
     * 
     * @return the user value.
     */
    public String user() {
        return this.user;
    }

    /**
     * Set the user property: User of the Confluent.
     * 
     * @param user the user value to set.
     * @return the ConfluentSourceConnectorProperties object itself.
     */
    public ConfluentSourceConnectorProperties withUser(String user) {
        this.user = user;
        return this;
    }

    /**
     * Get the password property: Password of the Confluent.
     * 
     * @return the password value.
     */
    public String password() {
        return this.password;
    }

    /**
     * Set the password property: Password of the Confluent.
     * 
     * @param password the password value to set.
     * @return the ConfluentSourceConnectorProperties object itself.
     */
    public ConfluentSourceConnectorProperties withPassword(String password) {
        this.password = password;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ConfluentSourceConnectorProperties withMaxTasks(int maxTasks) {
        super.withMaxTasks(maxTasks);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ConfluentSourceConnectorProperties withValueConverter(ConverterType valueConverter) {
        super.withValueConverter(valueConverter);
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ConfluentSourceConnectorProperties withEventHubConfig(EventHubConfig eventHubConfig) {
        super.withEventHubConfig(eventHubConfig);
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    @Override
    public void validate() {
        super.validate();
        if (bootstrapServers() == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                "Missing required property bootstrapServers in model ConfluentSourceConnectorProperties"));
        }
        if (topic() == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                "Missing required property topic in model ConfluentSourceConnectorProperties"));
        }
        if (consumerGroup() == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                "Missing required property consumerGroup in model ConfluentSourceConnectorProperties"));
        }
        if (autoOffsetReset() == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                "Missing required property autoOffsetReset in model ConfluentSourceConnectorProperties"));
        }
        if (user() == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                "Missing required property user in model ConfluentSourceConnectorProperties"));
        }
        if (password() == null) {
            throw LOGGER.logExceptionAsError(new IllegalArgumentException(
                "Missing required property password in model ConfluentSourceConnectorProperties"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(ConfluentSourceConnectorProperties.class);
}
