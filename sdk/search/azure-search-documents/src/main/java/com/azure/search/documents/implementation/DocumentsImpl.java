// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.search.documents.implementation;

import com.azure.core.annotation.BodyParam;
import com.azure.core.annotation.ExpectedResponses;
import com.azure.core.annotation.Get;
import com.azure.core.annotation.HeaderParam;
import com.azure.core.annotation.Host;
import com.azure.core.annotation.HostParam;
import com.azure.core.annotation.PathParam;
import com.azure.core.annotation.Post;
import com.azure.core.annotation.QueryParam;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceInterface;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.annotation.UnexpectedResponseExceptionType;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.http.rest.RestProxy;
import com.azure.core.util.BinaryData;
import com.azure.core.util.Context;
import com.azure.core.util.FluxUtil;
import com.azure.search.documents.SearchServiceVersion;
import reactor.core.publisher.Mono;

/**
 * An instance of this class provides access to all the operations defined in Documents.
 */
public final class DocumentsImpl {
    /**
     * The proxy service used to perform REST calls.
     */
    private final DocumentsService service;

    /**
     * The service client containing this operation class.
     */
    private final SearchClientImpl client;

    /**
     * Initializes an instance of DocumentsImpl.
     * 
     * @param client the instance of the service client containing this operation class.
     */
    DocumentsImpl(SearchClientImpl client) {
        this.service
            = RestProxy.create(DocumentsService.class, client.getHttpPipeline(), client.getSerializerAdapter());
        this.client = client;
    }

    /**
     * Gets Service version.
     * 
     * @return the serviceVersion value.
     */
    public SearchServiceVersion getServiceVersion() {
        return client.getServiceVersion();
    }

    /**
     * The interface defining all the services for SearchClientDocuments to be used by the proxy service to perform REST
     * calls.
     */
    @Host("{endpoint}")
    @ServiceInterface(name = "SearchClientDocument")
    public interface DocumentsService {
        @Get("/indexes('{indexName}')/docs/$count")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> count(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("indexName") String indexName,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs/$count")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> countSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("indexName") String indexName,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> searchGet(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("indexName") String indexName,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> searchGetSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("indexName") String indexName,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/indexes('{indexName}')/docs/search.post.search")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> searchPost(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("indexName") String indexName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") BinaryData searchRequest, RequestOptions requestOptions, Context context);

        @Post("/indexes('{indexName}')/docs/search.post.search")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> searchPostSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("indexName") String indexName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") BinaryData searchRequest, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs('{key}')")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> get(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("key") String key,
            @PathParam("indexName") String indexName, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs('{key}')")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> getSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("key") String key,
            @PathParam("indexName") String indexName, @HeaderParam("Accept") String accept,
            RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs/search.suggest")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> suggestGet(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @QueryParam("search") String searchText,
            @QueryParam("suggesterName") String suggesterName, @PathParam("indexName") String indexName,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs/search.suggest")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> suggestGetSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @QueryParam("search") String searchText,
            @QueryParam("suggesterName") String suggesterName, @PathParam("indexName") String indexName,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/indexes('{indexName}')/docs/search.post.suggest")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> suggestPost(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("indexName") String indexName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") BinaryData suggestRequest, RequestOptions requestOptions, Context context);

        @Post("/indexes('{indexName}')/docs/search.post.suggest")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> suggestPostSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("indexName") String indexName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") BinaryData suggestRequest, RequestOptions requestOptions, Context context);

        @Post("/indexes('{indexName}')/docs/search.index")
        @ExpectedResponses({ 200, 207 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> index(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("indexName") String indexName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") BinaryData batch, RequestOptions requestOptions, Context context);

        @Post("/indexes('{indexName}')/docs/search.index")
        @ExpectedResponses({ 200, 207 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> indexSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("indexName") String indexName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") BinaryData batch, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs/search.autocomplete")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> autocompleteGet(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @QueryParam("search") String searchText,
            @QueryParam("suggesterName") String suggesterName, @PathParam("indexName") String indexName,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Get("/indexes('{indexName}')/docs/search.autocomplete")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> autocompleteGetSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @QueryParam("search") String searchText,
            @QueryParam("suggesterName") String suggesterName, @PathParam("indexName") String indexName,
            @HeaderParam("Accept") String accept, RequestOptions requestOptions, Context context);

        @Post("/indexes('{indexName}')/docs/search.post.autocomplete")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Mono<Response<BinaryData>> autocompletePost(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("indexName") String indexName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") BinaryData autocompleteRequest, RequestOptions requestOptions,
            Context context);

        @Post("/indexes('{indexName}')/docs/search.post.autocomplete")
        @ExpectedResponses({ 200 })
        @UnexpectedResponseExceptionType(value = ClientAuthenticationException.class, code = { 401 })
        @UnexpectedResponseExceptionType(value = ResourceNotFoundException.class, code = { 404 })
        @UnexpectedResponseExceptionType(value = ResourceModifiedException.class, code = { 409 })
        @UnexpectedResponseExceptionType(HttpResponseException.class)
        Response<BinaryData> autocompletePostSync(@HostParam("endpoint") String endpoint,
            @QueryParam("api-version") String apiVersion, @PathParam("indexName") String indexName,
            @HeaderParam("Content-Type") String contentType, @HeaderParam("Accept") String accept,
            @BodyParam("application/json") BinaryData autocompleteRequest, RequestOptions requestOptions,
            Context context);
    }

    /**
     * Queries the number of documents in the index.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * int
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a 32-bit integer along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> countWithResponseAsync(String indexName, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.count(this.client.getEndpoint(),
            this.client.getServiceVersion().getVersion(), indexName, accept, requestOptions, context));
    }

    /**
     * Queries the number of documents in the index.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * int
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a 32-bit integer along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> countWithResponse(String indexName, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.countSync(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(), indexName,
            accept, requestOptions, Context.NONE);
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>search</td><td>String</td><td>No</td><td>A full-text search query expression; Use "*" or omit this
     * parameter to match
     * all documents.</td></tr>
     * <tr><td>$count</td><td>Boolean</td><td>No</td><td>A value that specifies whether to fetch the total count of
     * results. Default is
     * false. Setting this value to true may have a performance impact. Note that the
     * count returned is an approximation.</td></tr>
     * <tr><td>facet</td><td>List&lt;String&gt;</td><td>No</td><td>The list of facet expressions to apply to the search
     * query. Each facet
     * expression contains a field name, optionally followed by a comma-separated list
     * of name:value pairs. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>The OData $filter expression to apply to the search
     * query.</td></tr>
     * <tr><td>highlight</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to use for hit
     * highlights. Only searchable fields can
     * be used for hit highlighting. In the form of "," separated string.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with
     * highlightPreTag. Default is &amp;lt;/em&amp;gt;.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with
     * highlightPostTag. Default is &amp;lt;em&amp;gt;.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be
     * covered by a search query in order for the query to be reported as a success.
     * This parameter can be useful for ensuring search availability even for services
     * with only one replica. The default is 100.</td></tr>
     * <tr><td>$orderby</td><td>List&lt;String&gt;</td><td>No</td><td>The list of OData $orderby expressions by which to
     * sort the results. Each
     * expression can be either a field name or a call to either the geo.distance() or
     * the search.score() functions. Each expression can be followed by asc to
     * indicate ascending, and desc to indicate descending. The default is ascending
     * order. Ties will be broken by the match scores of documents. If no OrderBy is
     * specified, the default sort order is descending by document match score. There
     * can be at most 32 $orderby clauses. In the form of "," separated string.</td></tr>
     * <tr><td>queryType</td><td>String</td><td>No</td><td>A value that specifies the syntax of the search query. The
     * default is 'simple'.
     * Use 'full' if your query uses the Lucene query syntax. Allowed values: "simple", "full", "semantic".</td></tr>
     * <tr><td>scoringParameter</td><td>List&lt;String&gt;</td><td>No</td><td>The list of parameter values to be used in
     * scoring functions (for example,
     * referencePointParameter) using the format name-values. For example, if the
     * scoring profile defines a function with a parameter called 'mylocation' the
     * parameter string would be "mylocation--122.2,44.8" (without the quotes). Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>scoringProfile</td><td>String</td><td>No</td><td>The name of a scoring profile to evaluate match scores
     * for matching documents
     * in order to sort the results.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to which to scope the
     * full-text search. When using
     * fielded search (fieldName:searchExpression) in a full Lucene query, the field
     * names of each fielded search expression take precedence over any field names
     * listed in this parameter. In the form of "," separated string.</td></tr>
     * <tr><td>searchMode</td><td>String</td><td>No</td><td>A value that specifies whether any or all of the search
     * terms must be matched
     * in order to count the document as a match. Allowed values: "any", "all".</td></tr>
     * <tr><td>scoringStatistics</td><td>String</td><td>No</td><td>A value that specifies whether we want to calculate
     * scoring statistics (such as
     * document frequency) globally for more consistent scoring, or locally, for lower
     * latency. Allowed values: "local", "global".</td></tr>
     * <tr><td>sessionId</td><td>String</td><td>No</td><td>A value to be used to create a sticky session, which can help
     * to get more
     * consistent results. As long as the same sessionId is used, a best-effort
     * attempt will be made to target the same replica set. Be wary that reusing the
     * same sessionID values repeatedly can interfere with the load balancing of the
     * requests across replicas and adversely affect the performance of the search
     * service. The value used as sessionId cannot start with a '_' character.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>The list of fields to retrieve. If unspecified, all
     * fields marked as
     * retrievable in the schema are included. In the form of "," separated string.</td></tr>
     * <tr><td>$skip</td><td>Integer</td><td>No</td><td>The number of search results to skip. This value cannot be
     * greater than
     * 100,000. If you need to scan documents in sequence, but cannot use $skip due to
     * this limitation, consider using $orderby on a totally-ordered key and $filter
     * with a range query instead.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of search results to retrieve. This can be used in
     * conjunction with
     * $skip to implement client-side paging of search results. If results are
     * truncated due to server-side paging, the response will include a continuation
     * token that can be used to issue another Search request for the next page of
     * results.</td></tr>
     * <tr><td>semanticConfiguration</td><td>String</td><td>No</td><td>The name of the semantic configuration that lists
     * which fields should be used
     * for semantic ranking, captions, highlights, and answers</td></tr>
     * <tr><td>semanticErrorHandling</td><td>String</td><td>No</td><td>Allows the user to choose whether a semantic call
     * should fail completely, or to
     * return partial results (default). Allowed values: "partial", "fail".</td></tr>
     * <tr><td>semanticMaxWaitInMilliseconds</td><td>Integer</td><td>No</td><td>Allows the user to set an upper bound on
     * the amount of time it takes for
     * semantic enrichment to finish processing before the request fails.</td></tr>
     * <tr><td>answers</td><td>String</td><td>No</td><td>This parameter is only valid if the query type is `semantic`.
     * If set, the query
     * returns answers extracted from key passages in the highest ranked documents.
     * The number of answers returned can be configured by appending the pipe
     * character `|` followed by the `count-&lt;number of answers&gt;` option after the
     * answers parameter value, such as `extractive|count-3`. Default count is 1. The
     * confidence threshold can be configured by appending the pipe character `|`
     * followed by the `threshold-&lt;confidence threshold&gt;` option after the answers
     * parameter value, such as `extractive|threshold-0.9`. Default threshold is 0.7.
     * The maximum character length of answers can be configured by appending the pipe
     * character '|' followed by the 'count-&lt;number of maximum character length&gt;',
     * such as 'extractive|maxcharlength-600'. Allowed values: "none", "extractive".</td></tr>
     * <tr><td>captions</td><td>String</td><td>No</td><td>This parameter is only valid if the query type is `semantic`.
     * If set, the query
     * returns captions extracted from key passages in the highest ranked documents.
     * When Captions is set to `extractive`, highlighting is enabled by default, and
     * can be configured by appending the pipe character `|` followed by the
     * `highlight-&lt;true/false&gt;` option, such as `extractive|highlight-true`. Defaults
     * to `None`. The maximum character length of captions can be configured by
     * appending the pipe character '|' followed by the 'count-&lt;number of maximum
     * character length&gt;', such as 'extractive|maxcharlength-600'. Allowed values: "none", "extractive".</td></tr>
     * <tr><td>semanticQuery</td><td>String</td><td>No</td><td>Allows setting a separate search query that will be
     * solely used for semantic
     * reranking, semantic captions and semantic answers. Is useful for scenarios
     * where there is a need to use different queries between the base retrieval and
     * ranking phase, and the L2 semantic phase.</td></tr>
     * <tr><td>queryRewrites</td><td>String</td><td>No</td><td>When QueryRewrites is set to `generative`, the query
     * terms are sent to a
     * generate model which will produce 10 (default) rewrites to help increase the
     * recall of the request. The requested count can be configured by appending the
     * pipe character `|` followed by the `count-&lt;number of rewrites&gt;` option, such as
     * `generative|count-3`. Defaults to `None`. This parameter is only valid if the
     * query type is `semantic`. Allowed values: "none", "generative".</td></tr>
     * <tr><td>debug</td><td>String</td><td>No</td><td>Enables a debugging tool that can be used to further explore your
     * search
     * results. Allowed values: "disabled", "semantic", "vector", "queryRewrites", "all".</td></tr>
     * <tr><td>queryLanguage</td><td>String</td><td>No</td><td>The language of the query. Allowed values: "none",
     * "en-us", "en-gb", "en-in", "en-ca", "en-au", "fr-fr", "fr-ca", "de-de", "es-es", "es-mx", "zh-cn", "zh-tw",
     * "pt-br", "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru", "cs-cz", "nl-be", "nl-nl", "hu-hu", "pl-pl", "sv-se",
     * "tr-tr", "hi-in", "ar-sa", "ar-eg", "ar-ma", "ar-kw", "ar-jo", "da-dk", "no-no", "bg-bg", "hr-hr", "hr-ba",
     * "ms-my", "ms-bn", "sl-sl", "ta-in", "vi-vn", "el-gr", "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua",
     * "lv-lv", "et-ee", "ca-es", "fi-fi", "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am", "bn-in", "eu-es",
     * "gl-es", "gu-in", "he-il", "ga-ie", "kn-in", "ml-in", "mr-in", "fa-ae", "pa-in", "te-in", "ur-pk".</td></tr>
     * <tr><td>speller</td><td>String</td><td>No</td><td>Improve search recall by spell-correcting individual search
     * query terms. Allowed values: "none", "lexicon".</td></tr>
     * <tr><td>semanticFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names used for semantic
     * ranking. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: BinaryData (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight: String (Optional)
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby: String (Optional)
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/all) (Optional)
     *         search: String (Optional)
     *         searchFields: String (Optional)
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select: String (Optional)
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields: String (Optional)
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Double (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: BinaryData (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): [
     *                  (Optional){
     *                     semantic (Optional): {
     *                         titleField (Optional): {
     *                             name: String (Optional)
     *                             state: String(used/unused/partial) (Optional)
     *                         }
     *                         contentFields (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         keywordFields (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         rerankerInput (Optional): {
     *                             title: String (Optional)
     *                             content: String (Optional)
     *                             keywords: String (Optional)
     *                         }
     *                     }
     *                     vectors (Optional): {
     *                         subscores (Optional): {
     *                             text (Optional): {
     *                                 searchScore: Double (Optional)
     *                             }
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): {
     *                                         searchScore: Double (Optional)
     *                                         vectorSimilarity: Double (Optional)
     *                                     }
     *                                 }
     *                             ]
     *                             documentBoost: Double (Optional)
     *                         }
     *                     }
     *                 }
     *             ]
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> searchGetWithResponseAsync(String indexName, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.searchGet(this.client.getEndpoint(),
            this.client.getServiceVersion().getVersion(), indexName, accept, requestOptions, context));
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>search</td><td>String</td><td>No</td><td>A full-text search query expression; Use "*" or omit this
     * parameter to match
     * all documents.</td></tr>
     * <tr><td>$count</td><td>Boolean</td><td>No</td><td>A value that specifies whether to fetch the total count of
     * results. Default is
     * false. Setting this value to true may have a performance impact. Note that the
     * count returned is an approximation.</td></tr>
     * <tr><td>facet</td><td>List&lt;String&gt;</td><td>No</td><td>The list of facet expressions to apply to the search
     * query. Each facet
     * expression contains a field name, optionally followed by a comma-separated list
     * of name:value pairs. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>The OData $filter expression to apply to the search
     * query.</td></tr>
     * <tr><td>highlight</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to use for hit
     * highlights. Only searchable fields can
     * be used for hit highlighting. In the form of "," separated string.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with
     * highlightPreTag. Default is &amp;lt;/em&amp;gt;.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with
     * highlightPostTag. Default is &amp;lt;em&amp;gt;.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be
     * covered by a search query in order for the query to be reported as a success.
     * This parameter can be useful for ensuring search availability even for services
     * with only one replica. The default is 100.</td></tr>
     * <tr><td>$orderby</td><td>List&lt;String&gt;</td><td>No</td><td>The list of OData $orderby expressions by which to
     * sort the results. Each
     * expression can be either a field name or a call to either the geo.distance() or
     * the search.score() functions. Each expression can be followed by asc to
     * indicate ascending, and desc to indicate descending. The default is ascending
     * order. Ties will be broken by the match scores of documents. If no OrderBy is
     * specified, the default sort order is descending by document match score. There
     * can be at most 32 $orderby clauses. In the form of "," separated string.</td></tr>
     * <tr><td>queryType</td><td>String</td><td>No</td><td>A value that specifies the syntax of the search query. The
     * default is 'simple'.
     * Use 'full' if your query uses the Lucene query syntax. Allowed values: "simple", "full", "semantic".</td></tr>
     * <tr><td>scoringParameter</td><td>List&lt;String&gt;</td><td>No</td><td>The list of parameter values to be used in
     * scoring functions (for example,
     * referencePointParameter) using the format name-values. For example, if the
     * scoring profile defines a function with a parameter called 'mylocation' the
     * parameter string would be "mylocation--122.2,44.8" (without the quotes). Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>scoringProfile</td><td>String</td><td>No</td><td>The name of a scoring profile to evaluate match scores
     * for matching documents
     * in order to sort the results.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to which to scope the
     * full-text search. When using
     * fielded search (fieldName:searchExpression) in a full Lucene query, the field
     * names of each fielded search expression take precedence over any field names
     * listed in this parameter. In the form of "," separated string.</td></tr>
     * <tr><td>searchMode</td><td>String</td><td>No</td><td>A value that specifies whether any or all of the search
     * terms must be matched
     * in order to count the document as a match. Allowed values: "any", "all".</td></tr>
     * <tr><td>scoringStatistics</td><td>String</td><td>No</td><td>A value that specifies whether we want to calculate
     * scoring statistics (such as
     * document frequency) globally for more consistent scoring, or locally, for lower
     * latency. Allowed values: "local", "global".</td></tr>
     * <tr><td>sessionId</td><td>String</td><td>No</td><td>A value to be used to create a sticky session, which can help
     * to get more
     * consistent results. As long as the same sessionId is used, a best-effort
     * attempt will be made to target the same replica set. Be wary that reusing the
     * same sessionID values repeatedly can interfere with the load balancing of the
     * requests across replicas and adversely affect the performance of the search
     * service. The value used as sessionId cannot start with a '_' character.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>The list of fields to retrieve. If unspecified, all
     * fields marked as
     * retrievable in the schema are included. In the form of "," separated string.</td></tr>
     * <tr><td>$skip</td><td>Integer</td><td>No</td><td>The number of search results to skip. This value cannot be
     * greater than
     * 100,000. If you need to scan documents in sequence, but cannot use $skip due to
     * this limitation, consider using $orderby on a totally-ordered key and $filter
     * with a range query instead.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of search results to retrieve. This can be used in
     * conjunction with
     * $skip to implement client-side paging of search results. If results are
     * truncated due to server-side paging, the response will include a continuation
     * token that can be used to issue another Search request for the next page of
     * results.</td></tr>
     * <tr><td>semanticConfiguration</td><td>String</td><td>No</td><td>The name of the semantic configuration that lists
     * which fields should be used
     * for semantic ranking, captions, highlights, and answers</td></tr>
     * <tr><td>semanticErrorHandling</td><td>String</td><td>No</td><td>Allows the user to choose whether a semantic call
     * should fail completely, or to
     * return partial results (default). Allowed values: "partial", "fail".</td></tr>
     * <tr><td>semanticMaxWaitInMilliseconds</td><td>Integer</td><td>No</td><td>Allows the user to set an upper bound on
     * the amount of time it takes for
     * semantic enrichment to finish processing before the request fails.</td></tr>
     * <tr><td>answers</td><td>String</td><td>No</td><td>This parameter is only valid if the query type is `semantic`.
     * If set, the query
     * returns answers extracted from key passages in the highest ranked documents.
     * The number of answers returned can be configured by appending the pipe
     * character `|` followed by the `count-&lt;number of answers&gt;` option after the
     * answers parameter value, such as `extractive|count-3`. Default count is 1. The
     * confidence threshold can be configured by appending the pipe character `|`
     * followed by the `threshold-&lt;confidence threshold&gt;` option after the answers
     * parameter value, such as `extractive|threshold-0.9`. Default threshold is 0.7.
     * The maximum character length of answers can be configured by appending the pipe
     * character '|' followed by the 'count-&lt;number of maximum character length&gt;',
     * such as 'extractive|maxcharlength-600'. Allowed values: "none", "extractive".</td></tr>
     * <tr><td>captions</td><td>String</td><td>No</td><td>This parameter is only valid if the query type is `semantic`.
     * If set, the query
     * returns captions extracted from key passages in the highest ranked documents.
     * When Captions is set to `extractive`, highlighting is enabled by default, and
     * can be configured by appending the pipe character `|` followed by the
     * `highlight-&lt;true/false&gt;` option, such as `extractive|highlight-true`. Defaults
     * to `None`. The maximum character length of captions can be configured by
     * appending the pipe character '|' followed by the 'count-&lt;number of maximum
     * character length&gt;', such as 'extractive|maxcharlength-600'. Allowed values: "none", "extractive".</td></tr>
     * <tr><td>semanticQuery</td><td>String</td><td>No</td><td>Allows setting a separate search query that will be
     * solely used for semantic
     * reranking, semantic captions and semantic answers. Is useful for scenarios
     * where there is a need to use different queries between the base retrieval and
     * ranking phase, and the L2 semantic phase.</td></tr>
     * <tr><td>queryRewrites</td><td>String</td><td>No</td><td>When QueryRewrites is set to `generative`, the query
     * terms are sent to a
     * generate model which will produce 10 (default) rewrites to help increase the
     * recall of the request. The requested count can be configured by appending the
     * pipe character `|` followed by the `count-&lt;number of rewrites&gt;` option, such as
     * `generative|count-3`. Defaults to `None`. This parameter is only valid if the
     * query type is `semantic`. Allowed values: "none", "generative".</td></tr>
     * <tr><td>debug</td><td>String</td><td>No</td><td>Enables a debugging tool that can be used to further explore your
     * search
     * results. Allowed values: "disabled", "semantic", "vector", "queryRewrites", "all".</td></tr>
     * <tr><td>queryLanguage</td><td>String</td><td>No</td><td>The language of the query. Allowed values: "none",
     * "en-us", "en-gb", "en-in", "en-ca", "en-au", "fr-fr", "fr-ca", "de-de", "es-es", "es-mx", "zh-cn", "zh-tw",
     * "pt-br", "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru", "cs-cz", "nl-be", "nl-nl", "hu-hu", "pl-pl", "sv-se",
     * "tr-tr", "hi-in", "ar-sa", "ar-eg", "ar-ma", "ar-kw", "ar-jo", "da-dk", "no-no", "bg-bg", "hr-hr", "hr-ba",
     * "ms-my", "ms-bn", "sl-sl", "ta-in", "vi-vn", "el-gr", "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua",
     * "lv-lv", "et-ee", "ca-es", "fi-fi", "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am", "bn-in", "eu-es",
     * "gl-es", "gu-in", "he-il", "ga-ie", "kn-in", "ml-in", "mr-in", "fa-ae", "pa-in", "te-in", "ur-pk".</td></tr>
     * <tr><td>speller</td><td>String</td><td>No</td><td>Improve search recall by spell-correcting individual search
     * query terms. Allowed values: "none", "lexicon".</td></tr>
     * <tr><td>semanticFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names used for semantic
     * ranking. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: BinaryData (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight: String (Optional)
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby: String (Optional)
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/all) (Optional)
     *         search: String (Optional)
     *         searchFields: String (Optional)
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select: String (Optional)
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields: String (Optional)
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Double (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: BinaryData (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): [
     *                  (Optional){
     *                     semantic (Optional): {
     *                         titleField (Optional): {
     *                             name: String (Optional)
     *                             state: String(used/unused/partial) (Optional)
     *                         }
     *                         contentFields (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         keywordFields (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         rerankerInput (Optional): {
     *                             title: String (Optional)
     *                             content: String (Optional)
     *                             keywords: String (Optional)
     *                         }
     *                     }
     *                     vectors (Optional): {
     *                         subscores (Optional): {
     *                             text (Optional): {
     *                                 searchScore: Double (Optional)
     *                             }
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): {
     *                                         searchScore: Double (Optional)
     *                                         vectorSimilarity: Double (Optional)
     *                                     }
     *                                 }
     *                             ]
     *                             documentBoost: Double (Optional)
     *                         }
     *                     }
     *                 }
     *             ]
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> searchGetWithResponse(String indexName, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.searchGetSync(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(), indexName,
            accept, requestOptions, Context.NONE);
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     count: Boolean (Optional)
     *     facets (Optional): [
     *         String (Optional)
     *     ]
     *     filter: String (Optional)
     *     highlight: String (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby: String (Optional)
     *     queryType: String(simple/full/semantic) (Optional)
     *     scoringStatistics: String(local/global) (Optional)
     *     sessionId: String (Optional)
     *     scoringParameters (Optional): [
     *         String (Optional)
     *     ]
     *     scoringProfile: String (Optional)
     *     debug: String(disabled/semantic/vector/queryRewrites/all) (Optional)
     *     search: String (Optional)
     *     searchFields: String (Optional)
     *     searchMode: String(any/all) (Optional)
     *     queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *     speller: String(none/lexicon) (Optional)
     *     select: String (Optional)
     *     skip: Integer (Optional)
     *     top: Integer (Optional)
     *     semanticConfiguration: String (Optional)
     *     semanticErrorHandling: String(partial/fail) (Optional)
     *     semanticMaxWaitInMilliseconds: Integer (Optional)
     *     semanticQuery: String (Optional)
     *     answers: String(none/extractive) (Optional)
     *     captions: String(none/extractive) (Optional)
     *     queryRewrites: String(none/generative) (Optional)
     *     semanticFields: String (Optional)
     *     vectorQueries (Optional): [
     *          (Optional){
     *             kind: String(vector/text/imageUrl/imageBinary) (Required)
     *             k: Integer (Optional)
     *             fields: String (Optional)
     *             exhaustive: Boolean (Optional)
     *             oversampling: Double (Optional)
     *             weight: Double (Optional)
     *             threshold (Optional): {
     *                 kind: String(vectorSimilarity/searchScore) (Required)
     *             }
     *             filterOverride: String (Optional)
     *         }
     *     ]
     *     vectorFilterMode: String(postFilter/preFilter) (Optional)
     *     hybridSearch (Optional): {
     *         maxTextRecallSize: Integer (Optional)
     *         countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: BinaryData (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight: String (Optional)
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby: String (Optional)
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/all) (Optional)
     *         search: String (Optional)
     *         searchFields: String (Optional)
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select: String (Optional)
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields: String (Optional)
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Double (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: BinaryData (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): [
     *                  (Optional){
     *                     semantic (Optional): {
     *                         titleField (Optional): {
     *                             name: String (Optional)
     *                             state: String(used/unused/partial) (Optional)
     *                         }
     *                         contentFields (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         keywordFields (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         rerankerInput (Optional): {
     *                             title: String (Optional)
     *                             content: String (Optional)
     *                             keywords: String (Optional)
     *                         }
     *                     }
     *                     vectors (Optional): {
     *                         subscores (Optional): {
     *                             text (Optional): {
     *                                 searchScore: Double (Optional)
     *                             }
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): {
     *                                         searchScore: Double (Optional)
     *                                         vectorSimilarity: Double (Optional)
     *                                     }
     *                                 }
     *                             ]
     *                             documentBoost: Double (Optional)
     *                         }
     *                     }
     *                 }
     *             ]
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param searchRequest The definition of the Search request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> searchPostWithResponseAsync(String indexName, BinaryData searchRequest,
        RequestOptions requestOptions) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.searchPost(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(),
                indexName, contentType, accept, searchRequest, requestOptions, context));
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     count: Boolean (Optional)
     *     facets (Optional): [
     *         String (Optional)
     *     ]
     *     filter: String (Optional)
     *     highlight: String (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby: String (Optional)
     *     queryType: String(simple/full/semantic) (Optional)
     *     scoringStatistics: String(local/global) (Optional)
     *     sessionId: String (Optional)
     *     scoringParameters (Optional): [
     *         String (Optional)
     *     ]
     *     scoringProfile: String (Optional)
     *     debug: String(disabled/semantic/vector/queryRewrites/all) (Optional)
     *     search: String (Optional)
     *     searchFields: String (Optional)
     *     searchMode: String(any/all) (Optional)
     *     queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *     speller: String(none/lexicon) (Optional)
     *     select: String (Optional)
     *     skip: Integer (Optional)
     *     top: Integer (Optional)
     *     semanticConfiguration: String (Optional)
     *     semanticErrorHandling: String(partial/fail) (Optional)
     *     semanticMaxWaitInMilliseconds: Integer (Optional)
     *     semanticQuery: String (Optional)
     *     answers: String(none/extractive) (Optional)
     *     captions: String(none/extractive) (Optional)
     *     queryRewrites: String(none/generative) (Optional)
     *     semanticFields: String (Optional)
     *     vectorQueries (Optional): [
     *          (Optional){
     *             kind: String(vector/text/imageUrl/imageBinary) (Required)
     *             k: Integer (Optional)
     *             fields: String (Optional)
     *             exhaustive: Boolean (Optional)
     *             oversampling: Double (Optional)
     *             weight: Double (Optional)
     *             threshold (Optional): {
     *                 kind: String(vectorSimilarity/searchScore) (Required)
     *             }
     *             filterOverride: String (Optional)
     *         }
     *     ]
     *     vectorFilterMode: String(postFilter/preFilter) (Optional)
     *     hybridSearch (Optional): {
     *         maxTextRecallSize: Integer (Optional)
     *         countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: BinaryData (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight: String (Optional)
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby: String (Optional)
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/all) (Optional)
     *         search: String (Optional)
     *         searchFields: String (Optional)
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select: String (Optional)
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields: String (Optional)
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Double (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: BinaryData (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): [
     *                  (Optional){
     *                     semantic (Optional): {
     *                         titleField (Optional): {
     *                             name: String (Optional)
     *                             state: String(used/unused/partial) (Optional)
     *                         }
     *                         contentFields (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         keywordFields (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         rerankerInput (Optional): {
     *                             title: String (Optional)
     *                             content: String (Optional)
     *                             keywords: String (Optional)
     *                         }
     *                     }
     *                     vectors (Optional): {
     *                         subscores (Optional): {
     *                             text (Optional): {
     *                                 searchScore: Double (Optional)
     *                             }
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): {
     *                                         searchScore: Double (Optional)
     *                                         vectorSimilarity: Double (Optional)
     *                                     }
     *                                 }
     *                             ]
     *                             documentBoost: Double (Optional)
     *                         }
     *                     }
     *                 }
     *             ]
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param searchRequest The definition of the Search request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> searchPostWithResponse(String indexName, BinaryData searchRequest,
        RequestOptions requestOptions) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.searchPostSync(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(),
            indexName, contentType, accept, searchRequest, requestOptions, Context.NONE);
    }

    /**
     * Retrieves a document from the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>List of field names to retrieve for the document;
     * Any field not retrieved will
     * be missing from the returned document. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *      (Optional): {
     *         String: BinaryData (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param key The key of the document to retrieve.
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a document retrieved via a document lookup operation along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getWithResponseAsync(String key, String indexName,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(context -> service.get(this.client.getEndpoint(),
            this.client.getServiceVersion().getVersion(), key, indexName, accept, requestOptions, context));
    }

    /**
     * Retrieves a document from the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>List of field names to retrieve for the document;
     * Any field not retrieved will
     * be missing from the returned document. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *      (Optional): {
     *         String: BinaryData (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param key The key of the document to retrieve.
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a document retrieved via a document lookup operation along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> getWithResponse(String key, String indexName, RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.getSync(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(), key, indexName,
            accept, requestOptions, Context.NONE);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData expression that filters the documents considered for
     * suggestions.</td></tr>
     * <tr><td>fuzzy</td><td>Boolean</td><td>No</td><td>A value indicating whether to use fuzzy matching for the
     * suggestions query.
     * Default is false. When set to true, the query will find terms even if there's a
     * substituted or missing character in the search text. While this provides a
     * better experience in some scenarios, it comes at a performance cost as fuzzy
     * suggestions queries are slower and consume more resources.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with
     * highlightPreTag. If omitted, hit highlighting of suggestions is disabled.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with
     * highlightPostTag. If omitted, hit highlighting of suggestions is disabled.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be
     * covered by a suggestions query in order for the query to be reported as a
     * success. This parameter can be useful for ensuring search availability even for
     * services with only one replica. The default is 80.</td></tr>
     * <tr><td>$orderby</td><td>List&lt;String&gt;</td><td>No</td><td>The list of OData $orderby expressions by which to
     * sort the results. Each
     * expression can be either a field name or a call to either the geo.distance() or
     * the search.score() functions. Each expression can be followed by asc to
     * indicate ascending, or desc to indicate descending. The default is ascending
     * order. Ties will be broken by the match scores of documents. If no $orderby is
     * specified, the default sort order is descending by document match score. There
     * can be at most 32 $orderby clauses. In the form of "," separated string.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to search for the
     * specified search text. Target fields
     * must be included in the specified suggester. In the form of "," separated string.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>The list of fields to retrieve. If unspecified,
     * only the key field will be
     * included in the results. In the form of "," separated string.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of suggestions to retrieve. The value must be a number
     * between 1 and
     * 100. The default is 5.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and
     * no more than 100 characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     * of the index definition.
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> suggestGetWithResponseAsync(String searchText, String suggesterName,
        String indexName, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.suggestGet(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(),
                searchText, suggesterName, indexName, accept, requestOptions, context));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData expression that filters the documents considered for
     * suggestions.</td></tr>
     * <tr><td>fuzzy</td><td>Boolean</td><td>No</td><td>A value indicating whether to use fuzzy matching for the
     * suggestions query.
     * Default is false. When set to true, the query will find terms even if there's a
     * substituted or missing character in the search text. While this provides a
     * better experience in some scenarios, it comes at a performance cost as fuzzy
     * suggestions queries are slower and consume more resources.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with
     * highlightPreTag. If omitted, hit highlighting of suggestions is disabled.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with
     * highlightPostTag. If omitted, hit highlighting of suggestions is disabled.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be
     * covered by a suggestions query in order for the query to be reported as a
     * success. This parameter can be useful for ensuring search availability even for
     * services with only one replica. The default is 80.</td></tr>
     * <tr><td>$orderby</td><td>List&lt;String&gt;</td><td>No</td><td>The list of OData $orderby expressions by which to
     * sort the results. Each
     * expression can be either a field name or a call to either the geo.distance() or
     * the search.score() functions. Each expression can be followed by asc to
     * indicate ascending, or desc to indicate descending. The default is ascending
     * order. Ties will be broken by the match scores of documents. If no $orderby is
     * specified, the default sort order is descending by document match score. There
     * can be at most 32 $orderby clauses. In the form of "," separated string.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to search for the
     * specified search text. Target fields
     * must be included in the specified suggester. In the form of "," separated string.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>The list of fields to retrieve. If unspecified,
     * only the key field will be
     * included in the results. In the form of "," separated string.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of suggestions to retrieve. The value must be a number
     * between 1 and
     * 100. The default is 5.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and
     * no more than 100 characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     * of the index definition.
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> suggestGetWithResponse(String searchText, String suggesterName, String indexName,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.suggestGetSync(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(),
            searchText, suggesterName, indexName, accept, requestOptions, Context.NONE);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby: String (Optional)
     *     search: String (Required)
     *     searchFields: String (Optional)
     *     select: String (Optional)
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param suggestRequest The Suggest request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> suggestPostWithResponseAsync(String indexName, BinaryData suggestRequest,
        RequestOptions requestOptions) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.suggestPost(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(),
                indexName, contentType, accept, suggestRequest, requestOptions, context));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby: String (Optional)
     *     search: String (Required)
     *     searchFields: String (Optional)
     *     select: String (Optional)
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param suggestRequest The Suggest request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> suggestPostWithResponse(String indexName, BinaryData suggestRequest,
        RequestOptions requestOptions) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.suggestPostSync(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(),
            indexName, contentType, accept, suggestRequest, requestOptions, Context.NONE);
    }

    /**
     * Sends a batch of document write actions to the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.action: String(upload/merge/mergeOrUpload/delete) (Optional)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             key: String (Required)
     *             errorMessage: String (Optional)
     *             status: boolean (Required)
     *             statusCode: int (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param batch The batch of index actions.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing the status of operations for all documents in the indexing
     * request along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> indexWithResponseAsync(String indexName, BinaryData batch,
        RequestOptions requestOptions) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.index(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(), indexName,
                contentType, accept, batch, requestOptions, context));
    }

    /**
     * Sends a batch of document write actions to the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.action: String(upload/merge/mergeOrUpload/delete) (Optional)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             key: String (Required)
     *             errorMessage: String (Optional)
     *             status: boolean (Required)
     *             statusCode: int (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param batch The batch of index actions.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing the status of operations for all documents in the indexing
     * request along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> indexWithResponse(String indexName, BinaryData batch, RequestOptions requestOptions) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.indexSync(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(), indexName,
            contentType, accept, batch, requestOptions, Context.NONE);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in
     * the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>autocompleteMode</td><td>String</td><td>No</td><td>Specifies the mode for Autocomplete. The default is
     * 'oneTerm'. Use 'twoTerms'
     * to get shingles and 'oneTermWithContext' to use the current context while
     * producing auto-completed terms. Allowed values: "oneTerm", "twoTerms", "oneTermWithContext".</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData expression that filters the documents used to produce
     * completed terms
     * for the Autocomplete result.</td></tr>
     * <tr><td>fuzzy</td><td>Boolean</td><td>No</td><td>A value indicating whether to use fuzzy matching for the
     * autocomplete query.
     * Default is false. When set to true, the query will find terms even if there's a
     * substituted or missing character in the search text. While this provides a
     * better experience in some scenarios, it comes at a performance cost as fuzzy
     * autocomplete queries are slower and consume more resources.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with
     * highlightPreTag. If omitted, hit highlighting is disabled.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with
     * highlightPostTag. If omitted, hit highlighting is disabled.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be
     * covered by an autocomplete query in order for the query to be reported as a
     * success. This parameter can be useful for ensuring search availability even for
     * services with only one replica. The default is 80.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to consider when
     * querying for auto-completed terms.
     * Target fields must be included in the specified suggester. In the form of "," separated string.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of auto-completed terms to retrieve. This must be a
     * value between 1
     * and 100. The default is 5.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     * of the index definition.
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> autocompleteGetWithResponseAsync(String searchText, String suggesterName,
        String indexName, RequestOptions requestOptions) {
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.autocompleteGet(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(),
                searchText, suggesterName, indexName, accept, requestOptions, context));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in
     * the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>autocompleteMode</td><td>String</td><td>No</td><td>Specifies the mode for Autocomplete. The default is
     * 'oneTerm'. Use 'twoTerms'
     * to get shingles and 'oneTermWithContext' to use the current context while
     * producing auto-completed terms. Allowed values: "oneTerm", "twoTerms", "oneTermWithContext".</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData expression that filters the documents used to produce
     * completed terms
     * for the Autocomplete result.</td></tr>
     * <tr><td>fuzzy</td><td>Boolean</td><td>No</td><td>A value indicating whether to use fuzzy matching for the
     * autocomplete query.
     * Default is false. When set to true, the query will find terms even if there's a
     * substituted or missing character in the search text. While this provides a
     * better experience in some scenarios, it comes at a performance cost as fuzzy
     * autocomplete queries are slower and consume more resources.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with
     * highlightPreTag. If omitted, hit highlighting is disabled.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with
     * highlightPostTag. If omitted, hit highlighting is disabled.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be
     * covered by an autocomplete query in order for the query to be reported as a
     * success. This parameter can be useful for ensuring search availability even for
     * services with only one replica. The default is 80.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to consider when
     * querying for auto-completed terms.
     * Target fields must be included in the specified suggester. In the form of "," separated string.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of auto-completed terms to retrieve. This must be a
     * value between 1
     * and 100. The default is 5.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     * of the index definition.
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> autocompleteGetWithResponse(String searchText, String suggesterName, String indexName,
        RequestOptions requestOptions) {
        final String accept = "application/json";
        return service.autocompleteGetSync(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(),
            searchText, suggesterName, indexName, accept, requestOptions, Context.NONE);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in
     * the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     search: String (Required)
     *     autocompleteMode: String(oneTerm/twoTerms/oneTermWithContext) (Optional)
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     searchFields: String (Optional)
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param autocompleteRequest The definition of the Autocomplete request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response} on successful completion of {@link Mono}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> autocompletePostWithResponseAsync(String indexName,
        BinaryData autocompleteRequest, RequestOptions requestOptions) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return FluxUtil.withContext(
            context -> service.autocompletePost(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(),
                indexName, contentType, accept, autocompleteRequest, requestOptions, context));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in
     * the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     search: String (Required)
     *     autocompleteMode: String(oneTerm/twoTerms/oneTermWithContext) (Optional)
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     searchFields: String (Optional)
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param autocompleteRequest The definition of the Autocomplete request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response}.
     */
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Response<BinaryData> autocompletePostWithResponse(String indexName, BinaryData autocompleteRequest,
        RequestOptions requestOptions) {
        final String contentType = "application/json";
        final String accept = "application/json";
        return service.autocompletePostSync(this.client.getEndpoint(), this.client.getServiceVersion().getVersion(),
            indexName, contentType, accept, autocompleteRequest, requestOptions, Context.NONE);
    }
}
