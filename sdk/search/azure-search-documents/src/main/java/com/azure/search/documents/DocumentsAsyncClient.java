// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.search.documents;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.ReturnType;
import com.azure.core.annotation.ServiceClient;
import com.azure.core.annotation.ServiceMethod;
import com.azure.core.exception.ClientAuthenticationException;
import com.azure.core.exception.HttpResponseException;
import com.azure.core.exception.ResourceModifiedException;
import com.azure.core.exception.ResourceNotFoundException;
import com.azure.core.http.rest.RequestOptions;
import com.azure.core.http.rest.Response;
import com.azure.core.util.BinaryData;
import com.azure.core.util.FluxUtil;
import com.azure.search.documents.implementation.DocumentsImpl;
import com.azure.search.documents.models.AutocompleteMode;
import com.azure.search.documents.models.AutocompleteRequest;
import com.azure.search.documents.models.AutocompleteResult;
import com.azure.search.documents.models.IndexBatch;
import com.azure.search.documents.models.IndexDocumentsResult;
import com.azure.search.documents.models.LookupDocument;
import com.azure.search.documents.models.QueryAnswerType;
import com.azure.search.documents.models.QueryCaptionType;
import com.azure.search.documents.models.QueryDebugMode;
import com.azure.search.documents.models.QueryLanguage;
import com.azure.search.documents.models.QueryRewritesType;
import com.azure.search.documents.models.QuerySpellerType;
import com.azure.search.documents.models.QueryType;
import com.azure.search.documents.models.ScoringStatistics;
import com.azure.search.documents.models.SearchDocumentsResult;
import com.azure.search.documents.models.SearchMode;
import com.azure.search.documents.models.SearchRequest;
import com.azure.search.documents.models.SemanticErrorMode;
import com.azure.search.documents.models.SuggestDocumentsResult;
import com.azure.search.documents.models.SuggestRequest;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import reactor.core.publisher.Mono;

/**
 * Initializes a new instance of the asynchronous SearchClient type.
 */
@ServiceClient(builder = SearchClientBuilder.class, isAsync = true)
public final class DocumentsAsyncClient {
    @Generated
    private final DocumentsImpl serviceClient;

    /**
     * Initializes an instance of DocumentsAsyncClient class.
     * 
     * @param serviceClient the service client implementation.
     */
    @Generated
    DocumentsAsyncClient(DocumentsImpl serviceClient) {
        this.serviceClient = serviceClient;
    }

    /**
     * Queries the number of documents in the index.
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * int
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a 32-bit integer along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> countWithResponse(String indexName, RequestOptions requestOptions) {
        return this.serviceClient.countWithResponseAsync(indexName, requestOptions);
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>search</td><td>String</td><td>No</td><td>A full-text search query expression; Use "*" or omit this
     * parameter to match
     * all documents.</td></tr>
     * <tr><td>$count</td><td>Boolean</td><td>No</td><td>A value that specifies whether to fetch the total count of
     * results. Default is
     * false. Setting this value to true may have a performance impact. Note that the
     * count returned is an approximation.</td></tr>
     * <tr><td>facet</td><td>List&lt;String&gt;</td><td>No</td><td>The list of facet expressions to apply to the search
     * query. Each facet
     * expression contains a field name, optionally followed by a comma-separated list
     * of name:value pairs. Call {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>The OData $filter expression to apply to the search
     * query.</td></tr>
     * <tr><td>highlight</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to use for hit
     * highlights. Only searchable fields can
     * be used for hit highlighting. In the form of "," separated string.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with
     * highlightPreTag. Default is &amp;lt;/em&amp;gt;.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with
     * highlightPostTag. Default is &amp;lt;em&amp;gt;.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be
     * covered by a search query in order for the query to be reported as a success.
     * This parameter can be useful for ensuring search availability even for services
     * with only one replica. The default is 100.</td></tr>
     * <tr><td>$orderby</td><td>List&lt;String&gt;</td><td>No</td><td>The list of OData $orderby expressions by which to
     * sort the results. Each
     * expression can be either a field name or a call to either the geo.distance() or
     * the search.score() functions. Each expression can be followed by asc to
     * indicate ascending, and desc to indicate descending. The default is ascending
     * order. Ties will be broken by the match scores of documents. If no OrderBy is
     * specified, the default sort order is descending by document match score. There
     * can be at most 32 $orderby clauses. In the form of "," separated string.</td></tr>
     * <tr><td>queryType</td><td>String</td><td>No</td><td>A value that specifies the syntax of the search query. The
     * default is 'simple'.
     * Use 'full' if your query uses the Lucene query syntax. Allowed values: "simple", "full", "semantic".</td></tr>
     * <tr><td>scoringParameter</td><td>List&lt;String&gt;</td><td>No</td><td>The list of parameter values to be used in
     * scoring functions (for example,
     * referencePointParameter) using the format name-values. For example, if the
     * scoring profile defines a function with a parameter called 'mylocation' the
     * parameter string would be "mylocation--122.2,44.8" (without the quotes). Call
     * {@link RequestOptions#addQueryParam} to add string to array.</td></tr>
     * <tr><td>scoringProfile</td><td>String</td><td>No</td><td>The name of a scoring profile to evaluate match scores
     * for matching documents
     * in order to sort the results.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to which to scope the
     * full-text search. When using
     * fielded search (fieldName:searchExpression) in a full Lucene query, the field
     * names of each fielded search expression take precedence over any field names
     * listed in this parameter. In the form of "," separated string.</td></tr>
     * <tr><td>searchMode</td><td>String</td><td>No</td><td>A value that specifies whether any or all of the search
     * terms must be matched
     * in order to count the document as a match. Allowed values: "any", "all".</td></tr>
     * <tr><td>scoringStatistics</td><td>String</td><td>No</td><td>A value that specifies whether we want to calculate
     * scoring statistics (such as
     * document frequency) globally for more consistent scoring, or locally, for lower
     * latency. Allowed values: "local", "global".</td></tr>
     * <tr><td>sessionId</td><td>String</td><td>No</td><td>A value to be used to create a sticky session, which can help
     * to get more
     * consistent results. As long as the same sessionId is used, a best-effort
     * attempt will be made to target the same replica set. Be wary that reusing the
     * same sessionID values repeatedly can interfere with the load balancing of the
     * requests across replicas and adversely affect the performance of the search
     * service. The value used as sessionId cannot start with a '_' character.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>The list of fields to retrieve. If unspecified, all
     * fields marked as
     * retrievable in the schema are included. In the form of "," separated string.</td></tr>
     * <tr><td>$skip</td><td>Integer</td><td>No</td><td>The number of search results to skip. This value cannot be
     * greater than
     * 100,000. If you need to scan documents in sequence, but cannot use $skip due to
     * this limitation, consider using $orderby on a totally-ordered key and $filter
     * with a range query instead.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of search results to retrieve. This can be used in
     * conjunction with
     * $skip to implement client-side paging of search results. If results are
     * truncated due to server-side paging, the response will include a continuation
     * token that can be used to issue another Search request for the next page of
     * results.</td></tr>
     * <tr><td>semanticConfiguration</td><td>String</td><td>No</td><td>The name of the semantic configuration that lists
     * which fields should be used
     * for semantic ranking, captions, highlights, and answers</td></tr>
     * <tr><td>semanticErrorHandling</td><td>String</td><td>No</td><td>Allows the user to choose whether a semantic call
     * should fail completely, or to
     * return partial results (default). Allowed values: "partial", "fail".</td></tr>
     * <tr><td>semanticMaxWaitInMilliseconds</td><td>Integer</td><td>No</td><td>Allows the user to set an upper bound on
     * the amount of time it takes for
     * semantic enrichment to finish processing before the request fails.</td></tr>
     * <tr><td>answers</td><td>String</td><td>No</td><td>This parameter is only valid if the query type is `semantic`.
     * If set, the query
     * returns answers extracted from key passages in the highest ranked documents.
     * The number of answers returned can be configured by appending the pipe
     * character `|` followed by the `count-&lt;number of answers&gt;` option after the
     * answers parameter value, such as `extractive|count-3`. Default count is 1. The
     * confidence threshold can be configured by appending the pipe character `|`
     * followed by the `threshold-&lt;confidence threshold&gt;` option after the answers
     * parameter value, such as `extractive|threshold-0.9`. Default threshold is 0.7.
     * The maximum character length of answers can be configured by appending the pipe
     * character '|' followed by the 'count-&lt;number of maximum character length&gt;',
     * such as 'extractive|maxcharlength-600'. Allowed values: "none", "extractive".</td></tr>
     * <tr><td>captions</td><td>String</td><td>No</td><td>This parameter is only valid if the query type is `semantic`.
     * If set, the query
     * returns captions extracted from key passages in the highest ranked documents.
     * When Captions is set to `extractive`, highlighting is enabled by default, and
     * can be configured by appending the pipe character `|` followed by the
     * `highlight-&lt;true/false&gt;` option, such as `extractive|highlight-true`. Defaults
     * to `None`. The maximum character length of captions can be configured by
     * appending the pipe character '|' followed by the 'count-&lt;number of maximum
     * character length&gt;', such as 'extractive|maxcharlength-600'. Allowed values: "none", "extractive".</td></tr>
     * <tr><td>semanticQuery</td><td>String</td><td>No</td><td>Allows setting a separate search query that will be
     * solely used for semantic
     * reranking, semantic captions and semantic answers. Is useful for scenarios
     * where there is a need to use different queries between the base retrieval and
     * ranking phase, and the L2 semantic phase.</td></tr>
     * <tr><td>queryRewrites</td><td>String</td><td>No</td><td>When QueryRewrites is set to `generative`, the query
     * terms are sent to a
     * generate model which will produce 10 (default) rewrites to help increase the
     * recall of the request. The requested count can be configured by appending the
     * pipe character `|` followed by the `count-&lt;number of rewrites&gt;` option, such as
     * `generative|count-3`. Defaults to `None`. This parameter is only valid if the
     * query type is `semantic`. Allowed values: "none", "generative".</td></tr>
     * <tr><td>debug</td><td>String</td><td>No</td><td>Enables a debugging tool that can be used to further explore your
     * search
     * results. Allowed values: "disabled", "semantic", "vector", "queryRewrites", "all".</td></tr>
     * <tr><td>queryLanguage</td><td>String</td><td>No</td><td>The language of the query. Allowed values: "none",
     * "en-us", "en-gb", "en-in", "en-ca", "en-au", "fr-fr", "fr-ca", "de-de", "es-es", "es-mx", "zh-cn", "zh-tw",
     * "pt-br", "pt-pt", "it-it", "ja-jp", "ko-kr", "ru-ru", "cs-cz", "nl-be", "nl-nl", "hu-hu", "pl-pl", "sv-se",
     * "tr-tr", "hi-in", "ar-sa", "ar-eg", "ar-ma", "ar-kw", "ar-jo", "da-dk", "no-no", "bg-bg", "hr-hr", "hr-ba",
     * "ms-my", "ms-bn", "sl-sl", "ta-in", "vi-vn", "el-gr", "ro-ro", "is-is", "id-id", "th-th", "lt-lt", "uk-ua",
     * "lv-lv", "et-ee", "ca-es", "fi-fi", "sr-ba", "sr-me", "sr-rs", "sk-sk", "nb-no", "hy-am", "bn-in", "eu-es",
     * "gl-es", "gu-in", "he-il", "ga-ie", "kn-in", "ml-in", "mr-in", "fa-ae", "pa-in", "te-in", "ur-pk".</td></tr>
     * <tr><td>speller</td><td>String</td><td>No</td><td>Improve search recall by spell-correcting individual search
     * query terms. Allowed values: "none", "lexicon".</td></tr>
     * <tr><td>semanticFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names used for semantic
     * ranking. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: BinaryData (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight: String (Optional)
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby: String (Optional)
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/all) (Optional)
     *         search: String (Optional)
     *         searchFields: String (Optional)
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select: String (Optional)
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields: String (Optional)
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Double (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: BinaryData (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): [
     *                  (Optional){
     *                     semantic (Optional): {
     *                         titleField (Optional): {
     *                             name: String (Optional)
     *                             state: String(used/unused/partial) (Optional)
     *                         }
     *                         contentFields (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         keywordFields (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         rerankerInput (Optional): {
     *                             title: String (Optional)
     *                             content: String (Optional)
     *                             keywords: String (Optional)
     *                         }
     *                     }
     *                     vectors (Optional): {
     *                         subscores (Optional): {
     *                             text (Optional): {
     *                                 searchScore: Double (Optional)
     *                             }
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): {
     *                                         searchScore: Double (Optional)
     *                                         vectorSimilarity: Double (Optional)
     *                                     }
     *                                 }
     *                             ]
     *                             documentBoost: Double (Optional)
     *                         }
     *                     }
     *                 }
     *             ]
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> searchGetWithResponse(String indexName, RequestOptions requestOptions) {
        return this.serviceClient.searchGetWithResponseAsync(indexName, requestOptions);
    }

    /**
     * Searches for documents in the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     count: Boolean (Optional)
     *     facets (Optional): [
     *         String (Optional)
     *     ]
     *     filter: String (Optional)
     *     highlight: String (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby: String (Optional)
     *     queryType: String(simple/full/semantic) (Optional)
     *     scoringStatistics: String(local/global) (Optional)
     *     sessionId: String (Optional)
     *     scoringParameters (Optional): [
     *         String (Optional)
     *     ]
     *     scoringProfile: String (Optional)
     *     debug: String(disabled/semantic/vector/queryRewrites/all) (Optional)
     *     search: String (Optional)
     *     searchFields: String (Optional)
     *     searchMode: String(any/all) (Optional)
     *     queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *     speller: String(none/lexicon) (Optional)
     *     select: String (Optional)
     *     skip: Integer (Optional)
     *     top: Integer (Optional)
     *     semanticConfiguration: String (Optional)
     *     semanticErrorHandling: String(partial/fail) (Optional)
     *     semanticMaxWaitInMilliseconds: Integer (Optional)
     *     semanticQuery: String (Optional)
     *     answers: String(none/extractive) (Optional)
     *     captions: String(none/extractive) (Optional)
     *     queryRewrites: String(none/generative) (Optional)
     *     semanticFields: String (Optional)
     *     vectorQueries (Optional): [
     *          (Optional){
     *             kind: String(vector/text/imageUrl/imageBinary) (Required)
     *             k: Integer (Optional)
     *             fields: String (Optional)
     *             exhaustive: Boolean (Optional)
     *             oversampling: Double (Optional)
     *             weight: Double (Optional)
     *             threshold (Optional): {
     *                 kind: String(vectorSimilarity/searchScore) (Required)
     *             }
     *             filterOverride: String (Optional)
     *         }
     *     ]
     *     vectorFilterMode: String(postFilter/preFilter) (Optional)
     *     hybridSearch (Optional): {
     *         maxTextRecallSize: Integer (Optional)
     *         countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *     }
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;odata.count: Long (Optional)
     *     &#64;search.coverage: Double (Optional)
     *     &#64;search.facets (Optional): {
     *         String (Required): [
     *              (Required){
     *                 count: Long (Optional)
     *                 &#64;search.facets (Optional): {
     *                     String (Required): [
     *                         (recursive schema, see above)
     *                     ]
     *                 }
     *                  (Optional): {
     *                     String: BinaryData (Required)
     *                 }
     *             }
     *         ]
     *     }
     *     &#64;search.answers (Optional): [
     *          (Optional){
     *             score: Double (Optional)
     *             key: String (Optional)
     *             text: String (Optional)
     *             highlights: String (Optional)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.debug (Optional): {
     *         queryRewrites (Optional): {
     *             text (Optional): {
     *                 inputQuery: String (Optional)
     *                 rewrites (Optional): [
     *                     String (Optional)
     *                 ]
     *             }
     *             vectors (Optional): [
     *                 (recursive schema, see above)
     *             ]
     *         }
     *     }
     *     &#64;search.nextPageParameters (Optional): {
     *         count: Boolean (Optional)
     *         facets (Optional): [
     *             String (Optional)
     *         ]
     *         filter: String (Optional)
     *         highlight: String (Optional)
     *         highlightPostTag: String (Optional)
     *         highlightPreTag: String (Optional)
     *         minimumCoverage: Double (Optional)
     *         orderby: String (Optional)
     *         queryType: String(simple/full/semantic) (Optional)
     *         scoringStatistics: String(local/global) (Optional)
     *         sessionId: String (Optional)
     *         scoringParameters (Optional): [
     *             String (Optional)
     *         ]
     *         scoringProfile: String (Optional)
     *         debug: String(disabled/semantic/vector/queryRewrites/all) (Optional)
     *         search: String (Optional)
     *         searchFields: String (Optional)
     *         searchMode: String(any/all) (Optional)
     *         queryLanguage: String(none/en-us/en-gb/en-in/en-ca/en-au/fr-fr/fr-ca/de-de/es-es/es-mx/zh-cn/zh-tw/pt-br/pt-pt/it-it/ja-jp/ko-kr/ru-ru/cs-cz/nl-be/nl-nl/hu-hu/pl-pl/sv-se/tr-tr/hi-in/ar-sa/ar-eg/ar-ma/ar-kw/ar-jo/da-dk/no-no/bg-bg/hr-hr/hr-ba/ms-my/ms-bn/sl-sl/ta-in/vi-vn/el-gr/ro-ro/is-is/id-id/th-th/lt-lt/uk-ua/lv-lv/et-ee/ca-es/fi-fi/sr-ba/sr-me/sr-rs/sk-sk/nb-no/hy-am/bn-in/eu-es/gl-es/gu-in/he-il/ga-ie/kn-in/ml-in/mr-in/fa-ae/pa-in/te-in/ur-pk) (Optional)
     *         speller: String(none/lexicon) (Optional)
     *         select: String (Optional)
     *         skip: Integer (Optional)
     *         top: Integer (Optional)
     *         semanticConfiguration: String (Optional)
     *         semanticErrorHandling: String(partial/fail) (Optional)
     *         semanticMaxWaitInMilliseconds: Integer (Optional)
     *         semanticQuery: String (Optional)
     *         answers: String(none/extractive) (Optional)
     *         captions: String(none/extractive) (Optional)
     *         queryRewrites: String(none/generative) (Optional)
     *         semanticFields: String (Optional)
     *         vectorQueries (Optional): [
     *              (Optional){
     *                 kind: String(vector/text/imageUrl/imageBinary) (Required)
     *                 k: Integer (Optional)
     *                 fields: String (Optional)
     *                 exhaustive: Boolean (Optional)
     *                 oversampling: Double (Optional)
     *                 weight: Double (Optional)
     *                 threshold (Optional): {
     *                     kind: String(vectorSimilarity/searchScore) (Required)
     *                 }
     *                 filterOverride: String (Optional)
     *             }
     *         ]
     *         vectorFilterMode: String(postFilter/preFilter) (Optional)
     *         hybridSearch (Optional): {
     *             maxTextRecallSize: Integer (Optional)
     *             countAndFacetMode: String(countRetrievableResults/countAllResults) (Optional)
     *         }
     *     }
     *     value (Required): [
     *          (Required){
     *             &#64;search.score: double (Required)
     *             &#64;search.rerankerScore: Double (Optional)
     *             &#64;search.highlights (Optional): {
     *                 String (Required): [
     *                     String (Required)
     *                 ]
     *             }
     *             &#64;search.captions (Optional): [
     *                  (Optional){
     *                     text: String (Optional)
     *                     highlights: String (Optional)
     *                      (Optional): {
     *                         String: BinaryData (Required)
     *                     }
     *                 }
     *             ]
     *             &#64;search.documentDebugInfo (Optional): [
     *                  (Optional){
     *                     semantic (Optional): {
     *                         titleField (Optional): {
     *                             name: String (Optional)
     *                             state: String(used/unused/partial) (Optional)
     *                         }
     *                         contentFields (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         keywordFields (Optional): [
     *                             (recursive schema, see above)
     *                         ]
     *                         rerankerInput (Optional): {
     *                             title: String (Optional)
     *                             content: String (Optional)
     *                             keywords: String (Optional)
     *                         }
     *                     }
     *                     vectors (Optional): {
     *                         subscores (Optional): {
     *                             text (Optional): {
     *                                 searchScore: Double (Optional)
     *                             }
     *                             vectors (Optional): [
     *                                  (Optional){
     *                                     String (Required): {
     *                                         searchScore: Double (Optional)
     *                                         vectorSimilarity: Double (Optional)
     *                                     }
     *                                 }
     *                             ]
     *                             documentBoost: Double (Optional)
     *                         }
     *                     }
     *                 }
     *             ]
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;odata.nextLink: String (Optional)
     *     &#64;search.semanticPartialResponseReason: String(maxWaitExceeded/capacityOverloaded/transient) (Optional)
     *     &#64;search.semanticPartialResponseType: String(baseResults/rerankedResults) (Optional)
     *     &#64;search.semanticQueryRewritesResultType: String(originalQueryOnly) (Optional)
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param searchRequest The definition of the Search request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing search results from an index along with {@link Response} on successful completion of
     * {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> searchPostWithResponse(String indexName, BinaryData searchRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.searchPostWithResponseAsync(indexName, searchRequest, requestOptions);
    }

    /**
     * Retrieves a document from the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>List of field names to retrieve for the document;
     * Any field not retrieved will
     * be missing from the returned document. In the form of "," separated string.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *      (Optional): {
     *         String: BinaryData (Required)
     *     }
     * }
     * }
     * </pre>
     * 
     * @param key The key of the document to retrieve.
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return a document retrieved via a document lookup operation along with {@link Response} on successful completion
     * of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> getWithResponse(String key, String indexName, RequestOptions requestOptions) {
        return this.serviceClient.getWithResponseAsync(key, indexName, requestOptions);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData expression that filters the documents considered for
     * suggestions.</td></tr>
     * <tr><td>fuzzy</td><td>Boolean</td><td>No</td><td>A value indicating whether to use fuzzy matching for the
     * suggestions query.
     * Default is false. When set to true, the query will find terms even if there's a
     * substituted or missing character in the search text. While this provides a
     * better experience in some scenarios, it comes at a performance cost as fuzzy
     * suggestions queries are slower and consume more resources.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with
     * highlightPreTag. If omitted, hit highlighting of suggestions is disabled.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with
     * highlightPostTag. If omitted, hit highlighting of suggestions is disabled.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be
     * covered by a suggestions query in order for the query to be reported as a
     * success. This parameter can be useful for ensuring search availability even for
     * services with only one replica. The default is 80.</td></tr>
     * <tr><td>$orderby</td><td>List&lt;String&gt;</td><td>No</td><td>The list of OData $orderby expressions by which to
     * sort the results. Each
     * expression can be either a field name or a call to either the geo.distance() or
     * the search.score() functions. Each expression can be followed by asc to
     * indicate ascending, or desc to indicate descending. The default is ascending
     * order. Ties will be broken by the match scores of documents. If no $orderby is
     * specified, the default sort order is descending by document match score. There
     * can be at most 32 $orderby clauses. In the form of "," separated string.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to search for the
     * specified search text. Target fields
     * must be included in the specified suggester. In the form of "," separated string.</td></tr>
     * <tr><td>$select</td><td>List&lt;String&gt;</td><td>No</td><td>The list of fields to retrieve. If unspecified,
     * only the key field will be
     * included in the results. In the form of "," separated string.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of suggestions to retrieve. The value must be a number
     * between 1 and
     * 100. The default is 5.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and
     * no more than 100 characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     * of the index definition.
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> suggestGetWithResponse(String searchText, String suggesterName, String indexName,
        RequestOptions requestOptions) {
        return this.serviceClient.suggestGetWithResponseAsync(searchText, suggesterName, indexName, requestOptions);
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     orderby: String (Optional)
     *     search: String (Required)
     *     searchFields: String (Optional)
     *     select: String (Optional)
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.text: String (Required)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     *     &#64;search.coverage: Double (Optional)
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param suggestRequest The Suggest request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing suggestion query results from an index along with {@link Response} on successful
     * completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> suggestPostWithResponse(String indexName, BinaryData suggestRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.suggestPostWithResponseAsync(indexName, suggestRequest, requestOptions);
    }

    /**
     * Sends a batch of document write actions to the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             &#64;search.action: String(upload/merge/mergeOrUpload/delete) (Optional)
     *              (Optional): {
     *                 String: BinaryData (Required)
     *             }
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     value (Required): [
     *          (Required){
     *             key: String (Required)
     *             errorMessage: String (Optional)
     *             status: boolean (Required)
     *             statusCode: int (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param batch The batch of index actions.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return response containing the status of operations for all documents in the indexing
     * request along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> indexWithResponse(String indexName, BinaryData batch,
        RequestOptions requestOptions) {
        return this.serviceClient.indexWithResponseAsync(indexName, batch, requestOptions);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in
     * the index.
     * <p><strong>Query Parameters</strong></p>
     * <table border="1">
     * <caption>Query Parameters</caption>
     * <tr><th>Name</th><th>Type</th><th>Required</th><th>Description</th></tr>
     * <tr><td>autocompleteMode</td><td>String</td><td>No</td><td>Specifies the mode for Autocomplete. The default is
     * 'oneTerm'. Use 'twoTerms'
     * to get shingles and 'oneTermWithContext' to use the current context while
     * producing auto-completed terms. Allowed values: "oneTerm", "twoTerms", "oneTermWithContext".</td></tr>
     * <tr><td>$filter</td><td>String</td><td>No</td><td>An OData expression that filters the documents used to produce
     * completed terms
     * for the Autocomplete result.</td></tr>
     * <tr><td>fuzzy</td><td>Boolean</td><td>No</td><td>A value indicating whether to use fuzzy matching for the
     * autocomplete query.
     * Default is false. When set to true, the query will find terms even if there's a
     * substituted or missing character in the search text. While this provides a
     * better experience in some scenarios, it comes at a performance cost as fuzzy
     * autocomplete queries are slower and consume more resources.</td></tr>
     * <tr><td>highlightPostTag</td><td>String</td><td>No</td><td>A string tag that is appended to hit highlights. Must
     * be set with
     * highlightPreTag. If omitted, hit highlighting is disabled.</td></tr>
     * <tr><td>highlightPreTag</td><td>String</td><td>No</td><td>A string tag that is prepended to hit highlights. Must
     * be set with
     * highlightPostTag. If omitted, hit highlighting is disabled.</td></tr>
     * <tr><td>minimumCoverage</td><td>Double</td><td>No</td><td>A number between 0 and 100 indicating the percentage of
     * the index that must be
     * covered by an autocomplete query in order for the query to be reported as a
     * success. This parameter can be useful for ensuring search availability even for
     * services with only one replica. The default is 80.</td></tr>
     * <tr><td>searchFields</td><td>List&lt;String&gt;</td><td>No</td><td>The list of field names to consider when
     * querying for auto-completed terms.
     * Target fields must be included in the specified suggester. In the form of "," separated string.</td></tr>
     * <tr><td>$top</td><td>Integer</td><td>No</td><td>The number of auto-completed terms to retrieve. This must be a
     * value between 1
     * and 100. The default is 5.</td></tr>
     * </table>
     * You can add these to a request with {@link RequestOptions#addQueryParam}
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     * of the index definition.
     * @param indexName The name of the index.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> autocompleteGetWithResponse(String searchText, String suggesterName,
        String indexName, RequestOptions requestOptions) {
        return this.serviceClient.autocompleteGetWithResponseAsync(searchText, suggesterName, indexName,
            requestOptions);
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in
     * the index.
     * <p><strong>Request Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     search: String (Required)
     *     autocompleteMode: String(oneTerm/twoTerms/oneTermWithContext) (Optional)
     *     filter: String (Optional)
     *     fuzzy: Boolean (Optional)
     *     highlightPostTag: String (Optional)
     *     highlightPreTag: String (Optional)
     *     minimumCoverage: Double (Optional)
     *     searchFields: String (Optional)
     *     suggesterName: String (Required)
     *     top: Integer (Optional)
     * }
     * }
     * </pre>
     * 
     * <p><strong>Response Body Schema</strong></p>
     * 
     * <pre>
     * {@code
     * {
     *     &#64;search.coverage: Double (Optional)
     *     value (Required): [
     *          (Required){
     *             text: String (Required)
     *             queryPlusText: String (Required)
     *         }
     *     ]
     * }
     * }
     * </pre>
     * 
     * @param indexName The name of the index.
     * @param autocompleteRequest The definition of the Autocomplete request.
     * @param requestOptions The options to configure the HTTP request before HTTP client sends it.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @return the result of Autocomplete query along with {@link Response} on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Response<BinaryData>> autocompletePostWithResponse(String indexName, BinaryData autocompleteRequest,
        RequestOptions requestOptions) {
        return this.serviceClient.autocompletePostWithResponseAsync(indexName, autocompleteRequest, requestOptions);
    }

    /**
     * Queries the number of documents in the index.
     * 
     * @param indexName The name of the index.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a 32-bit integer on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<Integer> count(String indexName) {
        // Generated convenience method for countWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return countWithResponse(indexName, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(Integer.class));
    }

    /**
     * Searches for documents in the index.
     * 
     * @param indexName The name of the index.
     * @param searchText A full-text search query expression; Use "*" or omit this parameter to match
     * all documents.
     * @param includeTotalResultCount A value that specifies whether to fetch the total count of results. Default is
     * false. Setting this value to true may have a performance impact. Note that the
     * count returned is an approximation.
     * @param facets The list of facet expressions to apply to the search query. Each facet
     * expression contains a field name, optionally followed by a comma-separated list
     * of name:value pairs.
     * @param filter The OData $filter expression to apply to the search query.
     * @param highlightFields The list of field names to use for hit highlights. Only searchable fields can
     * be used for hit highlighting.
     * @param highlightPostTag A string tag that is appended to hit highlights. Must be set with
     * highlightPreTag. Default is &amp;lt;/em&amp;gt;.
     * @param highlightPreTag A string tag that is prepended to hit highlights. Must be set with
     * highlightPostTag. Default is &amp;lt;em&amp;gt;.
     * @param minimumCoverage A number between 0 and 100 indicating the percentage of the index that must be
     * covered by a search query in order for the query to be reported as a success.
     * This parameter can be useful for ensuring search availability even for services
     * with only one replica. The default is 100.
     * @param orderBy The list of OData $orderby expressions by which to sort the results. Each
     * expression can be either a field name or a call to either the geo.distance() or
     * the search.score() functions. Each expression can be followed by asc to
     * indicate ascending, and desc to indicate descending. The default is ascending
     * order. Ties will be broken by the match scores of documents. If no OrderBy is
     * specified, the default sort order is descending by document match score. There
     * can be at most 32 $orderby clauses.
     * @param queryType A value that specifies the syntax of the search query. The default is 'simple'.
     * Use 'full' if your query uses the Lucene query syntax.
     * @param scoringParameters The list of parameter values to be used in scoring functions (for example,
     * referencePointParameter) using the format name-values. For example, if the
     * scoring profile defines a function with a parameter called 'mylocation' the
     * parameter string would be "mylocation--122.2,44.8" (without the quotes).
     * @param scoringProfile The name of a scoring profile to evaluate match scores for matching documents
     * in order to sort the results.
     * @param searchFields The list of field names to which to scope the full-text search. When using
     * fielded search (fieldName:searchExpression) in a full Lucene query, the field
     * names of each fielded search expression take precedence over any field names
     * listed in this parameter.
     * @param searchMode A value that specifies whether any or all of the search terms must be matched
     * in order to count the document as a match.
     * @param scoringStatistics A value that specifies whether we want to calculate scoring statistics (such as
     * document frequency) globally for more consistent scoring, or locally, for lower
     * latency.
     * @param sessionId A value to be used to create a sticky session, which can help to get more
     * consistent results. As long as the same sessionId is used, a best-effort
     * attempt will be made to target the same replica set. Be wary that reusing the
     * same sessionID values repeatedly can interfere with the load balancing of the
     * requests across replicas and adversely affect the performance of the search
     * service. The value used as sessionId cannot start with a '_' character.
     * @param select The list of fields to retrieve. If unspecified, all fields marked as
     * retrievable in the schema are included.
     * @param skip The number of search results to skip. This value cannot be greater than
     * 100,000. If you need to scan documents in sequence, but cannot use $skip due to
     * this limitation, consider using $orderby on a totally-ordered key and $filter
     * with a range query instead.
     * @param top The number of search results to retrieve. This can be used in conjunction with
     * $skip to implement client-side paging of search results. If results are
     * truncated due to server-side paging, the response will include a continuation
     * token that can be used to issue another Search request for the next page of
     * results.
     * @param semanticConfiguration The name of the semantic configuration that lists which fields should be used
     * for semantic ranking, captions, highlights, and answers.
     * @param semanticErrorHandling Allows the user to choose whether a semantic call should fail completely, or to
     * return partial results (default).
     * @param semanticMaxWaitInMilliseconds Allows the user to set an upper bound on the amount of time it takes for
     * semantic enrichment to finish processing before the request fails.
     * @param answers This parameter is only valid if the query type is `semantic`. If set, the query
     * returns answers extracted from key passages in the highest ranked documents.
     * The number of answers returned can be configured by appending the pipe
     * character `|` followed by the `count-&lt;number of answers&gt;` option after the
     * answers parameter value, such as `extractive|count-3`. Default count is 1. The
     * confidence threshold can be configured by appending the pipe character `|`
     * followed by the `threshold-&lt;confidence threshold&gt;` option after the answers
     * parameter value, such as `extractive|threshold-0.9`. Default threshold is 0.7.
     * The maximum character length of answers can be configured by appending the pipe
     * character '|' followed by the 'count-&lt;number of maximum character length&gt;',
     * such as 'extractive|maxcharlength-600'.
     * @param captions This parameter is only valid if the query type is `semantic`. If set, the query
     * returns captions extracted from key passages in the highest ranked documents.
     * When Captions is set to `extractive`, highlighting is enabled by default, and
     * can be configured by appending the pipe character `|` followed by the
     * `highlight-&lt;true/false&gt;` option, such as `extractive|highlight-true`. Defaults
     * to `None`. The maximum character length of captions can be configured by
     * appending the pipe character '|' followed by the 'count-&lt;number of maximum
     * character length&gt;', such as 'extractive|maxcharlength-600'.
     * @param semanticQuery Allows setting a separate search query that will be solely used for semantic
     * reranking, semantic captions and semantic answers. Is useful for scenarios
     * where there is a need to use different queries between the base retrieval and
     * ranking phase, and the L2 semantic phase.
     * @param queryRewrites When QueryRewrites is set to `generative`, the query terms are sent to a
     * generate model which will produce 10 (default) rewrites to help increase the
     * recall of the request. The requested count can be configured by appending the
     * pipe character `|` followed by the `count-&lt;number of rewrites&gt;` option, such as
     * `generative|count-3`. Defaults to `None`. This parameter is only valid if the
     * query type is `semantic`.
     * @param debug Enables a debugging tool that can be used to further explore your search
     * results.
     * @param queryLanguage The language of the query.
     * @param speller Improve search recall by spell-correcting individual search query terms.
     * @param semanticFields The list of field names used for semantic ranking.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SearchDocumentsResult> searchGet(String indexName, String searchText, Boolean includeTotalResultCount,
        List<String> facets, String filter, List<String> highlightFields, String highlightPostTag,
        String highlightPreTag, Double minimumCoverage, List<String> orderBy, QueryType queryType,
        List<String> scoringParameters, String scoringProfile, List<String> searchFields, SearchMode searchMode,
        ScoringStatistics scoringStatistics, String sessionId, List<String> select, Integer skip, Integer top,
        String semanticConfiguration, SemanticErrorMode semanticErrorHandling, Integer semanticMaxWaitInMilliseconds,
        QueryAnswerType answers, QueryCaptionType captions, String semanticQuery, QueryRewritesType queryRewrites,
        QueryDebugMode debug, QueryLanguage queryLanguage, QuerySpellerType speller, List<String> semanticFields) {
        // Generated convenience method for searchGetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (searchText != null) {
            requestOptions.addQueryParam("search", searchText, false);
        }
        if (includeTotalResultCount != null) {
            requestOptions.addQueryParam("$count", String.valueOf(includeTotalResultCount), false);
        }
        if (facets != null) {
            for (String paramItemValue : facets) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("facet", paramItemValue, false);
                }
            }
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (highlightFields != null) {
            requestOptions.addQueryParam("highlight",
                highlightFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (highlightPostTag != null) {
            requestOptions.addQueryParam("highlightPostTag", highlightPostTag, false);
        }
        if (highlightPreTag != null) {
            requestOptions.addQueryParam("highlightPreTag", highlightPreTag, false);
        }
        if (minimumCoverage != null) {
            requestOptions.addQueryParam("minimumCoverage", String.valueOf(minimumCoverage), false);
        }
        if (orderBy != null) {
            requestOptions.addQueryParam("$orderby",
                orderBy.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (queryType != null) {
            requestOptions.addQueryParam("queryType", queryType.toString(), false);
        }
        if (scoringParameters != null) {
            for (String paramItemValue : scoringParameters) {
                if (paramItemValue != null) {
                    requestOptions.addQueryParam("scoringParameter", paramItemValue, false);
                }
            }
        }
        if (scoringProfile != null) {
            requestOptions.addQueryParam("scoringProfile", scoringProfile, false);
        }
        if (searchFields != null) {
            requestOptions.addQueryParam("searchFields",
                searchFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (searchMode != null) {
            requestOptions.addQueryParam("searchMode", searchMode.toString(), false);
        }
        if (scoringStatistics != null) {
            requestOptions.addQueryParam("scoringStatistics", scoringStatistics.toString(), false);
        }
        if (sessionId != null) {
            requestOptions.addQueryParam("sessionId", sessionId, false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (skip != null) {
            requestOptions.addQueryParam("$skip", String.valueOf(skip), false);
        }
        if (top != null) {
            requestOptions.addQueryParam("$top", String.valueOf(top), false);
        }
        if (semanticConfiguration != null) {
            requestOptions.addQueryParam("semanticConfiguration", semanticConfiguration, false);
        }
        if (semanticErrorHandling != null) {
            requestOptions.addQueryParam("semanticErrorHandling", semanticErrorHandling.toString(), false);
        }
        if (semanticMaxWaitInMilliseconds != null) {
            requestOptions.addQueryParam("semanticMaxWaitInMilliseconds", String.valueOf(semanticMaxWaitInMilliseconds),
                false);
        }
        if (answers != null) {
            requestOptions.addQueryParam("answers", answers.toString(), false);
        }
        if (captions != null) {
            requestOptions.addQueryParam("captions", captions.toString(), false);
        }
        if (semanticQuery != null) {
            requestOptions.addQueryParam("semanticQuery", semanticQuery, false);
        }
        if (queryRewrites != null) {
            requestOptions.addQueryParam("queryRewrites", queryRewrites.toString(), false);
        }
        if (debug != null) {
            requestOptions.addQueryParam("debug", debug.toString(), false);
        }
        if (queryLanguage != null) {
            requestOptions.addQueryParam("queryLanguage", queryLanguage.toString(), false);
        }
        if (speller != null) {
            requestOptions.addQueryParam("speller", speller.toString(), false);
        }
        if (semanticFields != null) {
            requestOptions.addQueryParam("semanticFields",
                semanticFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return searchGetWithResponse(indexName, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(SearchDocumentsResult.class));
    }

    /**
     * Searches for documents in the index.
     * 
     * @param indexName The name of the index.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SearchDocumentsResult> searchGet(String indexName) {
        // Generated convenience method for searchGetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return searchGetWithResponse(indexName, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(SearchDocumentsResult.class));
    }

    /**
     * Searches for documents in the index.
     * 
     * @param indexName The name of the index.
     * @param searchRequest The definition of the Search request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing search results from an index on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SearchDocumentsResult> searchPost(String indexName, SearchRequest searchRequest) {
        // Generated convenience method for searchPostWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return searchPostWithResponse(indexName, BinaryData.fromObject(searchRequest), requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(SearchDocumentsResult.class));
    }

    /**
     * Retrieves a document from the index.
     * 
     * @param key The key of the document to retrieve.
     * @param indexName The name of the index.
     * @param selectedFields List of field names to retrieve for the document; Any field not retrieved will
     * be missing from the returned document.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a document retrieved via a document lookup operation on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LookupDocument> get(String key, String indexName, List<String> selectedFields) {
        // Generated convenience method for getWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (selectedFields != null) {
            requestOptions.addQueryParam("$select",
                selectedFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        return getWithResponse(key, indexName, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LookupDocument.class));
    }

    /**
     * Retrieves a document from the index.
     * 
     * @param key The key of the document to retrieve.
     * @param indexName The name of the index.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return a document retrieved via a document lookup operation on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<LookupDocument> get(String key, String indexName) {
        // Generated convenience method for getWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return getWithResponse(key, indexName, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(LookupDocument.class));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and
     * no more than 100 characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     * of the index definition.
     * @param indexName The name of the index.
     * @param filter An OData expression that filters the documents considered for suggestions.
     * @param useFuzzyMatching A value indicating whether to use fuzzy matching for the suggestions query.
     * Default is false. When set to true, the query will find terms even if there's a
     * substituted or missing character in the search text. While this provides a
     * better experience in some scenarios, it comes at a performance cost as fuzzy
     * suggestions queries are slower and consume more resources.
     * @param highlightPostTag A string tag that is appended to hit highlights. Must be set with
     * highlightPreTag. If omitted, hit highlighting of suggestions is disabled.
     * @param highlightPreTag A string tag that is prepended to hit highlights. Must be set with
     * highlightPostTag. If omitted, hit highlighting of suggestions is disabled.
     * @param minimumCoverage A number between 0 and 100 indicating the percentage of the index that must be
     * covered by a suggestions query in order for the query to be reported as a
     * success. This parameter can be useful for ensuring search availability even for
     * services with only one replica. The default is 80.
     * @param orderBy The list of OData $orderby expressions by which to sort the results. Each
     * expression can be either a field name or a call to either the geo.distance() or
     * the search.score() functions. Each expression can be followed by asc to
     * indicate ascending, or desc to indicate descending. The default is ascending
     * order. Ties will be broken by the match scores of documents. If no $orderby is
     * specified, the default sort order is descending by document match score. There
     * can be at most 32 $orderby clauses.
     * @param searchFields The list of field names to search for the specified search text. Target fields
     * must be included in the specified suggester.
     * @param select The list of fields to retrieve. If unspecified, only the key field will be
     * included in the results.
     * @param top The number of suggestions to retrieve. The value must be a number between 1 and
     * 100. The default is 5.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SuggestDocumentsResult> suggestGet(String searchText, String suggesterName, String indexName,
        String filter, Boolean useFuzzyMatching, String highlightPostTag, String highlightPreTag,
        Double minimumCoverage, List<String> orderBy, List<String> searchFields, List<String> select, Integer top) {
        // Generated convenience method for suggestGetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (useFuzzyMatching != null) {
            requestOptions.addQueryParam("fuzzy", String.valueOf(useFuzzyMatching), false);
        }
        if (highlightPostTag != null) {
            requestOptions.addQueryParam("highlightPostTag", highlightPostTag, false);
        }
        if (highlightPreTag != null) {
            requestOptions.addQueryParam("highlightPreTag", highlightPreTag, false);
        }
        if (minimumCoverage != null) {
            requestOptions.addQueryParam("minimumCoverage", String.valueOf(minimumCoverage), false);
        }
        if (orderBy != null) {
            requestOptions.addQueryParam("$orderby",
                orderBy.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (searchFields != null) {
            requestOptions.addQueryParam("searchFields",
                searchFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (select != null) {
            requestOptions.addQueryParam("$select",
                select.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (top != null) {
            requestOptions.addQueryParam("$top", String.valueOf(top), false);
        }
        return suggestGetWithResponse(searchText, suggesterName, indexName, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(SuggestDocumentsResult.class));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param searchText The search text to use to suggest documents. Must be at least 1 character, and
     * no more than 100 characters.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     * of the index definition.
     * @param indexName The name of the index.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SuggestDocumentsResult> suggestGet(String searchText, String suggesterName, String indexName) {
        // Generated convenience method for suggestGetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return suggestGetWithResponse(searchText, suggesterName, indexName, requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(SuggestDocumentsResult.class));
    }

    /**
     * Suggests documents in the index that match the given partial query text.
     * 
     * @param indexName The name of the index.
     * @param suggestRequest The Suggest request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing suggestion query results from an index on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<SuggestDocumentsResult> suggestPost(String indexName, SuggestRequest suggestRequest) {
        // Generated convenience method for suggestPostWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return suggestPostWithResponse(indexName, BinaryData.fromObject(suggestRequest), requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(SuggestDocumentsResult.class));
    }

    /**
     * Sends a batch of document write actions to the index.
     * 
     * @param indexName The name of the index.
     * @param batch The batch of index actions.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return response containing the status of operations for all documents in the indexing
     * request on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<IndexDocumentsResult> index(String indexName, IndexBatch batch) {
        // Generated convenience method for indexWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return indexWithResponse(indexName, BinaryData.fromObject(batch), requestOptions).flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(IndexDocumentsResult.class));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in
     * the index.
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     * of the index definition.
     * @param indexName The name of the index.
     * @param autocompleteMode Specifies the mode for Autocomplete. The default is 'oneTerm'. Use 'twoTerms'
     * to get shingles and 'oneTermWithContext' to use the current context while
     * producing auto-completed terms.
     * @param filter An OData expression that filters the documents used to produce completed terms
     * for the Autocomplete result.
     * @param useFuzzyMatching A value indicating whether to use fuzzy matching for the autocomplete query.
     * Default is false. When set to true, the query will find terms even if there's a
     * substituted or missing character in the search text. While this provides a
     * better experience in some scenarios, it comes at a performance cost as fuzzy
     * autocomplete queries are slower and consume more resources.
     * @param highlightPostTag A string tag that is appended to hit highlights. Must be set with
     * highlightPreTag. If omitted, hit highlighting is disabled.
     * @param highlightPreTag A string tag that is prepended to hit highlights. Must be set with
     * highlightPostTag. If omitted, hit highlighting is disabled.
     * @param minimumCoverage A number between 0 and 100 indicating the percentage of the index that must be
     * covered by an autocomplete query in order for the query to be reported as a
     * success. This parameter can be useful for ensuring search availability even for
     * services with only one replica. The default is 80.
     * @param searchFields The list of field names to consider when querying for auto-completed terms.
     * Target fields must be included in the specified suggester.
     * @param top The number of auto-completed terms to retrieve. This must be a value between 1
     * and 100. The default is 5.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AutocompleteResult> autocompleteGet(String searchText, String suggesterName, String indexName,
        AutocompleteMode autocompleteMode, String filter, Boolean useFuzzyMatching, String highlightPostTag,
        String highlightPreTag, Double minimumCoverage, List<String> searchFields, Integer top) {
        // Generated convenience method for autocompleteGetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        if (autocompleteMode != null) {
            requestOptions.addQueryParam("autocompleteMode", autocompleteMode.toString(), false);
        }
        if (filter != null) {
            requestOptions.addQueryParam("$filter", filter, false);
        }
        if (useFuzzyMatching != null) {
            requestOptions.addQueryParam("fuzzy", String.valueOf(useFuzzyMatching), false);
        }
        if (highlightPostTag != null) {
            requestOptions.addQueryParam("highlightPostTag", highlightPostTag, false);
        }
        if (highlightPreTag != null) {
            requestOptions.addQueryParam("highlightPreTag", highlightPreTag, false);
        }
        if (minimumCoverage != null) {
            requestOptions.addQueryParam("minimumCoverage", String.valueOf(minimumCoverage), false);
        }
        if (searchFields != null) {
            requestOptions.addQueryParam("searchFields",
                searchFields.stream()
                    .map(paramItemValue -> Objects.toString(paramItemValue, ""))
                    .collect(Collectors.joining(",")),
                false);
        }
        if (top != null) {
            requestOptions.addQueryParam("$top", String.valueOf(top), false);
        }
        return autocompleteGetWithResponse(searchText, suggesterName, indexName, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AutocompleteResult.class));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in
     * the index.
     * 
     * @param searchText The incomplete term which should be auto-completed.
     * @param suggesterName The name of the suggester as specified in the suggesters collection that's part
     * of the index definition.
     * @param indexName The name of the index.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AutocompleteResult> autocompleteGet(String searchText, String suggesterName, String indexName) {
        // Generated convenience method for autocompleteGetWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return autocompleteGetWithResponse(searchText, suggesterName, indexName, requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AutocompleteResult.class));
    }

    /**
     * Autocompletes incomplete query terms based on input text and matching terms in
     * the index.
     * 
     * @param indexName The name of the index.
     * @param autocompleteRequest The definition of the Autocomplete request.
     * @throws IllegalArgumentException thrown if parameters fail the validation.
     * @throws HttpResponseException thrown if the request is rejected by server.
     * @throws ClientAuthenticationException thrown if the request is rejected by server on status code 401.
     * @throws ResourceNotFoundException thrown if the request is rejected by server on status code 404.
     * @throws ResourceModifiedException thrown if the request is rejected by server on status code 409.
     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.
     * @return the result of Autocomplete query on successful completion of {@link Mono}.
     */
    @Generated
    @ServiceMethod(returns = ReturnType.SINGLE)
    public Mono<AutocompleteResult> autocompletePost(String indexName, AutocompleteRequest autocompleteRequest) {
        // Generated convenience method for autocompletePostWithResponse
        RequestOptions requestOptions = new RequestOptions();
        return autocompletePostWithResponse(indexName, BinaryData.fromObject(autocompleteRequest), requestOptions)
            .flatMap(FluxUtil::toMono)
            .map(protocolMethodData -> protocolMethodData.toObject(AutocompleteResult.class));
    }
}
