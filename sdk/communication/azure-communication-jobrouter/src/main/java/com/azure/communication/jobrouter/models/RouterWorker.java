// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.
package com.azure.communication.jobrouter.models;

import com.azure.communication.jobrouter.implementation.JsonMergePatchHelper;
import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

/**
 * An entity for jobs to be routed to.
 */
@Fluent
public final class RouterWorker implements JsonSerializable<RouterWorker> {

    /**
     * Create new instance
     */
    public RouterWorker() {
    }

    /*
     * Id of the worker.
     */
    @JsonProperty(value = "id")
    private String id;

    /*
     * The current state of the worker.
     */
    @JsonProperty(value = "state")
    private RouterWorkerState state;

    /*
     * A set of key/value pairs that are identifying attributes used by the rules
     * engines to make decisions.
     */
    @JsonProperty(value = "labels")
    @JsonDeserialize(using = RouterValueMapDeserializer.class)
    @JsonSerialize(using = RouterValueMapSerializer.class)
    private Map<String, RouterValue> labels;

    /*
     * A set of non-identifying attributes attached to this worker.
     */
    @JsonProperty(value = "tags")
    @JsonDeserialize(using = RouterValueMapDeserializer.class)
    @JsonSerialize(using = RouterValueMapSerializer.class)
    private Map<String, RouterValue> tags;

    /*
     * A list of active offers issued to this worker.
     */
    @JsonProperty(value = "offers")
    private List<RouterJobOffer> offers;

    /*
     * A list of assigned jobs attached to this worker.
     */
    @JsonProperty(value = "assignedJobs")
    private List<RouterWorkerAssignment> assignedJobs;

    /*
     * A value indicating the workers capacity. A value of '1' means all capacity is
     * consumed. A value of '0' means no capacity is currently consumed.
     */
    @JsonProperty(value = "loadRatio")
    private Double loadRatio;

    /*
     * A flag indicating this worker is open to receive offers or not.
     */
    @JsonProperty(value = "availableForOffers")
    private Boolean availableForOffers;

    /**
     * Get the id property: Id of the worker.
     *
     * @return the id value.
     */
    public String getId() {
        return this.id;
    }

    /**
     * Get the state property: The current state of the worker.
     *
     * @return the state value.
     */
    public RouterWorkerState getState() {
        return this.state;
    }

    /**
     * Get the labels property: A set of key/value pairs that are identifying attributes used by the rules engines to
     * make decisions.
     *
     * @return the labels value.
     */
    public Map<String, RouterValue> getLabels() {
        return this.labels;
    }

    /**
     * Set the labels property: A set of key/value pairs that are identifying attributes used by the rules engines to
     * make decisions.
     *
     * @param labels the labels value to set.
     * @return the RouterWorker object itself.
     */
    public RouterWorker setLabels(Map<String, RouterValue> labels) {
        this.labels = labels;
        return this;
    }

    /**
     * Get the tags property: A set of non-identifying attributes attached to this worker.
     *
     * @return the tags value.
     */
    public Map<String, RouterValue> getTags() {
        return this.tags;
    }

    /**
     * Set the tags property: A set of non-identifying attributes attached to this worker.
     *
     * @param tags the tags value to set.
     * @return the RouterWorker object itself.
     */
    public RouterWorker setTags(Map<String, RouterValue> tags) {
        this.tags = tags;
        return this;
    }

    /**
     * Get the offers property: A list of active offers issued to this worker.
     *
     * @return the offers value.
     */
    public List<RouterJobOffer> getOffers() {
        return this.offers;
    }

    /**
     * Get the assignedJobs property: A list of assigned jobs attached to this worker.
     *
     * @return the assignedJobs value.
     */
    public List<RouterWorkerAssignment> getAssignedJobs() {
        return this.assignedJobs;
    }

    /**
     * Get the loadRatio property: A value indicating the workers capacity. A value of '1' means all capacity is
     * consumed. A value of '0' means no capacity is currently consumed.
     *
     * @return the loadRatio value.
     */
    public Double getLoadRatio() {
        return this.loadRatio;
    }

    /**
     * Get the availableForOffers property: A flag indicating this worker is open to receive offers or not.
     *
     * @return the availableForOffers value.
     */
    public Boolean isAvailableForOffers() {
        return this.availableForOffers;
    }

    /**
     * Set the availableForOffers property: A flag indicating this worker is open to receive offers or not.
     *
     * @param availableForOffers the availableForOffers value to set.
     * @return the RouterWorker object itself.
     */
    public RouterWorker setAvailableForOffers(Boolean availableForOffers) {
        this.availableForOffers = availableForOffers;
        return this;
    }

    /*
     * Concurrency Token.
     */
    @JsonProperty(value = "etag")
    private String etag;

    /*
     * The queue(s) that this worker can receive work from.
     */
    @JsonProperty(value = "queues")
    private List<String> queues;

    /*
     * The total capacity score this worker has to manage multiple concurrent jobs.
     */
    @JsonProperty(value = "capacity")
    private Integer capacity;

    /*
     * The channel(s) this worker can handle and their impact on the workers capacity.
     */
    @JsonProperty(value = "channels")
    private List<RouterChannel> channels;

    /*
     * If this is set, the worker will only receive up to this many new offers at a time.
     */
    @JsonProperty(value = "maxConcurrentOffers")
    private Integer maxConcurrentOffers;

    /**
     * Get the etag property: Concurrency Token.
     *
     * @return the etag value.
     */
    public String getEtag() {
        return this.etag;
    }

    /**
     * Get the queues property: The queue(s) that this worker can receive work from.
     *
     * @return the queues value.
     */
    public List<String> getQueues() {
        return this.queues;
    }

    /**
     * Set the queues property: The queue(s) that this worker can receive work from.
     *
     * @param queues the queues value to set.
     * @return the RouterWorker object itself.
     */
    public RouterWorker setQueues(List<String> queues) {
        this.queues = queues;
        return this;
    }

    /**
     * Get the capacity property: The total capacity score this worker has to manage multiple concurrent jobs.
     *
     * @return the capacity value.
     */
    public Integer getCapacity() {
        return this.capacity;
    }

    /**
     * Set the capacity property: The total capacity score this worker has to manage multiple concurrent jobs.
     *
     * @param capacity the capacity value to set.
     * @return the RouterWorker object itself.
     */
    public RouterWorker setCapacity(Integer capacity) {
        this.capacity = capacity;
        return this;
    }

    /**
     * Get the channels property: The channel(s) this worker can handle and their impact on the workers capacity.
     *
     * @return the channels value.
     */
    public List<RouterChannel> getChannels() {
        return this.channels;
    }

    /**
     * Set the channels property: The channel(s) this worker can handle and their impact on the workers capacity.
     *
     * @param channels the channels value to set.
     * @return the RouterWorker object itself.
     */
    public RouterWorker setChannels(List<RouterChannel> channels) {
        this.channels = channels;
        return this;
    }

    /**
     * Get the maxConcurrentOffers property: If this is set, the worker will only receive up to this many new offers at
     * a time.
     *
     * @return the maxConcurrentOffers value.
     */
    public Integer getMaxConcurrentOffers() {
        return this.maxConcurrentOffers;
    }

    /**
     * Set the maxConcurrentOffers property: If this is set, the worker will only receive up to this many new offers at
     * a time.
     *
     * @param maxConcurrentOffers the maxConcurrentOffers value to set.
     * @return the RouterWorkerInternal object itself.
     */
    public RouterWorker setMaxConcurrentOffers(Integer maxConcurrentOffers) {
        this.maxConcurrentOffers = maxConcurrentOffers;
        return this;
    }

    /**
     * Stores updated model property, the value is property name, not serialized name.
     */
    @Generated
    private final Set<String> updatedProperties = new HashSet<>();

    @Generated
    private boolean jsonMergePatch;

    @Generated
    private void serializeAsJsonMergePatch(boolean jsonMergePatch) {
        this.jsonMergePatch = jsonMergePatch;
    }

    static {
        JsonMergePatchHelper.setRouterWorkerAccessor(new JsonMergePatchHelper.RouterWorkerAccessor() {

            @Override
            public RouterWorker prepareModelForJsonMergePatch(RouterWorker model, boolean jsonMergePatchEnabled) {
                model.serializeAsJsonMergePatch(jsonMergePatchEnabled);
                return model;
            }

            @Override
            public boolean isJsonMergePatch(RouterWorker model) {
                return model.jsonMergePatch;
            }
        });
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        if (jsonMergePatch) {
            return toJsonMergePatch(jsonWriter);
        } else {
            jsonWriter.writeStartObject();
            jsonWriter.writeArrayField("queues", this.queues, (writer, element) -> writer.writeString(element));
            jsonWriter.writeNumberField("capacity", this.capacity);
            jsonWriter.writeMapField("labels", this.labels, (writer, element) -> writer.writeUntyped(element));
            jsonWriter.writeMapField("tags", this.tags, (writer, element) -> writer.writeUntyped(element));
            jsonWriter.writeArrayField("channels", this.channels, (writer, element) -> writer.writeJson(element));
            jsonWriter.writeBooleanField("availableForOffers", this.availableForOffers);
            jsonWriter.writeNumberField("maxConcurrentOffers", this.maxConcurrentOffers);
            return jsonWriter.writeEndObject();
        }
    }

    @Generated
    private JsonWriter toJsonMergePatch(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        if (updatedProperties.contains("queues")) {
            if (this.queues == null) {
                jsonWriter.writeNullField("queues");
            } else {
                jsonWriter.writeArrayField("queues", this.queues, (writer, element) -> writer.writeString(element));
            }
        }
        if (updatedProperties.contains("capacity")) {
            if (this.capacity == null) {
                jsonWriter.writeNullField("capacity");
            } else {
                jsonWriter.writeNumberField("capacity", this.capacity);
            }
        }
        if (updatedProperties.contains("labels")) {
            if (this.labels == null) {
                jsonWriter.writeNullField("labels");
            } else {
                jsonWriter.writeMapField("labels", this.labels, (writer, element) -> writer.writeUntyped(element));
            }
        }
        if (updatedProperties.contains("tags")) {
            if (this.tags == null) {
                jsonWriter.writeNullField("tags");
            } else {
                jsonWriter.writeMapField("tags", this.tags, (writer, element) -> writer.writeUntyped(element));
            }
        }
        if (updatedProperties.contains("channels")) {
            if (this.channels == null) {
                jsonWriter.writeNullField("channels");
            } else {
                jsonWriter.writeArrayField("channels", this.channels, (writer, element) -> writer.writeJson(element));
            }
        }
        if (updatedProperties.contains("availableForOffers")) {
            if (this.availableForOffers == null) {
                jsonWriter.writeNullField("availableForOffers");
            } else {
                jsonWriter.writeBooleanField("availableForOffers", this.availableForOffers);
            }
        }
        if (updatedProperties.contains("maxConcurrentOffers")) {
            if (this.maxConcurrentOffers == null) {
                jsonWriter.writeNullField("maxConcurrentOffers");
            } else {
                jsonWriter.writeNumberField("maxConcurrentOffers", this.maxConcurrentOffers);
            }
        }
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of RouterWorker from the JsonReader.
     *
     * @param jsonReader The JsonReader being read.
     * @return An instance of RouterWorker if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the RouterWorker.
     */
    @Generated
    public static RouterWorker fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            RouterWorker deserializedRouterWorker = new RouterWorker();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();
                if ("etag".equals(fieldName)) {
                    deserializedRouterWorker.etag = reader.getString();
                } else if ("id".equals(fieldName)) {
                    deserializedRouterWorker.id = reader.getString();
                } else if ("state".equals(fieldName)) {
                    deserializedRouterWorker.state = RouterWorkerState.fromString(reader.getString());
                } else if ("queues".equals(fieldName)) {
                    List<String> queues = reader.readArray(reader1 -> reader1.getString());
                    deserializedRouterWorker.queues = queues;
                } else if ("capacity".equals(fieldName)) {
                    deserializedRouterWorker.capacity = reader.getNullable(JsonReader::getInt);
                } else if ("labels".equals(fieldName)) {
                    Map<String, Object> labels = reader.readMap(reader1 -> reader1.readUntyped());
                    deserializedRouterWorker.labels = labels;
                } else if ("tags".equals(fieldName)) {
                    Map<String, Object> tags = reader.readMap(reader1 -> reader1.readUntyped());
                    deserializedRouterWorker.tags = tags;
                } else if ("channels".equals(fieldName)) {
                    List<RouterChannel> channels = reader.readArray(reader1 -> RouterChannel.fromJson(reader1));
                    deserializedRouterWorker.channels = channels;
                } else if ("offers".equals(fieldName)) {
                    List<RouterJobOffer> offers = reader.readArray(reader1 -> RouterJobOffer.fromJson(reader1));
                    deserializedRouterWorker.offers = offers;
                } else if ("assignedJobs".equals(fieldName)) {
                    List<RouterWorkerAssignment> assignedJobs
                        = reader.readArray(reader1 -> RouterWorkerAssignment.fromJson(reader1));
                    deserializedRouterWorker.assignedJobs = assignedJobs;
                } else if ("loadRatio".equals(fieldName)) {
                    deserializedRouterWorker.loadRatio = reader.getNullable(JsonReader::getDouble);
                } else if ("availableForOffers".equals(fieldName)) {
                    deserializedRouterWorker.availableForOffers = reader.getNullable(JsonReader::getBoolean);
                } else if ("maxConcurrentOffers".equals(fieldName)) {
                    deserializedRouterWorker.maxConcurrentOffers = reader.getNullable(JsonReader::getInt);
                } else {
                    reader.skipChildren();
                }
            }
            return deserializedRouterWorker;
        });
    }
}
