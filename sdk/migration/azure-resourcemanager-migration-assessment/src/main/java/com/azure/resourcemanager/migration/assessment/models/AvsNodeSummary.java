// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.migration.assessment.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Azure Avs Node summary.
 */
@Immutable
public final class AvsNodeSummary implements JsonSerializable<AvsNodeSummary> {
    /*
     * Servers suitable for migration.
     */
    private Integer serversSuitableForMigration;

    /*
     * The total number of servers.
     */
    private Integer totalNumberOfServers;

    /*
     * The total number of Avs VM cores.
     */
    private Integer cores;

    /*
     * The total memory in GB.
     */
    private Float memoryGb;

    /*
     * The on premises PaaS cost.
     */
    private CostDetails avsNodeCostDetails;

    /*
     * Estimated cost.
     */
    private Float estimatedCost;

    /*
     * OS licensing cost.
     */
    private Float osLicensingCost;

    /*
     * Estimated cost by offer.
     */
    private List<EstimatedCostByOffer> estimatedCostByRecommendedOffer;

    /*
     * The recommended VM family summary.
     */
    private List<RecommendedAvsNodeTypeSummary> recommendedAvsNodeTypeSummary;

    /*
     * Estimated External Storage
     */
    private List<EstimatedExternalStorage> estimatedExternalStorage;

    /*
     * Estimated Network
     */
    private List<EstimatedNetwork> estimatedNetwork;

    /*
     * Estimated Cost With VCF BYOL
     */
    private Float estimatedCostWithVcfByol;

    /*
     * Represents errors which might have occurred while calculating AVS Node Summary
     */
    private List<ErrorDetailAutoGenerated> errors;

    /**
     * Creates an instance of AvsNodeSummary class.
     */
    public AvsNodeSummary() {
    }

    /**
     * Get the serversSuitableForMigration property: Servers suitable for migration.
     * 
     * @return the serversSuitableForMigration value.
     */
    public Integer serversSuitableForMigration() {
        return this.serversSuitableForMigration;
    }

    /**
     * Get the totalNumberOfServers property: The total number of servers.
     * 
     * @return the totalNumberOfServers value.
     */
    public Integer totalNumberOfServers() {
        return this.totalNumberOfServers;
    }

    /**
     * Get the cores property: The total number of Avs VM cores.
     * 
     * @return the cores value.
     */
    public Integer cores() {
        return this.cores;
    }

    /**
     * Get the memoryGb property: The total memory in GB.
     * 
     * @return the memoryGb value.
     */
    public Float memoryGb() {
        return this.memoryGb;
    }

    /**
     * Get the avsNodeCostDetails property: The on premises PaaS cost.
     * 
     * @return the avsNodeCostDetails value.
     */
    public CostDetails avsNodeCostDetails() {
        return this.avsNodeCostDetails;
    }

    /**
     * Get the estimatedCost property: Estimated cost.
     * 
     * @return the estimatedCost value.
     */
    public Float estimatedCost() {
        return this.estimatedCost;
    }

    /**
     * Get the osLicensingCost property: OS licensing cost.
     * 
     * @return the osLicensingCost value.
     */
    public Float osLicensingCost() {
        return this.osLicensingCost;
    }

    /**
     * Get the estimatedCostByRecommendedOffer property: Estimated cost by offer.
     * 
     * @return the estimatedCostByRecommendedOffer value.
     */
    public List<EstimatedCostByOffer> estimatedCostByRecommendedOffer() {
        return this.estimatedCostByRecommendedOffer;
    }

    /**
     * Get the recommendedAvsNodeTypeSummary property: The recommended VM family summary.
     * 
     * @return the recommendedAvsNodeTypeSummary value.
     */
    public List<RecommendedAvsNodeTypeSummary> recommendedAvsNodeTypeSummary() {
        return this.recommendedAvsNodeTypeSummary;
    }

    /**
     * Get the estimatedExternalStorage property: Estimated External Storage.
     * 
     * @return the estimatedExternalStorage value.
     */
    public List<EstimatedExternalStorage> estimatedExternalStorage() {
        return this.estimatedExternalStorage;
    }

    /**
     * Get the estimatedNetwork property: Estimated Network.
     * 
     * @return the estimatedNetwork value.
     */
    public List<EstimatedNetwork> estimatedNetwork() {
        return this.estimatedNetwork;
    }

    /**
     * Get the estimatedCostWithVcfByol property: Estimated Cost With VCF BYOL.
     * 
     * @return the estimatedCostWithVcfByol value.
     */
    public Float estimatedCostWithVcfByol() {
        return this.estimatedCostWithVcfByol;
    }

    /**
     * Get the errors property: Represents errors which might have occurred while calculating AVS Node Summary.
     * 
     * @return the errors value.
     */
    public List<ErrorDetailAutoGenerated> errors() {
        return this.errors;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (avsNodeCostDetails() != null) {
            avsNodeCostDetails().validate();
        }
        if (estimatedCostByRecommendedOffer() != null) {
            estimatedCostByRecommendedOffer().forEach(e -> e.validate());
        }
        if (recommendedAvsNodeTypeSummary() != null) {
            recommendedAvsNodeTypeSummary().forEach(e -> e.validate());
        }
        if (estimatedExternalStorage() != null) {
            estimatedExternalStorage().forEach(e -> e.validate());
        }
        if (estimatedNetwork() != null) {
            estimatedNetwork().forEach(e -> e.validate());
        }
        if (errors() != null) {
            errors().forEach(e -> e.validate());
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of AvsNodeSummary from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of AvsNodeSummary if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the AvsNodeSummary.
     */
    public static AvsNodeSummary fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            AvsNodeSummary deserializedAvsNodeSummary = new AvsNodeSummary();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("serversSuitableForMigration".equals(fieldName)) {
                    deserializedAvsNodeSummary.serversSuitableForMigration = reader.getNullable(JsonReader::getInt);
                } else if ("totalNumberOfServers".equals(fieldName)) {
                    deserializedAvsNodeSummary.totalNumberOfServers = reader.getNullable(JsonReader::getInt);
                } else if ("cores".equals(fieldName)) {
                    deserializedAvsNodeSummary.cores = reader.getNullable(JsonReader::getInt);
                } else if ("memoryGb".equals(fieldName)) {
                    deserializedAvsNodeSummary.memoryGb = reader.getNullable(JsonReader::getFloat);
                } else if ("avsNodeCostDetails".equals(fieldName)) {
                    deserializedAvsNodeSummary.avsNodeCostDetails = CostDetails.fromJson(reader);
                } else if ("estimatedCost".equals(fieldName)) {
                    deserializedAvsNodeSummary.estimatedCost = reader.getNullable(JsonReader::getFloat);
                } else if ("osLicensingCost".equals(fieldName)) {
                    deserializedAvsNodeSummary.osLicensingCost = reader.getNullable(JsonReader::getFloat);
                } else if ("estimatedCostByRecommendedOffer".equals(fieldName)) {
                    List<EstimatedCostByOffer> estimatedCostByRecommendedOffer
                        = reader.readArray(reader1 -> EstimatedCostByOffer.fromJson(reader1));
                    deserializedAvsNodeSummary.estimatedCostByRecommendedOffer = estimatedCostByRecommendedOffer;
                } else if ("recommendedAvsNodeTypeSummary".equals(fieldName)) {
                    List<RecommendedAvsNodeTypeSummary> recommendedAvsNodeTypeSummary
                        = reader.readArray(reader1 -> RecommendedAvsNodeTypeSummary.fromJson(reader1));
                    deserializedAvsNodeSummary.recommendedAvsNodeTypeSummary = recommendedAvsNodeTypeSummary;
                } else if ("estimatedExternalStorage".equals(fieldName)) {
                    List<EstimatedExternalStorage> estimatedExternalStorage
                        = reader.readArray(reader1 -> EstimatedExternalStorage.fromJson(reader1));
                    deserializedAvsNodeSummary.estimatedExternalStorage = estimatedExternalStorage;
                } else if ("estimatedNetwork".equals(fieldName)) {
                    List<EstimatedNetwork> estimatedNetwork
                        = reader.readArray(reader1 -> EstimatedNetwork.fromJson(reader1));
                    deserializedAvsNodeSummary.estimatedNetwork = estimatedNetwork;
                } else if ("estimatedCostWithVcfByol".equals(fieldName)) {
                    deserializedAvsNodeSummary.estimatedCostWithVcfByol = reader.getNullable(JsonReader::getFloat);
                } else if ("errors".equals(fieldName)) {
                    List<ErrorDetailAutoGenerated> errors
                        = reader.readArray(reader1 -> ErrorDetailAutoGenerated.fromJson(reader1));
                    deserializedAvsNodeSummary.errors = errors;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedAvsNodeSummary;
        });
    }
}
