// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.migration.assessment.models;

import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * The sql instance extended details.
 */
@Immutable
public final class SqlInstanceExtendedDetails implements JsonSerializable<SqlInstanceExtendedDetails> {
    /*
     * Gets or sets the memory used by SQL instance in megabytes.
     */
    private Float memoryInUseInMB;

    /*
     * Gets or sets a value indicating whether SQL instance has been deep discovered.
     */
    private Boolean hasScanOccurred;

    /*
     * Gets the storage details.
     */
    private List<AssessedSqlInstanceStorageDetails> storageTypeBasedDetails;

    /*
     * Gets the product support status related details.
     */
    private ProductSupportStatus productSupportStatus;

    /*
     * Gets the FCI metadata if this instance represents an FCI instance.
     */
    private SqlFciMetadata fciMetadata;

    /*
     * Gets the overview counts of availability replicas in the assessed instance, by
     * commit mode and read type.
     */
    private SqlAvailabilityReplicaSummary availabilityReplicaSummary;

    /*
     * Gets a value indicating whether the SQL instance is clustered or not.
     */
    private Boolean isClustered;

    /*
     * Gets a value indicating whether the high availability is enabled or not.
     */
    private Boolean isHighAvailabilityEnabled;

    /*
     * Gets the list of recommended target reasoning.
     */
    private List<SqlRecommendationReasoning> recommendedTargetReasonings;

    /*
     * SQL instance edition.
     */
    private String sqlEdition;

    /*
     * SQL instance version.
     */
    private String sqlVersion;

    /*
     * Number of CPU cores assigned to the SQL instance.
     */
    private Integer numberOfCoresAllocated;

    /*
     * The percentage of the total number of cores being utilized by the SQL instance.
     */
    private Float percentageCoresUtilization;

    /*
     * The logical disk details.
     */
    private List<AssessedSqlInstanceDiskDetails> logicalDisks;

    /*
     * The databases summary.
     */
    private AssessedSqlInstanceDatabaseSummary databaseSummary;

    /**
     * Creates an instance of SqlInstanceExtendedDetails class.
     */
    public SqlInstanceExtendedDetails() {
    }

    /**
     * Get the memoryInUseInMB property: Gets or sets the memory used by SQL instance in megabytes.
     * 
     * @return the memoryInUseInMB value.
     */
    public Float memoryInUseInMB() {
        return this.memoryInUseInMB;
    }

    /**
     * Get the hasScanOccurred property: Gets or sets a value indicating whether SQL instance has been deep discovered.
     * 
     * @return the hasScanOccurred value.
     */
    public Boolean hasScanOccurred() {
        return this.hasScanOccurred;
    }

    /**
     * Get the storageTypeBasedDetails property: Gets the storage details.
     * 
     * @return the storageTypeBasedDetails value.
     */
    public List<AssessedSqlInstanceStorageDetails> storageTypeBasedDetails() {
        return this.storageTypeBasedDetails;
    }

    /**
     * Get the productSupportStatus property: Gets the product support status related details.
     * 
     * @return the productSupportStatus value.
     */
    public ProductSupportStatus productSupportStatus() {
        return this.productSupportStatus;
    }

    /**
     * Get the fciMetadata property: Gets the FCI metadata if this instance represents an FCI instance.
     * 
     * @return the fciMetadata value.
     */
    public SqlFciMetadata fciMetadata() {
        return this.fciMetadata;
    }

    /**
     * Get the availabilityReplicaSummary property: Gets the overview counts of availability replicas in the assessed
     * instance, by
     * commit mode and read type.
     * 
     * @return the availabilityReplicaSummary value.
     */
    public SqlAvailabilityReplicaSummary availabilityReplicaSummary() {
        return this.availabilityReplicaSummary;
    }

    /**
     * Get the isClustered property: Gets a value indicating whether the SQL instance is clustered or not.
     * 
     * @return the isClustered value.
     */
    public Boolean isClustered() {
        return this.isClustered;
    }

    /**
     * Get the isHighAvailabilityEnabled property: Gets a value indicating whether the high availability is enabled or
     * not.
     * 
     * @return the isHighAvailabilityEnabled value.
     */
    public Boolean isHighAvailabilityEnabled() {
        return this.isHighAvailabilityEnabled;
    }

    /**
     * Get the recommendedTargetReasonings property: Gets the list of recommended target reasoning.
     * 
     * @return the recommendedTargetReasonings value.
     */
    public List<SqlRecommendationReasoning> recommendedTargetReasonings() {
        return this.recommendedTargetReasonings;
    }

    /**
     * Get the sqlEdition property: SQL instance edition.
     * 
     * @return the sqlEdition value.
     */
    public String sqlEdition() {
        return this.sqlEdition;
    }

    /**
     * Get the sqlVersion property: SQL instance version.
     * 
     * @return the sqlVersion value.
     */
    public String sqlVersion() {
        return this.sqlVersion;
    }

    /**
     * Get the numberOfCoresAllocated property: Number of CPU cores assigned to the SQL instance.
     * 
     * @return the numberOfCoresAllocated value.
     */
    public Integer numberOfCoresAllocated() {
        return this.numberOfCoresAllocated;
    }

    /**
     * Get the percentageCoresUtilization property: The percentage of the total number of cores being utilized by the
     * SQL instance.
     * 
     * @return the percentageCoresUtilization value.
     */
    public Float percentageCoresUtilization() {
        return this.percentageCoresUtilization;
    }

    /**
     * Get the logicalDisks property: The logical disk details.
     * 
     * @return the logicalDisks value.
     */
    public List<AssessedSqlInstanceDiskDetails> logicalDisks() {
        return this.logicalDisks;
    }

    /**
     * Get the databaseSummary property: The databases summary.
     * 
     * @return the databaseSummary value.
     */
    public AssessedSqlInstanceDatabaseSummary databaseSummary() {
        return this.databaseSummary;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (storageTypeBasedDetails() != null) {
            storageTypeBasedDetails().forEach(e -> e.validate());
        }
        if (productSupportStatus() != null) {
            productSupportStatus().validate();
        }
        if (fciMetadata() != null) {
            fciMetadata().validate();
        }
        if (availabilityReplicaSummary() != null) {
            availabilityReplicaSummary().validate();
        }
        if (recommendedTargetReasonings() != null) {
            recommendedTargetReasonings().forEach(e -> e.validate());
        }
        if (logicalDisks() != null) {
            logicalDisks().forEach(e -> e.validate());
        }
        if (databaseSummary() != null) {
            databaseSummary().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SqlInstanceExtendedDetails from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SqlInstanceExtendedDetails if the JsonReader was pointing to an instance of it, or null if
     * it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the SqlInstanceExtendedDetails.
     */
    public static SqlInstanceExtendedDetails fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SqlInstanceExtendedDetails deserializedSqlInstanceExtendedDetails = new SqlInstanceExtendedDetails();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("memoryInUseInMB".equals(fieldName)) {
                    deserializedSqlInstanceExtendedDetails.memoryInUseInMB = reader.getNullable(JsonReader::getFloat);
                } else if ("hasScanOccurred".equals(fieldName)) {
                    deserializedSqlInstanceExtendedDetails.hasScanOccurred = reader.getNullable(JsonReader::getBoolean);
                } else if ("storageTypeBasedDetails".equals(fieldName)) {
                    List<AssessedSqlInstanceStorageDetails> storageTypeBasedDetails
                        = reader.readArray(reader1 -> AssessedSqlInstanceStorageDetails.fromJson(reader1));
                    deserializedSqlInstanceExtendedDetails.storageTypeBasedDetails = storageTypeBasedDetails;
                } else if ("productSupportStatus".equals(fieldName)) {
                    deserializedSqlInstanceExtendedDetails.productSupportStatus = ProductSupportStatus.fromJson(reader);
                } else if ("fciMetadata".equals(fieldName)) {
                    deserializedSqlInstanceExtendedDetails.fciMetadata = SqlFciMetadata.fromJson(reader);
                } else if ("availabilityReplicaSummary".equals(fieldName)) {
                    deserializedSqlInstanceExtendedDetails.availabilityReplicaSummary
                        = SqlAvailabilityReplicaSummary.fromJson(reader);
                } else if ("isClustered".equals(fieldName)) {
                    deserializedSqlInstanceExtendedDetails.isClustered = reader.getNullable(JsonReader::getBoolean);
                } else if ("isHighAvailabilityEnabled".equals(fieldName)) {
                    deserializedSqlInstanceExtendedDetails.isHighAvailabilityEnabled
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("recommendedTargetReasonings".equals(fieldName)) {
                    List<SqlRecommendationReasoning> recommendedTargetReasonings
                        = reader.readArray(reader1 -> SqlRecommendationReasoning.fromJson(reader1));
                    deserializedSqlInstanceExtendedDetails.recommendedTargetReasonings = recommendedTargetReasonings;
                } else if ("sqlEdition".equals(fieldName)) {
                    deserializedSqlInstanceExtendedDetails.sqlEdition = reader.getString();
                } else if ("sqlVersion".equals(fieldName)) {
                    deserializedSqlInstanceExtendedDetails.sqlVersion = reader.getString();
                } else if ("numberOfCoresAllocated".equals(fieldName)) {
                    deserializedSqlInstanceExtendedDetails.numberOfCoresAllocated
                        = reader.getNullable(JsonReader::getInt);
                } else if ("percentageCoresUtilization".equals(fieldName)) {
                    deserializedSqlInstanceExtendedDetails.percentageCoresUtilization
                        = reader.getNullable(JsonReader::getFloat);
                } else if ("logicalDisks".equals(fieldName)) {
                    List<AssessedSqlInstanceDiskDetails> logicalDisks
                        = reader.readArray(reader1 -> AssessedSqlInstanceDiskDetails.fromJson(reader1));
                    deserializedSqlInstanceExtendedDetails.logicalDisks = logicalDisks;
                } else if ("databaseSummary".equals(fieldName)) {
                    deserializedSqlInstanceExtendedDetails.databaseSummary
                        = AssessedSqlInstanceDatabaseSummary.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSqlInstanceExtendedDetails;
        });
    }
}
