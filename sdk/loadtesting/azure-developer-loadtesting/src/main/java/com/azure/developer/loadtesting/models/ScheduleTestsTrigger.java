// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.developer.loadtesting.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.core.util.CoreUtils;
import com.azure.developer.loadtesting.implementation.JsonMergePatchHelper;
import com.azure.json.JsonReader;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * ScheduleTestsTrigger model.
 */
@Fluent
public final class ScheduleTestsTrigger extends Trigger {
    /*
     * The type of the trigger.
     */
    @Generated
    private TriggerType kind = TriggerType.SCHEDULE_TESTS_TRIGGER;

    /*
     * The test id of test to be triggered by this schedule trigger. Currently only one test is supported for a trigger.
     */
    @Generated
    private List<String> testIds;

    /*
     * Start date time of the trigger in UTC timezone. (RFC 3339 literal format)
     */
    @Generated
    private OffsetDateTime startDateTime;

    /*
     * The recurrenceStatus property.
     */
    @Generated
    private RecurrenceStatus recurrenceStatus;

    /*
     * Recurrence details of the trigger. Null if schedule is not recurring.
     */
    @Generated
    private Recurrence recurrence;

    /**
     * Stores updated model property, the value is property name, not serialized name.
     */
    @Generated
    private final Set<String> updatedProperties = new HashSet<>();

    /**
     * Creates an instance of ScheduleTestsTrigger class.
     */
    @Generated
    public ScheduleTestsTrigger() {
    }

    /**
     * Get the kind property: The type of the trigger.
     * 
     * @return the kind value.
     */
    @Generated
    @Override
    public TriggerType getKind() {
        return this.kind;
    }

    /**
     * Get the testIds property: The test id of test to be triggered by this schedule trigger. Currently only one test
     * is supported for a trigger.
     * 
     * @return the testIds value.
     */
    @Generated
    public List<String> getTestIds() {
        return this.testIds;
    }

    /**
     * Set the testIds property: The test id of test to be triggered by this schedule trigger. Currently only one test
     * is supported for a trigger.
     * <p>Required when create the resource.</p>
     * 
     * @param testIds the testIds value to set.
     * @return the ScheduleTestsTrigger object itself.
     */
    @Generated
    public ScheduleTestsTrigger setTestIds(List<String> testIds) {
        this.testIds = testIds;
        this.updatedProperties.add("testIds");
        return this;
    }

    /**
     * Get the startDateTime property: Start date time of the trigger in UTC timezone. (RFC 3339 literal format).
     * 
     * @return the startDateTime value.
     */
    @Generated
    public OffsetDateTime getStartDateTime() {
        return this.startDateTime;
    }

    /**
     * Set the startDateTime property: Start date time of the trigger in UTC timezone. (RFC 3339 literal format).
     * 
     * @param startDateTime the startDateTime value to set.
     * @return the ScheduleTestsTrigger object itself.
     */
    @Generated
    public ScheduleTestsTrigger setStartDateTime(OffsetDateTime startDateTime) {
        this.startDateTime = startDateTime;
        this.updatedProperties.add("startDateTime");
        return this;
    }

    /**
     * Get the recurrenceStatus property: The recurrenceStatus property.
     * 
     * @return the recurrenceStatus value.
     */
    @Generated
    public RecurrenceStatus getRecurrenceStatus() {
        return this.recurrenceStatus;
    }

    /**
     * Get the recurrence property: Recurrence details of the trigger. Null if schedule is not recurring.
     * 
     * @return the recurrence value.
     */
    @Generated
    public Recurrence getRecurrence() {
        return this.recurrence;
    }

    /**
     * Set the recurrence property: Recurrence details of the trigger. Null if schedule is not recurring.
     * 
     * @param recurrence the recurrence value to set.
     * @return the ScheduleTestsTrigger object itself.
     */
    @Generated
    public ScheduleTestsTrigger setRecurrence(Recurrence recurrence) {
        this.recurrence = recurrence;
        this.updatedProperties.add("recurrence");
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public ScheduleTestsTrigger setDisplayName(String displayName) {
        super.setDisplayName(displayName);
        this.updatedProperties.add("displayName");
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public ScheduleTestsTrigger setDescription(String description) {
        super.setDescription(description);
        this.updatedProperties.add("description");
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public ScheduleTestsTrigger setState(TriggerState state) {
        super.setState(state);
        this.updatedProperties.add("state");
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        if (JsonMergePatchHelper.getTriggerAccessor().isJsonMergePatch(this)) {
            return toJsonMergePatch(jsonWriter);
        } else {
            jsonWriter.writeStartObject();
            jsonWriter.writeStringField("displayName", getDisplayName());
            jsonWriter.writeStringField("description", getDescription());
            jsonWriter.writeStringField("state", getState() == null ? null : getState().toString());
            jsonWriter.writeStringField("kind", this.kind == null ? null : this.kind.toString());
            jsonWriter.writeArrayField("testIds", this.testIds, (writer, element) -> writer.writeString(element));
            jsonWriter.writeStringField("startDateTime",
                this.startDateTime == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.startDateTime));
            jsonWriter.writeJsonField("recurrence", this.recurrence);
            return jsonWriter.writeEndObject();
        }
    }

    @Generated
    private JsonWriter toJsonMergePatch(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        if (updatedProperties.contains("displayName")) {
            if (getDisplayName() == null) {
                jsonWriter.writeNullField("displayName");
            } else {
                jsonWriter.writeStringField("displayName", getDisplayName());
            }
        }
        if (updatedProperties.contains("description")) {
            if (getDescription() == null) {
                jsonWriter.writeNullField("description");
            } else {
                jsonWriter.writeStringField("description", getDescription());
            }
        }
        if (updatedProperties.contains("state")) {
            if (getState() == null) {
                jsonWriter.writeNullField("state");
            } else {
                jsonWriter.writeStringField("state", getState().toString());
            }
        }
        jsonWriter.writeStringField("kind", this.kind.toString());
        if (updatedProperties.contains("testIds")) {
            if (this.testIds == null) {
                jsonWriter.writeNullField("testIds");
            } else {
                jsonWriter.writeArrayField("testIds", this.testIds, (writer, element) -> writer.writeString(element));
            }
        }
        if (updatedProperties.contains("startDateTime")) {
            if (this.startDateTime == null) {
                jsonWriter.writeNullField("startDateTime");
            } else {
                jsonWriter.writeStringField("startDateTime",
                    this.startDateTime == null
                        ? null
                        : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.startDateTime));
            }
        }
        if (updatedProperties.contains("recurrence")) {
            if (this.recurrence == null) {
                jsonWriter.writeNullField("recurrence");
            } else {
                JsonMergePatchHelper.getRecurrenceAccessor().prepareModelForJsonMergePatch(this.recurrence, true);
                jsonWriter.writeJsonField("recurrence", this.recurrence);
                JsonMergePatchHelper.getRecurrenceAccessor().prepareModelForJsonMergePatch(this.recurrence, false);
            }
        }
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of ScheduleTestsTrigger from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of ScheduleTestsTrigger if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the ScheduleTestsTrigger.
     */
    @Generated
    public static ScheduleTestsTrigger fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            ScheduleTestsTrigger deserializedScheduleTestsTrigger = new ScheduleTestsTrigger();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("triggerId".equals(fieldName)) {
                    JsonMergePatchHelper.getTriggerAccessor()
                        .setTriggerId(deserializedScheduleTestsTrigger, reader.getString());
                } else if ("displayName".equals(fieldName)) {
                    JsonMergePatchHelper.getTriggerAccessor()
                        .setDisplayName(deserializedScheduleTestsTrigger, reader.getString());
                } else if ("description".equals(fieldName)) {
                    JsonMergePatchHelper.getTriggerAccessor()
                        .setDescription(deserializedScheduleTestsTrigger, reader.getString());
                } else if ("state".equals(fieldName)) {
                    JsonMergePatchHelper.getTriggerAccessor()
                        .setState(deserializedScheduleTestsTrigger, TriggerState.fromString(reader.getString()));
                } else if ("stateDetails".equals(fieldName)) {
                    JsonMergePatchHelper.getTriggerAccessor()
                        .setStateDetails(deserializedScheduleTestsTrigger, StateDetails.fromJson(reader));
                } else if ("createdDateTime".equals(fieldName)) {
                    JsonMergePatchHelper.getTriggerAccessor()
                        .setCreatedDateTime(deserializedScheduleTestsTrigger, reader.getNullable(
                            nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString())));
                } else if ("createdBy".equals(fieldName)) {
                    JsonMergePatchHelper.getTriggerAccessor()
                        .setCreatedBy(deserializedScheduleTestsTrigger, reader.getString());
                } else if ("lastModifiedDateTime".equals(fieldName)) {
                    JsonMergePatchHelper.getTriggerAccessor()
                        .setLastModifiedDateTime(deserializedScheduleTestsTrigger, reader.getNullable(
                            nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString())));
                } else if ("lastModifiedBy".equals(fieldName)) {
                    JsonMergePatchHelper.getTriggerAccessor()
                        .setLastModifiedBy(deserializedScheduleTestsTrigger, reader.getString());
                } else if ("kind".equals(fieldName)) {
                    deserializedScheduleTestsTrigger.kind = TriggerType.fromString(reader.getString());
                } else if ("testIds".equals(fieldName)) {
                    List<String> testIds = reader.readArray(reader1 -> reader1.getString());
                    deserializedScheduleTestsTrigger.testIds = testIds;
                } else if ("startDateTime".equals(fieldName)) {
                    deserializedScheduleTestsTrigger.startDateTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("recurrenceStatus".equals(fieldName)) {
                    deserializedScheduleTestsTrigger.recurrenceStatus = RecurrenceStatus.fromJson(reader);
                } else if ("recurrence".equals(fieldName)) {
                    deserializedScheduleTestsTrigger.recurrence = Recurrence.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedScheduleTestsTrigger;
        });
    }
}
