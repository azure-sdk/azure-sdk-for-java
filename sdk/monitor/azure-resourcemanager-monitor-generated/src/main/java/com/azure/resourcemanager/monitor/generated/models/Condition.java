// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.monitor.generated.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * A condition of the scheduled query rule.
 */
@Fluent
public final class Condition implements JsonSerializable<Condition> {
    /*
     * Specifies the type of threshold criteria
     */
    private CriterionType criterionType;

    /*
     * Log query alert
     */
    private String query;

    /*
     * Aggregation type. Relevant and required only for rules of the kind LogAlert.
     */
    private TimeAggregation timeAggregation;

    /*
     * The column containing the metric measure number. Relevant only for rules of the kind LogAlert.
     */
    private String metricMeasureColumn;

    /*
     * The column containing the resource id. The content of the column must be a uri formatted as resource id. Relevant
     * only for rules of the kind LogAlert.
     */
    private String resourceIdColumn;

    /*
     * List of Dimensions conditions
     */
    private List<Dimension> dimensions;

    /*
     * The criteria operator. Relevant and required only for rules of the kind LogAlert.
     */
    private ConditionOperator operator;

    /*
     * the criteria threshold value that activates the alert. Relevant and required only for static threshold rules of
     * the kind LogAlert.
     */
    private Double threshold;

    /*
     * The extent of deviation required to trigger an alert. Allowed values are 'Low', 'Medium' and 'High'. This will
     * affect how tight the threshold is to the metric series pattern. Relevant and required only for dynamic threshold
     * rules of the kind LogAlert.
     */
    private String alertSensitivity;

    /*
     * Use this option to set the date from which to start learning the metric historical data and calculate the dynamic
     * thresholds (in ISO8601 format). Relevant only for dynamic threshold rules of the kind LogAlert.
     */
    private OffsetDateTime ignoreDataBefore;

    /*
     * The minimum number of violations required within the selected lookback time window required to raise an alert.
     * Relevant only for rules of the kind LogAlert.
     */
    private ConditionFailingPeriods failingPeriods;

    /*
     * The name of the metric to be sent. Relevant and required only for rules of the kind LogToMetric.
     */
    private String metricName;

    /*
     * The minimum results count that should be found for triggering an alert. Relevant only for rules of the kind
     * SimpleLogAlert.
     */
    private Long minRecurrenceCount;

    /**
     * Creates an instance of Condition class.
     */
    public Condition() {
    }

    /**
     * Get the criterionType property: Specifies the type of threshold criteria.
     * 
     * @return the criterionType value.
     */
    public CriterionType criterionType() {
        return this.criterionType;
    }

    /**
     * Set the criterionType property: Specifies the type of threshold criteria.
     * 
     * @param criterionType the criterionType value to set.
     * @return the Condition object itself.
     */
    public Condition withCriterionType(CriterionType criterionType) {
        this.criterionType = criterionType;
        return this;
    }

    /**
     * Get the query property: Log query alert.
     * 
     * @return the query value.
     */
    public String query() {
        return this.query;
    }

    /**
     * Set the query property: Log query alert.
     * 
     * @param query the query value to set.
     * @return the Condition object itself.
     */
    public Condition withQuery(String query) {
        this.query = query;
        return this;
    }

    /**
     * Get the timeAggregation property: Aggregation type. Relevant and required only for rules of the kind LogAlert.
     * 
     * @return the timeAggregation value.
     */
    public TimeAggregation timeAggregation() {
        return this.timeAggregation;
    }

    /**
     * Set the timeAggregation property: Aggregation type. Relevant and required only for rules of the kind LogAlert.
     * 
     * @param timeAggregation the timeAggregation value to set.
     * @return the Condition object itself.
     */
    public Condition withTimeAggregation(TimeAggregation timeAggregation) {
        this.timeAggregation = timeAggregation;
        return this;
    }

    /**
     * Get the metricMeasureColumn property: The column containing the metric measure number. Relevant only for rules of
     * the kind LogAlert.
     * 
     * @return the metricMeasureColumn value.
     */
    public String metricMeasureColumn() {
        return this.metricMeasureColumn;
    }

    /**
     * Set the metricMeasureColumn property: The column containing the metric measure number. Relevant only for rules of
     * the kind LogAlert.
     * 
     * @param metricMeasureColumn the metricMeasureColumn value to set.
     * @return the Condition object itself.
     */
    public Condition withMetricMeasureColumn(String metricMeasureColumn) {
        this.metricMeasureColumn = metricMeasureColumn;
        return this;
    }

    /**
     * Get the resourceIdColumn property: The column containing the resource id. The content of the column must be a uri
     * formatted as resource id. Relevant only for rules of the kind LogAlert.
     * 
     * @return the resourceIdColumn value.
     */
    public String resourceIdColumn() {
        return this.resourceIdColumn;
    }

    /**
     * Set the resourceIdColumn property: The column containing the resource id. The content of the column must be a uri
     * formatted as resource id. Relevant only for rules of the kind LogAlert.
     * 
     * @param resourceIdColumn the resourceIdColumn value to set.
     * @return the Condition object itself.
     */
    public Condition withResourceIdColumn(String resourceIdColumn) {
        this.resourceIdColumn = resourceIdColumn;
        return this;
    }

    /**
     * Get the dimensions property: List of Dimensions conditions.
     * 
     * @return the dimensions value.
     */
    public List<Dimension> dimensions() {
        return this.dimensions;
    }

    /**
     * Set the dimensions property: List of Dimensions conditions.
     * 
     * @param dimensions the dimensions value to set.
     * @return the Condition object itself.
     */
    public Condition withDimensions(List<Dimension> dimensions) {
        this.dimensions = dimensions;
        return this;
    }

    /**
     * Get the operator property: The criteria operator. Relevant and required only for rules of the kind LogAlert.
     * 
     * @return the operator value.
     */
    public ConditionOperator operator() {
        return this.operator;
    }

    /**
     * Set the operator property: The criteria operator. Relevant and required only for rules of the kind LogAlert.
     * 
     * @param operator the operator value to set.
     * @return the Condition object itself.
     */
    public Condition withOperator(ConditionOperator operator) {
        this.operator = operator;
        return this;
    }

    /**
     * Get the threshold property: the criteria threshold value that activates the alert. Relevant and required only for
     * static threshold rules of the kind LogAlert.
     * 
     * @return the threshold value.
     */
    public Double threshold() {
        return this.threshold;
    }

    /**
     * Set the threshold property: the criteria threshold value that activates the alert. Relevant and required only for
     * static threshold rules of the kind LogAlert.
     * 
     * @param threshold the threshold value to set.
     * @return the Condition object itself.
     */
    public Condition withThreshold(Double threshold) {
        this.threshold = threshold;
        return this;
    }

    /**
     * Get the alertSensitivity property: The extent of deviation required to trigger an alert. Allowed values are
     * 'Low', 'Medium' and 'High'. This will affect how tight the threshold is to the metric series pattern. Relevant
     * and required only for dynamic threshold rules of the kind LogAlert.
     * 
     * @return the alertSensitivity value.
     */
    public String alertSensitivity() {
        return this.alertSensitivity;
    }

    /**
     * Set the alertSensitivity property: The extent of deviation required to trigger an alert. Allowed values are
     * 'Low', 'Medium' and 'High'. This will affect how tight the threshold is to the metric series pattern. Relevant
     * and required only for dynamic threshold rules of the kind LogAlert.
     * 
     * @param alertSensitivity the alertSensitivity value to set.
     * @return the Condition object itself.
     */
    public Condition withAlertSensitivity(String alertSensitivity) {
        this.alertSensitivity = alertSensitivity;
        return this;
    }

    /**
     * Get the ignoreDataBefore property: Use this option to set the date from which to start learning the metric
     * historical data and calculate the dynamic thresholds (in ISO8601 format). Relevant only for dynamic threshold
     * rules of the kind LogAlert.
     * 
     * @return the ignoreDataBefore value.
     */
    public OffsetDateTime ignoreDataBefore() {
        return this.ignoreDataBefore;
    }

    /**
     * Set the ignoreDataBefore property: Use this option to set the date from which to start learning the metric
     * historical data and calculate the dynamic thresholds (in ISO8601 format). Relevant only for dynamic threshold
     * rules of the kind LogAlert.
     * 
     * @param ignoreDataBefore the ignoreDataBefore value to set.
     * @return the Condition object itself.
     */
    public Condition withIgnoreDataBefore(OffsetDateTime ignoreDataBefore) {
        this.ignoreDataBefore = ignoreDataBefore;
        return this;
    }

    /**
     * Get the failingPeriods property: The minimum number of violations required within the selected lookback time
     * window required to raise an alert. Relevant only for rules of the kind LogAlert.
     * 
     * @return the failingPeriods value.
     */
    public ConditionFailingPeriods failingPeriods() {
        return this.failingPeriods;
    }

    /**
     * Set the failingPeriods property: The minimum number of violations required within the selected lookback time
     * window required to raise an alert. Relevant only for rules of the kind LogAlert.
     * 
     * @param failingPeriods the failingPeriods value to set.
     * @return the Condition object itself.
     */
    public Condition withFailingPeriods(ConditionFailingPeriods failingPeriods) {
        this.failingPeriods = failingPeriods;
        return this;
    }

    /**
     * Get the metricName property: The name of the metric to be sent. Relevant and required only for rules of the kind
     * LogToMetric.
     * 
     * @return the metricName value.
     */
    public String metricName() {
        return this.metricName;
    }

    /**
     * Set the metricName property: The name of the metric to be sent. Relevant and required only for rules of the kind
     * LogToMetric.
     * 
     * @param metricName the metricName value to set.
     * @return the Condition object itself.
     */
    public Condition withMetricName(String metricName) {
        this.metricName = metricName;
        return this;
    }

    /**
     * Get the minRecurrenceCount property: The minimum results count that should be found for triggering an alert.
     * Relevant only for rules of the kind SimpleLogAlert.
     * 
     * @return the minRecurrenceCount value.
     */
    public Long minRecurrenceCount() {
        return this.minRecurrenceCount;
    }

    /**
     * Set the minRecurrenceCount property: The minimum results count that should be found for triggering an alert.
     * Relevant only for rules of the kind SimpleLogAlert.
     * 
     * @param minRecurrenceCount the minRecurrenceCount value to set.
     * @return the Condition object itself.
     */
    public Condition withMinRecurrenceCount(Long minRecurrenceCount) {
        this.minRecurrenceCount = minRecurrenceCount;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (dimensions() != null) {
            dimensions().forEach(e -> e.validate());
        }
        if (failingPeriods() != null) {
            failingPeriods().validate();
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("criterionType", this.criterionType == null ? null : this.criterionType.toString());
        jsonWriter.writeStringField("query", this.query);
        jsonWriter.writeStringField("timeAggregation",
            this.timeAggregation == null ? null : this.timeAggregation.toString());
        jsonWriter.writeStringField("metricMeasureColumn", this.metricMeasureColumn);
        jsonWriter.writeStringField("resourceIdColumn", this.resourceIdColumn);
        jsonWriter.writeArrayField("dimensions", this.dimensions, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("operator", this.operator == null ? null : this.operator.toString());
        jsonWriter.writeNumberField("threshold", this.threshold);
        jsonWriter.writeStringField("alertSensitivity", this.alertSensitivity);
        jsonWriter.writeStringField("ignoreDataBefore",
            this.ignoreDataBefore == null
                ? null
                : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.ignoreDataBefore));
        jsonWriter.writeJsonField("failingPeriods", this.failingPeriods);
        jsonWriter.writeStringField("metricName", this.metricName);
        jsonWriter.writeNumberField("minRecurrenceCount", this.minRecurrenceCount);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of Condition from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of Condition if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IOException If an error occurs while reading the Condition.
     */
    public static Condition fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            Condition deserializedCondition = new Condition();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("criterionType".equals(fieldName)) {
                    deserializedCondition.criterionType = CriterionType.fromString(reader.getString());
                } else if ("query".equals(fieldName)) {
                    deserializedCondition.query = reader.getString();
                } else if ("timeAggregation".equals(fieldName)) {
                    deserializedCondition.timeAggregation = TimeAggregation.fromString(reader.getString());
                } else if ("metricMeasureColumn".equals(fieldName)) {
                    deserializedCondition.metricMeasureColumn = reader.getString();
                } else if ("resourceIdColumn".equals(fieldName)) {
                    deserializedCondition.resourceIdColumn = reader.getString();
                } else if ("dimensions".equals(fieldName)) {
                    List<Dimension> dimensions = reader.readArray(reader1 -> Dimension.fromJson(reader1));
                    deserializedCondition.dimensions = dimensions;
                } else if ("operator".equals(fieldName)) {
                    deserializedCondition.operator = ConditionOperator.fromString(reader.getString());
                } else if ("threshold".equals(fieldName)) {
                    deserializedCondition.threshold = reader.getNullable(JsonReader::getDouble);
                } else if ("alertSensitivity".equals(fieldName)) {
                    deserializedCondition.alertSensitivity = reader.getString();
                } else if ("ignoreDataBefore".equals(fieldName)) {
                    deserializedCondition.ignoreDataBefore = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("failingPeriods".equals(fieldName)) {
                    deserializedCondition.failingPeriods = ConditionFailingPeriods.fromJson(reader);
                } else if ("metricName".equals(fieldName)) {
                    deserializedCondition.metricName = reader.getString();
                } else if ("minRecurrenceCount".equals(fieldName)) {
                    deserializedCondition.minRecurrenceCount = reader.getNullable(JsonReader::getLong);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedCondition;
        });
    }
}
