// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.billingbenefits.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Custom price properties for a given discount.
 */
@Fluent
public final class CustomPriceProperties implements JsonSerializable<CustomPriceProperties> {
    /*
     * The type of the priceable node pricing rule. Validation: Required. Supported values are fixedPriceLock,
     * fixedListPrice, and priceCeiling.
     */
    private DiscountRuleType ruleType;

    /*
     * The catalog instance where the priceable node lives. Validation: Required. No defined format, will vary per team.
     */
    private String catalogId;

    /*
     * The set of BigCat claims. Validation: Required. Must contain AgreementType, NationalCloud, and PricingAudience
     * claims. Additionally requires AccessPass claim when creating custom price with action == consume on the pricing
     * instructions.
     */
    private List<CatalogClaimsItem> catalogClaims;

    /*
     * The term units for the priceable node. Validation: Optional, Maximum length 128 characters. Must be present if
     * and only if the availability derived by market, product, sku, and claims has terms.
     */
    private String termUnits;

    /*
     * The billing period of the priceable node. Validation: Optional, Maximum length 128 characters. Only allowed if
     * the availability derived by market, product, sku, and claims has terms and at least one of those terms has a
     * billing period. When specified, termUnits must be specified.
     */
    private String billingPeriod;

    /*
     * Must be present if the market, product, sku, and claims, and optional term information resolves to multiple
     * availabilities that only differ by meter type. Validation: Maximum length 128 characters.
     */
    private String meterType;

    /*
     * The set of market set prices of the priceable node. Validation: Required. Must contain at least one element.
     */
    private List<MarketSetPricesItems> marketSetPrices;

    /**
     * Creates an instance of CustomPriceProperties class.
     */
    public CustomPriceProperties() {
    }

    /**
     * Get the ruleType property: The type of the priceable node pricing rule. Validation: Required. Supported values
     * are fixedPriceLock, fixedListPrice, and priceCeiling.
     * 
     * @return the ruleType value.
     */
    public DiscountRuleType ruleType() {
        return this.ruleType;
    }

    /**
     * Set the ruleType property: The type of the priceable node pricing rule. Validation: Required. Supported values
     * are fixedPriceLock, fixedListPrice, and priceCeiling.
     * 
     * @param ruleType the ruleType value to set.
     * @return the CustomPriceProperties object itself.
     */
    public CustomPriceProperties withRuleType(DiscountRuleType ruleType) {
        this.ruleType = ruleType;
        return this;
    }

    /**
     * Get the catalogId property: The catalog instance where the priceable node lives. Validation: Required. No defined
     * format, will vary per team.
     * 
     * @return the catalogId value.
     */
    public String catalogId() {
        return this.catalogId;
    }

    /**
     * Set the catalogId property: The catalog instance where the priceable node lives. Validation: Required. No defined
     * format, will vary per team.
     * 
     * @param catalogId the catalogId value to set.
     * @return the CustomPriceProperties object itself.
     */
    public CustomPriceProperties withCatalogId(String catalogId) {
        this.catalogId = catalogId;
        return this;
    }

    /**
     * Get the catalogClaims property: The set of BigCat claims. Validation: Required. Must contain AgreementType,
     * NationalCloud, and PricingAudience claims. Additionally requires AccessPass claim when creating custom price with
     * action == consume on the pricing instructions.
     * 
     * @return the catalogClaims value.
     */
    public List<CatalogClaimsItem> catalogClaims() {
        return this.catalogClaims;
    }

    /**
     * Set the catalogClaims property: The set of BigCat claims. Validation: Required. Must contain AgreementType,
     * NationalCloud, and PricingAudience claims. Additionally requires AccessPass claim when creating custom price with
     * action == consume on the pricing instructions.
     * 
     * @param catalogClaims the catalogClaims value to set.
     * @return the CustomPriceProperties object itself.
     */
    public CustomPriceProperties withCatalogClaims(List<CatalogClaimsItem> catalogClaims) {
        this.catalogClaims = catalogClaims;
        return this;
    }

    /**
     * Get the termUnits property: The term units for the priceable node. Validation: Optional, Maximum length 128
     * characters. Must be present if and only if the availability derived by market, product, sku, and claims has
     * terms.
     * 
     * @return the termUnits value.
     */
    public String termUnits() {
        return this.termUnits;
    }

    /**
     * Set the termUnits property: The term units for the priceable node. Validation: Optional, Maximum length 128
     * characters. Must be present if and only if the availability derived by market, product, sku, and claims has
     * terms.
     * 
     * @param termUnits the termUnits value to set.
     * @return the CustomPriceProperties object itself.
     */
    public CustomPriceProperties withTermUnits(String termUnits) {
        this.termUnits = termUnits;
        return this;
    }

    /**
     * Get the billingPeriod property: The billing period of the priceable node. Validation: Optional, Maximum length
     * 128 characters. Only allowed if the availability derived by market, product, sku, and claims has terms and at
     * least one of those terms has a billing period. When specified, termUnits must be specified.
     * 
     * @return the billingPeriod value.
     */
    public String billingPeriod() {
        return this.billingPeriod;
    }

    /**
     * Set the billingPeriod property: The billing period of the priceable node. Validation: Optional, Maximum length
     * 128 characters. Only allowed if the availability derived by market, product, sku, and claims has terms and at
     * least one of those terms has a billing period. When specified, termUnits must be specified.
     * 
     * @param billingPeriod the billingPeriod value to set.
     * @return the CustomPriceProperties object itself.
     */
    public CustomPriceProperties withBillingPeriod(String billingPeriod) {
        this.billingPeriod = billingPeriod;
        return this;
    }

    /**
     * Get the meterType property: Must be present if the market, product, sku, and claims, and optional term
     * information resolves to multiple availabilities that only differ by meter type. Validation: Maximum length 128
     * characters.
     * 
     * @return the meterType value.
     */
    public String meterType() {
        return this.meterType;
    }

    /**
     * Set the meterType property: Must be present if the market, product, sku, and claims, and optional term
     * information resolves to multiple availabilities that only differ by meter type. Validation: Maximum length 128
     * characters.
     * 
     * @param meterType the meterType value to set.
     * @return the CustomPriceProperties object itself.
     */
    public CustomPriceProperties withMeterType(String meterType) {
        this.meterType = meterType;
        return this;
    }

    /**
     * Get the marketSetPrices property: The set of market set prices of the priceable node. Validation: Required. Must
     * contain at least one element.
     * 
     * @return the marketSetPrices value.
     */
    public List<MarketSetPricesItems> marketSetPrices() {
        return this.marketSetPrices;
    }

    /**
     * Set the marketSetPrices property: The set of market set prices of the priceable node. Validation: Required. Must
     * contain at least one element.
     * 
     * @param marketSetPrices the marketSetPrices value to set.
     * @return the CustomPriceProperties object itself.
     */
    public CustomPriceProperties withMarketSetPrices(List<MarketSetPricesItems> marketSetPrices) {
        this.marketSetPrices = marketSetPrices;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (ruleType() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException("Missing required property ruleType in model CustomPriceProperties"));
        }
        if (catalogId() == null) {
            throw LOGGER.atError()
                .log(
                    new IllegalArgumentException("Missing required property catalogId in model CustomPriceProperties"));
        }
        if (catalogClaims() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property catalogClaims in model CustomPriceProperties"));
        } else {
            catalogClaims().forEach(e -> e.validate());
        }
        if (marketSetPrices() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property marketSetPrices in model CustomPriceProperties"));
        } else {
            marketSetPrices().forEach(e -> e.validate());
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(CustomPriceProperties.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("ruleType", this.ruleType == null ? null : this.ruleType.toString());
        jsonWriter.writeStringField("catalogId", this.catalogId);
        jsonWriter.writeArrayField("catalogClaims", this.catalogClaims, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeArrayField("marketSetPrices", this.marketSetPrices,
            (writer, element) -> writer.writeJson(element));
        jsonWriter.writeStringField("termUnits", this.termUnits);
        jsonWriter.writeStringField("billingPeriod", this.billingPeriod);
        jsonWriter.writeStringField("meterType", this.meterType);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of CustomPriceProperties from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of CustomPriceProperties if the JsonReader was pointing to an instance of it, or null if it
     * was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the CustomPriceProperties.
     */
    public static CustomPriceProperties fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            CustomPriceProperties deserializedCustomPriceProperties = new CustomPriceProperties();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("ruleType".equals(fieldName)) {
                    deserializedCustomPriceProperties.ruleType = DiscountRuleType.fromString(reader.getString());
                } else if ("catalogId".equals(fieldName)) {
                    deserializedCustomPriceProperties.catalogId = reader.getString();
                } else if ("catalogClaims".equals(fieldName)) {
                    List<CatalogClaimsItem> catalogClaims
                        = reader.readArray(reader1 -> CatalogClaimsItem.fromJson(reader1));
                    deserializedCustomPriceProperties.catalogClaims = catalogClaims;
                } else if ("marketSetPrices".equals(fieldName)) {
                    List<MarketSetPricesItems> marketSetPrices
                        = reader.readArray(reader1 -> MarketSetPricesItems.fromJson(reader1));
                    deserializedCustomPriceProperties.marketSetPrices = marketSetPrices;
                } else if ("termUnits".equals(fieldName)) {
                    deserializedCustomPriceProperties.termUnits = reader.getString();
                } else if ("billingPeriod".equals(fieldName)) {
                    deserializedCustomPriceProperties.billingPeriod = reader.getString();
                } else if ("meterType".equals(fieldName)) {
                    deserializedCustomPriceProperties.meterType = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedCustomPriceProperties;
        });
    }
}
