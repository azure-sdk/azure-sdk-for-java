// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) AutoRest Code Generator.

package com.azure.resourcemanager.securityinsights.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.util.logging.ClientLogger;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * A custom response configuration for a rule.
 */
@Fluent
public final class CcpResponseConfig implements JsonSerializable<CcpResponseConfig> {
    /*
     * The json paths, '$' char is the json root.
     */
    private List<String> eventsJsonPaths;

    /*
     * The value where the status message/code should appear in the response.
     */
    private String successStatusJsonPath;

    /*
     * The the status value.
     */
    private String successStatusValue;

    /*
     * The value indicating whether the remote server support Gzip and we should expect Gzip response.
     */
    private Boolean isGzipCompressed;

    /*
     * The compression algorithm.
     */
    private String compressionAlgo;

    /*
     * The response format. possible values are json,csv,xml
     */
    private String format;

    /*
     * The csv delimiter, in case the response format is CSV.
     */
    private String csvDelimiter;

    /*
     * The value indicating whether the response has CSV boundary in case the response in CSV format.
     */
    private Boolean hasCsvBoundary;

    /*
     * The value indicating whether the response has headers in case the response in CSV format.
     */
    private Boolean hasCsvHeader;

    /*
     * The a value indicating whether the response isn't an array of events / logs. By setting this flag to true it
     * means the remote server will response with an object which each property has as a value an array of events /
     * logs.
     */
    private Boolean convertChildPropertiesToArray;

    /*
     * Th character used to escape characters in CSV.
     */
    private String csvEscape;

    /**
     * Creates an instance of CcpResponseConfig class.
     */
    public CcpResponseConfig() {
    }

    /**
     * Get the eventsJsonPaths property: The json paths, '$' char is the json root.
     * 
     * @return the eventsJsonPaths value.
     */
    public List<String> eventsJsonPaths() {
        return this.eventsJsonPaths;
    }

    /**
     * Set the eventsJsonPaths property: The json paths, '$' char is the json root.
     * 
     * @param eventsJsonPaths the eventsJsonPaths value to set.
     * @return the CcpResponseConfig object itself.
     */
    public CcpResponseConfig withEventsJsonPaths(List<String> eventsJsonPaths) {
        this.eventsJsonPaths = eventsJsonPaths;
        return this;
    }

    /**
     * Get the successStatusJsonPath property: The value where the status message/code should appear in the response.
     * 
     * @return the successStatusJsonPath value.
     */
    public String successStatusJsonPath() {
        return this.successStatusJsonPath;
    }

    /**
     * Set the successStatusJsonPath property: The value where the status message/code should appear in the response.
     * 
     * @param successStatusJsonPath the successStatusJsonPath value to set.
     * @return the CcpResponseConfig object itself.
     */
    public CcpResponseConfig withSuccessStatusJsonPath(String successStatusJsonPath) {
        this.successStatusJsonPath = successStatusJsonPath;
        return this;
    }

    /**
     * Get the successStatusValue property: The the status value.
     * 
     * @return the successStatusValue value.
     */
    public String successStatusValue() {
        return this.successStatusValue;
    }

    /**
     * Set the successStatusValue property: The the status value.
     * 
     * @param successStatusValue the successStatusValue value to set.
     * @return the CcpResponseConfig object itself.
     */
    public CcpResponseConfig withSuccessStatusValue(String successStatusValue) {
        this.successStatusValue = successStatusValue;
        return this;
    }

    /**
     * Get the isGzipCompressed property: The value indicating whether the remote server support Gzip and we should
     * expect Gzip response.
     * 
     * @return the isGzipCompressed value.
     */
    public Boolean isGzipCompressed() {
        return this.isGzipCompressed;
    }

    /**
     * Set the isGzipCompressed property: The value indicating whether the remote server support Gzip and we should
     * expect Gzip response.
     * 
     * @param isGzipCompressed the isGzipCompressed value to set.
     * @return the CcpResponseConfig object itself.
     */
    public CcpResponseConfig withIsGzipCompressed(Boolean isGzipCompressed) {
        this.isGzipCompressed = isGzipCompressed;
        return this;
    }

    /**
     * Get the compressionAlgo property: The compression algorithm.
     * 
     * @return the compressionAlgo value.
     */
    public String compressionAlgo() {
        return this.compressionAlgo;
    }

    /**
     * Set the compressionAlgo property: The compression algorithm.
     * 
     * @param compressionAlgo the compressionAlgo value to set.
     * @return the CcpResponseConfig object itself.
     */
    public CcpResponseConfig withCompressionAlgo(String compressionAlgo) {
        this.compressionAlgo = compressionAlgo;
        return this;
    }

    /**
     * Get the format property: The response format. possible values are json,csv,xml.
     * 
     * @return the format value.
     */
    public String format() {
        return this.format;
    }

    /**
     * Set the format property: The response format. possible values are json,csv,xml.
     * 
     * @param format the format value to set.
     * @return the CcpResponseConfig object itself.
     */
    public CcpResponseConfig withFormat(String format) {
        this.format = format;
        return this;
    }

    /**
     * Get the csvDelimiter property: The csv delimiter, in case the response format is CSV.
     * 
     * @return the csvDelimiter value.
     */
    public String csvDelimiter() {
        return this.csvDelimiter;
    }

    /**
     * Set the csvDelimiter property: The csv delimiter, in case the response format is CSV.
     * 
     * @param csvDelimiter the csvDelimiter value to set.
     * @return the CcpResponseConfig object itself.
     */
    public CcpResponseConfig withCsvDelimiter(String csvDelimiter) {
        this.csvDelimiter = csvDelimiter;
        return this;
    }

    /**
     * Get the hasCsvBoundary property: The value indicating whether the response has CSV boundary in case the response
     * in CSV format.
     * 
     * @return the hasCsvBoundary value.
     */
    public Boolean hasCsvBoundary() {
        return this.hasCsvBoundary;
    }

    /**
     * Set the hasCsvBoundary property: The value indicating whether the response has CSV boundary in case the response
     * in CSV format.
     * 
     * @param hasCsvBoundary the hasCsvBoundary value to set.
     * @return the CcpResponseConfig object itself.
     */
    public CcpResponseConfig withHasCsvBoundary(Boolean hasCsvBoundary) {
        this.hasCsvBoundary = hasCsvBoundary;
        return this;
    }

    /**
     * Get the hasCsvHeader property: The value indicating whether the response has headers in case the response in CSV
     * format.
     * 
     * @return the hasCsvHeader value.
     */
    public Boolean hasCsvHeader() {
        return this.hasCsvHeader;
    }

    /**
     * Set the hasCsvHeader property: The value indicating whether the response has headers in case the response in CSV
     * format.
     * 
     * @param hasCsvHeader the hasCsvHeader value to set.
     * @return the CcpResponseConfig object itself.
     */
    public CcpResponseConfig withHasCsvHeader(Boolean hasCsvHeader) {
        this.hasCsvHeader = hasCsvHeader;
        return this;
    }

    /**
     * Get the convertChildPropertiesToArray property: The a value indicating whether the response isn't an array of
     * events / logs. By setting this flag to true it means the remote server will response with an object which each
     * property has as a value an array of events / logs.
     * 
     * @return the convertChildPropertiesToArray value.
     */
    public Boolean convertChildPropertiesToArray() {
        return this.convertChildPropertiesToArray;
    }

    /**
     * Set the convertChildPropertiesToArray property: The a value indicating whether the response isn't an array of
     * events / logs. By setting this flag to true it means the remote server will response with an object which each
     * property has as a value an array of events / logs.
     * 
     * @param convertChildPropertiesToArray the convertChildPropertiesToArray value to set.
     * @return the CcpResponseConfig object itself.
     */
    public CcpResponseConfig withConvertChildPropertiesToArray(Boolean convertChildPropertiesToArray) {
        this.convertChildPropertiesToArray = convertChildPropertiesToArray;
        return this;
    }

    /**
     * Get the csvEscape property: Th character used to escape characters in CSV.
     * 
     * @return the csvEscape value.
     */
    public String csvEscape() {
        return this.csvEscape;
    }

    /**
     * Set the csvEscape property: Th character used to escape characters in CSV.
     * 
     * @param csvEscape the csvEscape value to set.
     * @return the CcpResponseConfig object itself.
     */
    public CcpResponseConfig withCsvEscape(String csvEscape) {
        this.csvEscape = csvEscape;
        return this;
    }

    /**
     * Validates the instance.
     * 
     * @throws IllegalArgumentException thrown if the instance is not valid.
     */
    public void validate() {
        if (eventsJsonPaths() == null) {
            throw LOGGER.atError()
                .log(new IllegalArgumentException(
                    "Missing required property eventsJsonPaths in model CcpResponseConfig"));
        }
    }

    private static final ClientLogger LOGGER = new ClientLogger(CcpResponseConfig.class);

    /**
     * {@inheritDoc}
     */
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("eventsJsonPaths", this.eventsJsonPaths,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("successStatusJsonPath", this.successStatusJsonPath);
        jsonWriter.writeStringField("successStatusValue", this.successStatusValue);
        jsonWriter.writeBooleanField("isGzipCompressed", this.isGzipCompressed);
        jsonWriter.writeStringField("compressionAlgo", this.compressionAlgo);
        jsonWriter.writeStringField("format", this.format);
        jsonWriter.writeStringField("csvDelimiter", this.csvDelimiter);
        jsonWriter.writeBooleanField("hasCsvBoundary", this.hasCsvBoundary);
        jsonWriter.writeBooleanField("hasCsvHeader", this.hasCsvHeader);
        jsonWriter.writeBooleanField("convertChildPropertiesToArray", this.convertChildPropertiesToArray);
        jsonWriter.writeStringField("csvEscape", this.csvEscape);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of CcpResponseConfig from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of CcpResponseConfig if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the CcpResponseConfig.
     */
    public static CcpResponseConfig fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            CcpResponseConfig deserializedCcpResponseConfig = new CcpResponseConfig();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("eventsJsonPaths".equals(fieldName)) {
                    List<String> eventsJsonPaths = reader.readArray(reader1 -> reader1.getString());
                    deserializedCcpResponseConfig.eventsJsonPaths = eventsJsonPaths;
                } else if ("successStatusJsonPath".equals(fieldName)) {
                    deserializedCcpResponseConfig.successStatusJsonPath = reader.getString();
                } else if ("successStatusValue".equals(fieldName)) {
                    deserializedCcpResponseConfig.successStatusValue = reader.getString();
                } else if ("isGzipCompressed".equals(fieldName)) {
                    deserializedCcpResponseConfig.isGzipCompressed = reader.getNullable(JsonReader::getBoolean);
                } else if ("compressionAlgo".equals(fieldName)) {
                    deserializedCcpResponseConfig.compressionAlgo = reader.getString();
                } else if ("format".equals(fieldName)) {
                    deserializedCcpResponseConfig.format = reader.getString();
                } else if ("csvDelimiter".equals(fieldName)) {
                    deserializedCcpResponseConfig.csvDelimiter = reader.getString();
                } else if ("hasCsvBoundary".equals(fieldName)) {
                    deserializedCcpResponseConfig.hasCsvBoundary = reader.getNullable(JsonReader::getBoolean);
                } else if ("hasCsvHeader".equals(fieldName)) {
                    deserializedCcpResponseConfig.hasCsvHeader = reader.getNullable(JsonReader::getBoolean);
                } else if ("convertChildPropertiesToArray".equals(fieldName)) {
                    deserializedCcpResponseConfig.convertChildPropertiesToArray
                        = reader.getNullable(JsonReader::getBoolean);
                } else if ("csvEscape".equals(fieldName)) {
                    deserializedCcpResponseConfig.csvEscape = reader.getString();
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedCcpResponseConfig;
        });
    }
}
