// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.ai.language.conversations.authoring.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * Represents an entity with its components.
 */
@Fluent
public final class AnalyzeConversationAuthoringConversationExportedEntity
    implements JsonSerializable<AnalyzeConversationAuthoringConversationExportedEntity> {
    /*
     * The category of the entity.
     */
    @Generated
    private final String category;

    /*
     * The behavior to follow when the entity's components overlap with each other.
     */
    @Generated
    private CompositionSetting compositionSetting;

    /*
     * The list component of the entity.
     */
    @Generated
    private AnalyzeConversationAuthoringExportedEntityList list;

    /*
     * The prebuilt entities components.
     */
    @Generated
    private List<AnalyzeConversationAuthoringExportedPrebuiltEntity> prebuilts;

    /*
     * The regex component of the entity.
     */
    @Generated
    private AnalyzeConversationAuthoringExportedEntityRegex regex;

    /*
     * The required components. Allowed values are 'learned', 'list', 'prebuilts' and 'regex'.
     */
    @Generated
    private List<String> requiredComponents;

    /**
     * Creates an instance of AnalyzeConversationAuthoringConversationExportedEntity class.
     * 
     * @param category the category value to set.
     */
    @Generated
    public AnalyzeConversationAuthoringConversationExportedEntity(String category) {
        this.category = category;
    }

    /**
     * Get the category property: The category of the entity.
     * 
     * @return the category value.
     */
    @Generated
    public String getCategory() {
        return this.category;
    }

    /**
     * Get the compositionSetting property: The behavior to follow when the entity's components overlap with each other.
     * 
     * @return the compositionSetting value.
     */
    @Generated
    public CompositionSetting getCompositionSetting() {
        return this.compositionSetting;
    }

    /**
     * Set the compositionSetting property: The behavior to follow when the entity's components overlap with each other.
     * 
     * @param compositionSetting the compositionSetting value to set.
     * @return the AnalyzeConversationAuthoringConversationExportedEntity object itself.
     */
    @Generated
    public AnalyzeConversationAuthoringConversationExportedEntity
        setCompositionSetting(CompositionSetting compositionSetting) {
        this.compositionSetting = compositionSetting;
        return this;
    }

    /**
     * Get the list property: The list component of the entity.
     * 
     * @return the list value.
     */
    @Generated
    public AnalyzeConversationAuthoringExportedEntityList getList() {
        return this.list;
    }

    /**
     * Set the list property: The list component of the entity.
     * 
     * @param list the list value to set.
     * @return the AnalyzeConversationAuthoringConversationExportedEntity object itself.
     */
    @Generated
    public AnalyzeConversationAuthoringConversationExportedEntity
        setList(AnalyzeConversationAuthoringExportedEntityList list) {
        this.list = list;
        return this;
    }

    /**
     * Get the prebuilts property: The prebuilt entities components.
     * 
     * @return the prebuilts value.
     */
    @Generated
    public List<AnalyzeConversationAuthoringExportedPrebuiltEntity> getPrebuilts() {
        return this.prebuilts;
    }

    /**
     * Set the prebuilts property: The prebuilt entities components.
     * 
     * @param prebuilts the prebuilts value to set.
     * @return the AnalyzeConversationAuthoringConversationExportedEntity object itself.
     */
    @Generated
    public AnalyzeConversationAuthoringConversationExportedEntity
        setPrebuilts(List<AnalyzeConversationAuthoringExportedPrebuiltEntity> prebuilts) {
        this.prebuilts = prebuilts;
        return this;
    }

    /**
     * Get the regex property: The regex component of the entity.
     * 
     * @return the regex value.
     */
    @Generated
    public AnalyzeConversationAuthoringExportedEntityRegex getRegex() {
        return this.regex;
    }

    /**
     * Set the regex property: The regex component of the entity.
     * 
     * @param regex the regex value to set.
     * @return the AnalyzeConversationAuthoringConversationExportedEntity object itself.
     */
    @Generated
    public AnalyzeConversationAuthoringConversationExportedEntity
        setRegex(AnalyzeConversationAuthoringExportedEntityRegex regex) {
        this.regex = regex;
        return this;
    }

    /**
     * Get the requiredComponents property: The required components. Allowed values are 'learned', 'list', 'prebuilts'
     * and 'regex'.
     * 
     * @return the requiredComponents value.
     */
    @Generated
    public List<String> getRequiredComponents() {
        return this.requiredComponents;
    }

    /**
     * Set the requiredComponents property: The required components. Allowed values are 'learned', 'list', 'prebuilts'
     * and 'regex'.
     * 
     * @param requiredComponents the requiredComponents value to set.
     * @return the AnalyzeConversationAuthoringConversationExportedEntity object itself.
     */
    @Generated
    public AnalyzeConversationAuthoringConversationExportedEntity
        setRequiredComponents(List<String> requiredComponents) {
        this.requiredComponents = requiredComponents;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("category", this.category);
        jsonWriter.writeStringField("compositionSetting",
            this.compositionSetting == null ? null : this.compositionSetting.toString());
        jsonWriter.writeJsonField("list", this.list);
        jsonWriter.writeArrayField("prebuilts", this.prebuilts, (writer, element) -> writer.writeJson(element));
        jsonWriter.writeJsonField("regex", this.regex);
        jsonWriter.writeArrayField("requiredComponents", this.requiredComponents,
            (writer, element) -> writer.writeString(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of AnalyzeConversationAuthoringConversationExportedEntity from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of AnalyzeConversationAuthoringConversationExportedEntity if the JsonReader was pointing to
     * an instance of it, or null if it was pointing to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the AnalyzeConversationAuthoringConversationExportedEntity.
     */
    @Generated
    public static AnalyzeConversationAuthoringConversationExportedEntity fromJson(JsonReader jsonReader)
        throws IOException {
        return jsonReader.readObject(reader -> {
            String category = null;
            CompositionSetting compositionSetting = null;
            AnalyzeConversationAuthoringExportedEntityList list = null;
            List<AnalyzeConversationAuthoringExportedPrebuiltEntity> prebuilts = null;
            AnalyzeConversationAuthoringExportedEntityRegex regex = null;
            List<String> requiredComponents = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("category".equals(fieldName)) {
                    category = reader.getString();
                } else if ("compositionSetting".equals(fieldName)) {
                    compositionSetting = CompositionSetting.fromString(reader.getString());
                } else if ("list".equals(fieldName)) {
                    list = AnalyzeConversationAuthoringExportedEntityList.fromJson(reader);
                } else if ("prebuilts".equals(fieldName)) {
                    prebuilts = reader
                        .readArray(reader1 -> AnalyzeConversationAuthoringExportedPrebuiltEntity.fromJson(reader1));
                } else if ("regex".equals(fieldName)) {
                    regex = AnalyzeConversationAuthoringExportedEntityRegex.fromJson(reader);
                } else if ("requiredComponents".equals(fieldName)) {
                    requiredComponents = reader.readArray(reader1 -> reader1.getString());
                } else {
                    reader.skipChildren();
                }
            }
            AnalyzeConversationAuthoringConversationExportedEntity deserializedAnalyzeConversationAuthoringConversationExportedEntity
                = new AnalyzeConversationAuthoringConversationExportedEntity(category);
            deserializedAnalyzeConversationAuthoringConversationExportedEntity.compositionSetting = compositionSetting;
            deserializedAnalyzeConversationAuthoringConversationExportedEntity.list = list;
            deserializedAnalyzeConversationAuthoringConversationExportedEntity.prebuilts = prebuilts;
            deserializedAnalyzeConversationAuthoringConversationExportedEntity.regex = regex;
            deserializedAnalyzeConversationAuthoringConversationExportedEntity.requiredComponents = requiredComponents;

            return deserializedAnalyzeConversationAuthoringConversationExportedEntity;
        });
    }
}
