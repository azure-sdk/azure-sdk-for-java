// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.microsoft.agricultureplatform.models;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.Immutable;
import com.azure.core.util.BinaryData;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * Schema of weather data.
 */
@Immutable
public final class WeatherData implements JsonSerializable<WeatherData> {
    /*
     * A collection of key value pairs that belongs to the resource. Each pair must
     * not have a key greater than 50 characters and must not have a value greater
     * than 250 characters. Note: A maximum of 100 key value pairs can be provided for
     * a resource and only string and numeral values are supported.
     */
    @Generated
    private Map<String, BinaryData> additionalAttributes;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures wetBulbTemperature;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures cloudCover;

    /*
     * Day of week.
     */
    @Generated
    private List<String> dayOfWeek;

    /*
     * This data field indicates whether it is daytime or nighttime based on the Local
     * Apparent Time of the location.
     */
    @Generated
    private List<String> dayOrNight;

    /*
     * Expiration time in Utc format.
     */
    @Generated
    private List<String> expirationTime;

    /*
     * This number is the key to the weather icon lookup. The data field shows the
     * icon number that is matched to represent the observed weather conditions.
     */
    @Generated
    private List<Integer> iconCode;

    /*
     * Code representing full set sensible weather.
     */
    @Generated
    private List<Integer> iconCodeExtend;

    /*
     * Indicates whether there is precipitation or not.
     */
    @Generated
    private List<Boolean> hasPrecipitation;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures pressureMeanSeaLevel;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures relativeHumidity;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures temperature;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures temperatureDewPoint;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures temperatureFeelsLike;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures temperatureHeatIndex;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures temperatureWindChill;

    /*
     * The UV Index Description which complements the UV Index value by providing an
     * associated level of risk of skin damage due to exposure (-2 = Not Available, -1
     * = No Report, 0 to 2 = Low, 3 to 5 = Moderate, 6 to 7 = High, 8 to 10 = Very
     * High, 11 to 16 = Extreme).
     */
    @Generated
    private List<String> uvDescription;

    /*
     * Hourly maximum UV index.
     */
    @Generated
    private List<Double> uvIndex;

    /*
     * Time forecast is valid in local apparent time.
     */
    @Generated
    private List<String> validTimeLocal;

    /*
     * Time forecast is valid in Utc format.
     */
    @Generated
    private List<String> validTime;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures visibility;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures windDirection;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures windGust;

    /*
     * Schema for storing measurement readings and unit.
     */
    @Generated
    private Measures windSpeed;

    /*
     * Hourly sensible weather phrase containing longer description.
     */
    @Generated
    private List<String> wxPhraseLong;

    /*
     * Hourly sensible weather phrase containing short description.
     */
    @Generated
    private List<String> wxPhraseShort;

    /**
     * Creates an instance of WeatherData class.
     */
    @Generated
    private WeatherData() {
    }

    /**
     * Get the additionalAttributes property: A collection of key value pairs that belongs to the resource. Each pair
     * must
     * not have a key greater than 50 characters and must not have a value greater
     * than 250 characters. Note: A maximum of 100 key value pairs can be provided for
     * a resource and only string and numeral values are supported.
     * 
     * @return the additionalAttributes value.
     */
    @Generated
    public Map<String, BinaryData> getAdditionalAttributes() {
        return this.additionalAttributes;
    }

    /**
     * Get the wetBulbTemperature property: Schema for storing measurement readings and unit.
     * 
     * @return the wetBulbTemperature value.
     */
    @Generated
    public Measures getWetBulbTemperature() {
        return this.wetBulbTemperature;
    }

    /**
     * Get the cloudCover property: Schema for storing measurement readings and unit.
     * 
     * @return the cloudCover value.
     */
    @Generated
    public Measures getCloudCover() {
        return this.cloudCover;
    }

    /**
     * Get the dayOfWeek property: Day of week.
     * 
     * @return the dayOfWeek value.
     */
    @Generated
    public List<String> getDayOfWeek() {
        return this.dayOfWeek;
    }

    /**
     * Get the dayOrNight property: This data field indicates whether it is daytime or nighttime based on the Local
     * Apparent Time of the location.
     * 
     * @return the dayOrNight value.
     */
    @Generated
    public List<String> getDayOrNight() {
        return this.dayOrNight;
    }

    /**
     * Get the expirationTime property: Expiration time in Utc format.
     * 
     * @return the expirationTime value.
     */
    @Generated
    public List<String> getExpirationTime() {
        return this.expirationTime;
    }

    /**
     * Get the iconCode property: This number is the key to the weather icon lookup. The data field shows the
     * icon number that is matched to represent the observed weather conditions.
     * 
     * @return the iconCode value.
     */
    @Generated
    public List<Integer> getIconCode() {
        return this.iconCode;
    }

    /**
     * Get the iconCodeExtend property: Code representing full set sensible weather.
     * 
     * @return the iconCodeExtend value.
     */
    @Generated
    public List<Integer> getIconCodeExtend() {
        return this.iconCodeExtend;
    }

    /**
     * Get the hasPrecipitation property: Indicates whether there is precipitation or not.
     * 
     * @return the hasPrecipitation value.
     */
    @Generated
    public List<Boolean> getHasPrecipitation() {
        return this.hasPrecipitation;
    }

    /**
     * Get the pressureMeanSeaLevel property: Schema for storing measurement readings and unit.
     * 
     * @return the pressureMeanSeaLevel value.
     */
    @Generated
    public Measures getPressureMeanSeaLevel() {
        return this.pressureMeanSeaLevel;
    }

    /**
     * Get the relativeHumidity property: Schema for storing measurement readings and unit.
     * 
     * @return the relativeHumidity value.
     */
    @Generated
    public Measures getRelativeHumidity() {
        return this.relativeHumidity;
    }

    /**
     * Get the temperature property: Schema for storing measurement readings and unit.
     * 
     * @return the temperature value.
     */
    @Generated
    public Measures getTemperature() {
        return this.temperature;
    }

    /**
     * Get the temperatureDewPoint property: Schema for storing measurement readings and unit.
     * 
     * @return the temperatureDewPoint value.
     */
    @Generated
    public Measures getTemperatureDewPoint() {
        return this.temperatureDewPoint;
    }

    /**
     * Get the temperatureFeelsLike property: Schema for storing measurement readings and unit.
     * 
     * @return the temperatureFeelsLike value.
     */
    @Generated
    public Measures getTemperatureFeelsLike() {
        return this.temperatureFeelsLike;
    }

    /**
     * Get the temperatureHeatIndex property: Schema for storing measurement readings and unit.
     * 
     * @return the temperatureHeatIndex value.
     */
    @Generated
    public Measures getTemperatureHeatIndex() {
        return this.temperatureHeatIndex;
    }

    /**
     * Get the temperatureWindChill property: Schema for storing measurement readings and unit.
     * 
     * @return the temperatureWindChill value.
     */
    @Generated
    public Measures getTemperatureWindChill() {
        return this.temperatureWindChill;
    }

    /**
     * Get the uvDescription property: The UV Index Description which complements the UV Index value by providing an
     * associated level of risk of skin damage due to exposure (-2 = Not Available, -1
     * = No Report, 0 to 2 = Low, 3 to 5 = Moderate, 6 to 7 = High, 8 to 10 = Very
     * High, 11 to 16 = Extreme).
     * 
     * @return the uvDescription value.
     */
    @Generated
    public List<String> getUvDescription() {
        return this.uvDescription;
    }

    /**
     * Get the uvIndex property: Hourly maximum UV index.
     * 
     * @return the uvIndex value.
     */
    @Generated
    public List<Double> getUvIndex() {
        return this.uvIndex;
    }

    /**
     * Get the validTimeLocal property: Time forecast is valid in local apparent time.
     * 
     * @return the validTimeLocal value.
     */
    @Generated
    public List<String> getValidTimeLocal() {
        return this.validTimeLocal;
    }

    /**
     * Get the validTime property: Time forecast is valid in Utc format.
     * 
     * @return the validTime value.
     */
    @Generated
    public List<String> getValidTime() {
        return this.validTime;
    }

    /**
     * Get the visibility property: Schema for storing measurement readings and unit.
     * 
     * @return the visibility value.
     */
    @Generated
    public Measures getVisibility() {
        return this.visibility;
    }

    /**
     * Get the windDirection property: Schema for storing measurement readings and unit.
     * 
     * @return the windDirection value.
     */
    @Generated
    public Measures getWindDirection() {
        return this.windDirection;
    }

    /**
     * Get the windGust property: Schema for storing measurement readings and unit.
     * 
     * @return the windGust value.
     */
    @Generated
    public Measures getWindGust() {
        return this.windGust;
    }

    /**
     * Get the windSpeed property: Schema for storing measurement readings and unit.
     * 
     * @return the windSpeed value.
     */
    @Generated
    public Measures getWindSpeed() {
        return this.windSpeed;
    }

    /**
     * Get the wxPhraseLong property: Hourly sensible weather phrase containing longer description.
     * 
     * @return the wxPhraseLong value.
     */
    @Generated
    public List<String> getWxPhraseLong() {
        return this.wxPhraseLong;
    }

    /**
     * Get the wxPhraseShort property: Hourly sensible weather phrase containing short description.
     * 
     * @return the wxPhraseShort value.
     */
    @Generated
    public List<String> getWxPhraseShort() {
        return this.wxPhraseShort;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeMapField("additionalAttributes", this.additionalAttributes,
            (writer, element) -> writer.writeUntyped(element == null ? null : element.toObject(Object.class)));
        jsonWriter.writeJsonField("wetBulbTemperature", this.wetBulbTemperature);
        jsonWriter.writeJsonField("cloudCover", this.cloudCover);
        jsonWriter.writeArrayField("dayOfWeek", this.dayOfWeek, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("dayOrNight", this.dayOrNight, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("expirationTime", this.expirationTime,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("iconCode", this.iconCode, (writer, element) -> writer.writeInt(element));
        jsonWriter.writeArrayField("iconCodeExtend", this.iconCodeExtend,
            (writer, element) -> writer.writeInt(element));
        jsonWriter.writeArrayField("hasPrecipitation", this.hasPrecipitation,
            (writer, element) -> writer.writeBoolean(element));
        jsonWriter.writeJsonField("pressureMeanSeaLevel", this.pressureMeanSeaLevel);
        jsonWriter.writeJsonField("relativeHumidity", this.relativeHumidity);
        jsonWriter.writeJsonField("temperature", this.temperature);
        jsonWriter.writeJsonField("temperatureDewPoint", this.temperatureDewPoint);
        jsonWriter.writeJsonField("temperatureFeelsLike", this.temperatureFeelsLike);
        jsonWriter.writeJsonField("temperatureHeatIndex", this.temperatureHeatIndex);
        jsonWriter.writeJsonField("temperatureWindChill", this.temperatureWindChill);
        jsonWriter.writeArrayField("uvDescription", this.uvDescription,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("uvIndex", this.uvIndex, (writer, element) -> writer.writeDouble(element));
        jsonWriter.writeArrayField("validTimeLocal", this.validTimeLocal,
            (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("validTime", this.validTime, (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("visibility", this.visibility);
        jsonWriter.writeJsonField("windDirection", this.windDirection);
        jsonWriter.writeJsonField("windGust", this.windGust);
        jsonWriter.writeJsonField("windSpeed", this.windSpeed);
        jsonWriter.writeArrayField("wxPhraseLong", this.wxPhraseLong, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("wxPhraseShort", this.wxPhraseShort,
            (writer, element) -> writer.writeString(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of WeatherData from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of WeatherData if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the WeatherData.
     */
    @Generated
    public static WeatherData fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            WeatherData deserializedWeatherData = new WeatherData();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("additionalAttributes".equals(fieldName)) {
                    Map<String, BinaryData> additionalAttributes = reader.readMap(reader1 -> reader1
                        .getNullable(nonNullReader -> BinaryData.fromObject(nonNullReader.readUntyped())));
                    deserializedWeatherData.additionalAttributes = additionalAttributes;
                } else if ("wetBulbTemperature".equals(fieldName)) {
                    deserializedWeatherData.wetBulbTemperature = Measures.fromJson(reader);
                } else if ("cloudCover".equals(fieldName)) {
                    deserializedWeatherData.cloudCover = Measures.fromJson(reader);
                } else if ("dayOfWeek".equals(fieldName)) {
                    List<String> dayOfWeek = reader.readArray(reader1 -> reader1.getString());
                    deserializedWeatherData.dayOfWeek = dayOfWeek;
                } else if ("dayOrNight".equals(fieldName)) {
                    List<String> dayOrNight = reader.readArray(reader1 -> reader1.getString());
                    deserializedWeatherData.dayOrNight = dayOrNight;
                } else if ("expirationTime".equals(fieldName)) {
                    List<String> expirationTime = reader.readArray(reader1 -> reader1.getString());
                    deserializedWeatherData.expirationTime = expirationTime;
                } else if ("iconCode".equals(fieldName)) {
                    List<Integer> iconCode = reader.readArray(reader1 -> reader1.getInt());
                    deserializedWeatherData.iconCode = iconCode;
                } else if ("iconCodeExtend".equals(fieldName)) {
                    List<Integer> iconCodeExtend = reader.readArray(reader1 -> reader1.getInt());
                    deserializedWeatherData.iconCodeExtend = iconCodeExtend;
                } else if ("hasPrecipitation".equals(fieldName)) {
                    List<Boolean> hasPrecipitation = reader.readArray(reader1 -> reader1.getBoolean());
                    deserializedWeatherData.hasPrecipitation = hasPrecipitation;
                } else if ("pressureMeanSeaLevel".equals(fieldName)) {
                    deserializedWeatherData.pressureMeanSeaLevel = Measures.fromJson(reader);
                } else if ("relativeHumidity".equals(fieldName)) {
                    deserializedWeatherData.relativeHumidity = Measures.fromJson(reader);
                } else if ("temperature".equals(fieldName)) {
                    deserializedWeatherData.temperature = Measures.fromJson(reader);
                } else if ("temperatureDewPoint".equals(fieldName)) {
                    deserializedWeatherData.temperatureDewPoint = Measures.fromJson(reader);
                } else if ("temperatureFeelsLike".equals(fieldName)) {
                    deserializedWeatherData.temperatureFeelsLike = Measures.fromJson(reader);
                } else if ("temperatureHeatIndex".equals(fieldName)) {
                    deserializedWeatherData.temperatureHeatIndex = Measures.fromJson(reader);
                } else if ("temperatureWindChill".equals(fieldName)) {
                    deserializedWeatherData.temperatureWindChill = Measures.fromJson(reader);
                } else if ("uvDescription".equals(fieldName)) {
                    List<String> uvDescription = reader.readArray(reader1 -> reader1.getString());
                    deserializedWeatherData.uvDescription = uvDescription;
                } else if ("uvIndex".equals(fieldName)) {
                    List<Double> uvIndex = reader.readArray(reader1 -> reader1.getDouble());
                    deserializedWeatherData.uvIndex = uvIndex;
                } else if ("validTimeLocal".equals(fieldName)) {
                    List<String> validTimeLocal = reader.readArray(reader1 -> reader1.getString());
                    deserializedWeatherData.validTimeLocal = validTimeLocal;
                } else if ("validTime".equals(fieldName)) {
                    List<String> validTime = reader.readArray(reader1 -> reader1.getString());
                    deserializedWeatherData.validTime = validTime;
                } else if ("visibility".equals(fieldName)) {
                    deserializedWeatherData.visibility = Measures.fromJson(reader);
                } else if ("windDirection".equals(fieldName)) {
                    deserializedWeatherData.windDirection = Measures.fromJson(reader);
                } else if ("windGust".equals(fieldName)) {
                    deserializedWeatherData.windGust = Measures.fromJson(reader);
                } else if ("windSpeed".equals(fieldName)) {
                    deserializedWeatherData.windSpeed = Measures.fromJson(reader);
                } else if ("wxPhraseLong".equals(fieldName)) {
                    List<String> wxPhraseLong = reader.readArray(reader1 -> reader1.getString());
                    deserializedWeatherData.wxPhraseLong = wxPhraseLong;
                } else if ("wxPhraseShort".equals(fieldName)) {
                    List<String> wxPhraseShort = reader.readArray(reader1 -> reader1.getString());
                    deserializedWeatherData.wxPhraseShort = wxPhraseShort;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedWeatherData;
        });
    }
}
