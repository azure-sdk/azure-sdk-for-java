// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.microsoft.agricultureplatform.implementation.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import com.microsoft.agricultureplatform.models.GeoJsonObject;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

/**
 * The SearchAcrossCollectionRequest model.
 */
@Fluent
public final class SearchAcrossCollectionRequest implements JsonSerializable<SearchAcrossCollectionRequest> {
    /*
     * Owner Item Ids of the resource.
     */
    @Generated
    private List<String> ownerItemIds;

    /*
     * Filters on key-value pairs within the Data object.
     * e.g. "{testKey} eq {testValue}".
     */
    @Generated
    private List<String> dataFilters;

    /*
     * GeoJSON (For more details: https://geojson.org/). Note: Coordinates are
     * expected in [Longitude, Latitude] format.
     */
    @Generated
    private GeoJsonObject intersectsWithGeometry;

    /*
     * Ids of the resource.
     */
    @Generated
    private List<String> ids;

    /*
     * Minimum creation date of resource (inclusive).
     */
    @Generated
    private OffsetDateTime minCreatedDateTime;

    /*
     * Maximum creation date of resource (inclusive).
     */
    @Generated
    private OffsetDateTime maxCreatedDateTime;

    /*
     * Minimum last modified date of resource (inclusive).
     */
    @Generated
    private OffsetDateTime minLastModifiedDateTime;

    /*
     * Maximum last modified date of resource (inclusive).
     */
    @Generated
    private OffsetDateTime maxLastModifiedDateTime;

    /*
     * Maximum number of items needed (inclusive).
     * Minimum = 10, Maximum = 1000, Default value = 50.
     */
    @Generated
    private Integer maxPageSize;

    /*
     * Skip token for getting next set of results.
     */
    @Generated
    private String skipToken;

    /*
     * Owner Item Ids of the resource.
     */
    @Generated
    private List<String> collectionIds;

    /**
     * Creates an instance of SearchAcrossCollectionRequest class.
     */
    @Generated
    public SearchAcrossCollectionRequest() {
    }

    /**
     * Get the ownerItemIds property: Owner Item Ids of the resource.
     * 
     * @return the ownerItemIds value.
     */
    @Generated
    public List<String> getOwnerItemIds() {
        return this.ownerItemIds;
    }

    /**
     * Set the ownerItemIds property: Owner Item Ids of the resource.
     * 
     * @param ownerItemIds the ownerItemIds value to set.
     * @return the SearchAcrossCollectionRequest object itself.
     */
    @Generated
    public SearchAcrossCollectionRequest setOwnerItemIds(List<String> ownerItemIds) {
        this.ownerItemIds = ownerItemIds;
        return this;
    }

    /**
     * Get the dataFilters property: Filters on key-value pairs within the Data object.
     * e.g. "{testKey} eq {testValue}".
     * 
     * @return the dataFilters value.
     */
    @Generated
    public List<String> getDataFilters() {
        return this.dataFilters;
    }

    /**
     * Set the dataFilters property: Filters on key-value pairs within the Data object.
     * e.g. "{testKey} eq {testValue}".
     * 
     * @param dataFilters the dataFilters value to set.
     * @return the SearchAcrossCollectionRequest object itself.
     */
    @Generated
    public SearchAcrossCollectionRequest setDataFilters(List<String> dataFilters) {
        this.dataFilters = dataFilters;
        return this;
    }

    /**
     * Get the intersectsWithGeometry property: GeoJSON (For more details: https://geojson.org/). Note: Coordinates are
     * expected in [Longitude, Latitude] format.
     * 
     * @return the intersectsWithGeometry value.
     */
    @Generated
    public GeoJsonObject getIntersectsWithGeometry() {
        return this.intersectsWithGeometry;
    }

    /**
     * Set the intersectsWithGeometry property: GeoJSON (For more details: https://geojson.org/). Note: Coordinates are
     * expected in [Longitude, Latitude] format.
     * 
     * @param intersectsWithGeometry the intersectsWithGeometry value to set.
     * @return the SearchAcrossCollectionRequest object itself.
     */
    @Generated
    public SearchAcrossCollectionRequest setIntersectsWithGeometry(GeoJsonObject intersectsWithGeometry) {
        this.intersectsWithGeometry = intersectsWithGeometry;
        return this;
    }

    /**
     * Get the ids property: Ids of the resource.
     * 
     * @return the ids value.
     */
    @Generated
    public List<String> getIds() {
        return this.ids;
    }

    /**
     * Set the ids property: Ids of the resource.
     * 
     * @param ids the ids value to set.
     * @return the SearchAcrossCollectionRequest object itself.
     */
    @Generated
    public SearchAcrossCollectionRequest setIds(List<String> ids) {
        this.ids = ids;
        return this;
    }

    /**
     * Get the minCreatedDateTime property: Minimum creation date of resource (inclusive).
     * 
     * @return the minCreatedDateTime value.
     */
    @Generated
    public OffsetDateTime getMinCreatedDateTime() {
        return this.minCreatedDateTime;
    }

    /**
     * Set the minCreatedDateTime property: Minimum creation date of resource (inclusive).
     * 
     * @param minCreatedDateTime the minCreatedDateTime value to set.
     * @return the SearchAcrossCollectionRequest object itself.
     */
    @Generated
    public SearchAcrossCollectionRequest setMinCreatedDateTime(OffsetDateTime minCreatedDateTime) {
        this.minCreatedDateTime = minCreatedDateTime;
        return this;
    }

    /**
     * Get the maxCreatedDateTime property: Maximum creation date of resource (inclusive).
     * 
     * @return the maxCreatedDateTime value.
     */
    @Generated
    public OffsetDateTime getMaxCreatedDateTime() {
        return this.maxCreatedDateTime;
    }

    /**
     * Set the maxCreatedDateTime property: Maximum creation date of resource (inclusive).
     * 
     * @param maxCreatedDateTime the maxCreatedDateTime value to set.
     * @return the SearchAcrossCollectionRequest object itself.
     */
    @Generated
    public SearchAcrossCollectionRequest setMaxCreatedDateTime(OffsetDateTime maxCreatedDateTime) {
        this.maxCreatedDateTime = maxCreatedDateTime;
        return this;
    }

    /**
     * Get the minLastModifiedDateTime property: Minimum last modified date of resource (inclusive).
     * 
     * @return the minLastModifiedDateTime value.
     */
    @Generated
    public OffsetDateTime getMinLastModifiedDateTime() {
        return this.minLastModifiedDateTime;
    }

    /**
     * Set the minLastModifiedDateTime property: Minimum last modified date of resource (inclusive).
     * 
     * @param minLastModifiedDateTime the minLastModifiedDateTime value to set.
     * @return the SearchAcrossCollectionRequest object itself.
     */
    @Generated
    public SearchAcrossCollectionRequest setMinLastModifiedDateTime(OffsetDateTime minLastModifiedDateTime) {
        this.minLastModifiedDateTime = minLastModifiedDateTime;
        return this;
    }

    /**
     * Get the maxLastModifiedDateTime property: Maximum last modified date of resource (inclusive).
     * 
     * @return the maxLastModifiedDateTime value.
     */
    @Generated
    public OffsetDateTime getMaxLastModifiedDateTime() {
        return this.maxLastModifiedDateTime;
    }

    /**
     * Set the maxLastModifiedDateTime property: Maximum last modified date of resource (inclusive).
     * 
     * @param maxLastModifiedDateTime the maxLastModifiedDateTime value to set.
     * @return the SearchAcrossCollectionRequest object itself.
     */
    @Generated
    public SearchAcrossCollectionRequest setMaxLastModifiedDateTime(OffsetDateTime maxLastModifiedDateTime) {
        this.maxLastModifiedDateTime = maxLastModifiedDateTime;
        return this;
    }

    /**
     * Get the maxPageSize property: Maximum number of items needed (inclusive).
     * Minimum = 10, Maximum = 1000, Default value = 50.
     * 
     * @return the maxPageSize value.
     */
    @Generated
    public Integer getMaxPageSize() {
        return this.maxPageSize;
    }

    /**
     * Set the maxPageSize property: Maximum number of items needed (inclusive).
     * Minimum = 10, Maximum = 1000, Default value = 50.
     * 
     * @param maxPageSize the maxPageSize value to set.
     * @return the SearchAcrossCollectionRequest object itself.
     */
    @Generated
    public SearchAcrossCollectionRequest setMaxPageSize(Integer maxPageSize) {
        this.maxPageSize = maxPageSize;
        return this;
    }

    /**
     * Get the skipToken property: Skip token for getting next set of results.
     * 
     * @return the skipToken value.
     */
    @Generated
    public String getSkipToken() {
        return this.skipToken;
    }

    /**
     * Set the skipToken property: Skip token for getting next set of results.
     * 
     * @param skipToken the skipToken value to set.
     * @return the SearchAcrossCollectionRequest object itself.
     */
    @Generated
    public SearchAcrossCollectionRequest setSkipToken(String skipToken) {
        this.skipToken = skipToken;
        return this;
    }

    /**
     * Get the collectionIds property: Owner Item Ids of the resource.
     * 
     * @return the collectionIds value.
     */
    @Generated
    public List<String> getCollectionIds() {
        return this.collectionIds;
    }

    /**
     * Set the collectionIds property: Owner Item Ids of the resource.
     * 
     * @param collectionIds the collectionIds value to set.
     * @return the SearchAcrossCollectionRequest object itself.
     */
    @Generated
    public SearchAcrossCollectionRequest setCollectionIds(List<String> collectionIds) {
        this.collectionIds = collectionIds;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("ownerItemIds", this.ownerItemIds, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("dataFilters", this.dataFilters, (writer, element) -> writer.writeString(element));
        jsonWriter.writeJsonField("intersectsWithGeometry", this.intersectsWithGeometry);
        jsonWriter.writeArrayField("ids", this.ids, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("minCreatedDateTime",
            this.minCreatedDateTime == null
                ? null
                : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.minCreatedDateTime));
        jsonWriter.writeStringField("maxCreatedDateTime",
            this.maxCreatedDateTime == null
                ? null
                : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.maxCreatedDateTime));
        jsonWriter.writeStringField("minLastModifiedDateTime",
            this.minLastModifiedDateTime == null
                ? null
                : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.minLastModifiedDateTime));
        jsonWriter.writeStringField("maxLastModifiedDateTime",
            this.maxLastModifiedDateTime == null
                ? null
                : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.maxLastModifiedDateTime));
        jsonWriter.writeNumberField("maxPageSize", this.maxPageSize);
        jsonWriter.writeStringField("skipToken", this.skipToken);
        jsonWriter.writeArrayField("collectionIds", this.collectionIds,
            (writer, element) -> writer.writeString(element));
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of SearchAcrossCollectionRequest from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of SearchAcrossCollectionRequest if the JsonReader was pointing to an instance of it, or null
     * if it was pointing to JSON null.
     * @throws IOException If an error occurs while reading the SearchAcrossCollectionRequest.
     */
    @Generated
    public static SearchAcrossCollectionRequest fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            SearchAcrossCollectionRequest deserializedSearchAcrossCollectionRequest
                = new SearchAcrossCollectionRequest();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("ownerItemIds".equals(fieldName)) {
                    List<String> ownerItemIds = reader.readArray(reader1 -> reader1.getString());
                    deserializedSearchAcrossCollectionRequest.ownerItemIds = ownerItemIds;
                } else if ("dataFilters".equals(fieldName)) {
                    List<String> dataFilters = reader.readArray(reader1 -> reader1.getString());
                    deserializedSearchAcrossCollectionRequest.dataFilters = dataFilters;
                } else if ("intersectsWithGeometry".equals(fieldName)) {
                    deserializedSearchAcrossCollectionRequest.intersectsWithGeometry = GeoJsonObject.fromJson(reader);
                } else if ("ids".equals(fieldName)) {
                    List<String> ids = reader.readArray(reader1 -> reader1.getString());
                    deserializedSearchAcrossCollectionRequest.ids = ids;
                } else if ("minCreatedDateTime".equals(fieldName)) {
                    deserializedSearchAcrossCollectionRequest.minCreatedDateTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("maxCreatedDateTime".equals(fieldName)) {
                    deserializedSearchAcrossCollectionRequest.maxCreatedDateTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("minLastModifiedDateTime".equals(fieldName)) {
                    deserializedSearchAcrossCollectionRequest.minLastModifiedDateTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("maxLastModifiedDateTime".equals(fieldName)) {
                    deserializedSearchAcrossCollectionRequest.maxLastModifiedDateTime = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("maxPageSize".equals(fieldName)) {
                    deserializedSearchAcrossCollectionRequest.maxPageSize = reader.getNullable(JsonReader::getInt);
                } else if ("skipToken".equals(fieldName)) {
                    deserializedSearchAcrossCollectionRequest.skipToken = reader.getString();
                } else if ("collectionIds".equals(fieldName)) {
                    List<String> collectionIds = reader.readArray(reader1 -> reader1.getString());
                    deserializedSearchAcrossCollectionRequest.collectionIds = collectionIds;
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedSearchAcrossCollectionRequest;
        });
    }
}
