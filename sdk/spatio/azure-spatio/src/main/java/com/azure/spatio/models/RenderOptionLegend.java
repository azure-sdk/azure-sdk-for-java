// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.spatio.models;

import com.azure.core.annotation.Fluent;
import com.azure.core.annotation.Generated;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;

/**
 * An optional legend configuration.TODO: add description for RenderOptionLegend.
 */
@Fluent
public final class RenderOptionLegend implements JsonSerializable<RenderOptionLegend> {
    /*
     * Legend type to make,
     * one of: `continuous`,
     * `classmap`,
     * `interval` or `none`
     * (note, `none` is a string literal).TODO: add description for type
     */
    @Generated
    private LegendConfigType type;

    /*
     * List of string labels that will be flex spaced-between under the legend image.TODO: add description for labels
     */
    @Generated
    private List<String> labels;

    /*
     * The number of items to trim from the start of the legend definition. Used if
     * there are values important for rendering (e.g. nodata) that aren't desirable in
     * the legend.TODO: add description for trimStart
     */
    @Generated
    private Integer trimStart;

    /*
     * Same as trim_start, but for the end of the legend definition.TODO: add description for trimEnd
     */
    @Generated
    private Integer trimEnd;

    /*
     * A factor to multiply interval legend labels by. Useful for scaled rasters whose
     * colormap definitions map to unscaled values, effectively showing legend labels
     * as scaled values.TODO: add description for scaleFactor
     */
    @Generated
    private Double scaleFactor;

    /**
     * Creates an instance of RenderOptionLegend class.
     */
    @Generated
    public RenderOptionLegend() {
    }

    /**
     * Get the type property: Legend type to make,
     * one of: `continuous`,
     * `classmap`,
     * `interval` or `none`
     * (note, `none` is a string literal).TODO: add description for type.
     * 
     * @return the type value.
     */
    @Generated
    public LegendConfigType getType() {
        return this.type;
    }

    /**
     * Set the type property: Legend type to make,
     * one of: `continuous`,
     * `classmap`,
     * `interval` or `none`
     * (note, `none` is a string literal).TODO: add description for type.
     * 
     * @param type the type value to set.
     * @return the RenderOptionLegend object itself.
     */
    @Generated
    public RenderOptionLegend setType(LegendConfigType type) {
        this.type = type;
        return this;
    }

    /**
     * Get the labels property: List of string labels that will be flex spaced-between under the legend image.TODO: add
     * description for labels.
     * 
     * @return the labels value.
     */
    @Generated
    public List<String> getLabels() {
        return this.labels;
    }

    /**
     * Set the labels property: List of string labels that will be flex spaced-between under the legend image.TODO: add
     * description for labels.
     * 
     * @param labels the labels value to set.
     * @return the RenderOptionLegend object itself.
     */
    @Generated
    public RenderOptionLegend setLabels(List<String> labels) {
        this.labels = labels;
        return this;
    }

    /**
     * Get the trimStart property: The number of items to trim from the start of the legend definition. Used if
     * there are values important for rendering (e.g. nodata) that aren't desirable in
     * the legend.TODO: add description for trimStart.
     * 
     * @return the trimStart value.
     */
    @Generated
    public Integer getTrimStart() {
        return this.trimStart;
    }

    /**
     * Set the trimStart property: The number of items to trim from the start of the legend definition. Used if
     * there are values important for rendering (e.g. nodata) that aren't desirable in
     * the legend.TODO: add description for trimStart.
     * 
     * @param trimStart the trimStart value to set.
     * @return the RenderOptionLegend object itself.
     */
    @Generated
    public RenderOptionLegend setTrimStart(Integer trimStart) {
        this.trimStart = trimStart;
        return this;
    }

    /**
     * Get the trimEnd property: Same as trim_start, but for the end of the legend definition.TODO: add description for
     * trimEnd.
     * 
     * @return the trimEnd value.
     */
    @Generated
    public Integer getTrimEnd() {
        return this.trimEnd;
    }

    /**
     * Set the trimEnd property: Same as trim_start, but for the end of the legend definition.TODO: add description for
     * trimEnd.
     * 
     * @param trimEnd the trimEnd value to set.
     * @return the RenderOptionLegend object itself.
     */
    @Generated
    public RenderOptionLegend setTrimEnd(Integer trimEnd) {
        this.trimEnd = trimEnd;
        return this;
    }

    /**
     * Get the scaleFactor property: A factor to multiply interval legend labels by. Useful for scaled rasters whose
     * colormap definitions map to unscaled values, effectively showing legend labels
     * as scaled values.TODO: add description for scaleFactor.
     * 
     * @return the scaleFactor value.
     */
    @Generated
    public Double getScaleFactor() {
        return this.scaleFactor;
    }

    /**
     * Set the scaleFactor property: A factor to multiply interval legend labels by. Useful for scaled rasters whose
     * colormap definitions map to unscaled values, effectively showing legend labels
     * as scaled values.TODO: add description for scaleFactor.
     * 
     * @param scaleFactor the scaleFactor value to set.
     * @return the RenderOptionLegend object itself.
     */
    @Generated
    public RenderOptionLegend setScaleFactor(Double scaleFactor) {
        this.scaleFactor = scaleFactor;
        return this;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("type", this.type == null ? null : this.type.toString());
        jsonWriter.writeArrayField("labels", this.labels, (writer, element) -> writer.writeString(element));
        jsonWriter.writeNumberField("trimStart", this.trimStart);
        jsonWriter.writeNumberField("trimEnd", this.trimEnd);
        jsonWriter.writeNumberField("scaleFactor", this.scaleFactor);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of RenderOptionLegend from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of RenderOptionLegend if the JsonReader was pointing to an instance of it, or null if it was
     * pointing to JSON null.
     * @throws IOException If an error occurs while reading the RenderOptionLegend.
     */
    @Generated
    public static RenderOptionLegend fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            RenderOptionLegend deserializedRenderOptionLegend = new RenderOptionLegend();
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("type".equals(fieldName)) {
                    deserializedRenderOptionLegend.type = LegendConfigType.fromString(reader.getString());
                } else if ("labels".equals(fieldName)) {
                    List<String> labels = reader.readArray(reader1 -> reader1.getString());
                    deserializedRenderOptionLegend.labels = labels;
                } else if ("trimStart".equals(fieldName)) {
                    deserializedRenderOptionLegend.trimStart = reader.getNullable(JsonReader::getInt);
                } else if ("trimEnd".equals(fieldName)) {
                    deserializedRenderOptionLegend.trimEnd = reader.getNullable(JsonReader::getInt);
                } else if ("scaleFactor".equals(fieldName)) {
                    deserializedRenderOptionLegend.scaleFactor = reader.getNullable(JsonReader::getDouble);
                } else {
                    reader.skipChildren();
                }
            }

            return deserializedRenderOptionLegend;
        });
    }
}
