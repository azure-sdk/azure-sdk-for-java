// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.spatio.models;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.Immutable;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.util.List;
import java.util.Map;

/**
 * TilerInfo
 * 
 * Dataset Info.
 */
@Immutable
public final class TilerInfo implements JsonSerializable<TilerInfo> {
    /*
     * Bounds
     */
    @Generated
    private final List<String> bounds;

    /*
     * Band Metadata
     */
    @Generated
    private final List<List<String>> bandMetadata;

    /*
     * Band Descriptions
     */
    @Generated
    private final List<List<String>> bandDescriptions;

    /*
     * Dtype
     * 
     * Band Names
     */
    @Generated
    private final String dtype;

    /*
     * Nodata Type
     * 
     * Band Names
     */
    @Generated
    private final NoDataType nodataType;

    /*
     * Colorinterp
     * 
     * Band Names
     */
    @Generated
    private List<String> colorinterp;

    /*
     * Scales
     * 
     * Band Names
     */
    @Generated
    private List<Long> scales;

    /*
     * Offsets
     * 
     * Band Names
     */
    @Generated
    private List<Long> offsets;

    /*
     * Colormap
     * 
     * Band Names
     */
    @Generated
    private Map<String, List<String>> colormap;

    /*
     * Minzoom
     * 
     * Band Names
     */
    @Generated
    private Long minzoom;

    /*
     * Maxzoom
     * 
     * Band Names
     */
    @Generated
    private Long maxzoom;

    /**
     * Creates an instance of TilerInfo class.
     * 
     * @param bounds the bounds value to set.
     * @param bandMetadata the bandMetadata value to set.
     * @param bandDescriptions the bandDescriptions value to set.
     * @param dtype the dtype value to set.
     * @param nodataType the nodataType value to set.
     */
    @Generated
    private TilerInfo(List<String> bounds, List<List<String>> bandMetadata, List<List<String>> bandDescriptions,
        String dtype, NoDataType nodataType) {
        this.bounds = bounds;
        this.bandMetadata = bandMetadata;
        this.bandDescriptions = bandDescriptions;
        this.dtype = dtype;
        this.nodataType = nodataType;
    }

    /**
     * Get the bounds property: Bounds.
     * 
     * @return the bounds value.
     */
    @Generated
    public List<String> getBounds() {
        return this.bounds;
    }

    /**
     * Get the bandMetadata property: Band Metadata.
     * 
     * @return the bandMetadata value.
     */
    @Generated
    public List<List<String>> getBandMetadata() {
        return this.bandMetadata;
    }

    /**
     * Get the bandDescriptions property: Band Descriptions.
     * 
     * @return the bandDescriptions value.
     */
    @Generated
    public List<List<String>> getBandDescriptions() {
        return this.bandDescriptions;
    }

    /**
     * Get the dtype property: Dtype
     * 
     * Band Names.
     * 
     * @return the dtype value.
     */
    @Generated
    public String getDtype() {
        return this.dtype;
    }

    /**
     * Get the nodataType property: Nodata Type
     * 
     * Band Names.
     * 
     * @return the nodataType value.
     */
    @Generated
    public NoDataType getNodataType() {
        return this.nodataType;
    }

    /**
     * Get the colorinterp property: Colorinterp
     * 
     * Band Names.
     * 
     * @return the colorinterp value.
     */
    @Generated
    public List<String> getColorinterp() {
        return this.colorinterp;
    }

    /**
     * Get the scales property: Scales
     * 
     * Band Names.
     * 
     * @return the scales value.
     */
    @Generated
    public List<Long> getScales() {
        return this.scales;
    }

    /**
     * Get the offsets property: Offsets
     * 
     * Band Names.
     * 
     * @return the offsets value.
     */
    @Generated
    public List<Long> getOffsets() {
        return this.offsets;
    }

    /**
     * Get the colormap property: Colormap
     * 
     * Band Names.
     * 
     * @return the colormap value.
     */
    @Generated
    public Map<String, List<String>> getColormap() {
        return this.colormap;
    }

    /**
     * Get the minzoom property: Minzoom
     * 
     * Band Names.
     * 
     * @return the minzoom value.
     */
    @Generated
    public Long getMinzoom() {
        return this.minzoom;
    }

    /**
     * Get the maxzoom property: Maxzoom
     * 
     * Band Names.
     * 
     * @return the maxzoom value.
     */
    @Generated
    public Long getMaxzoom() {
        return this.maxzoom;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeArrayField("bounds", this.bounds, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("bandMetadata", this.bandMetadata,
            (writer, element) -> writer.writeArray(element, (writer1, element1) -> writer1.writeString(element1)));
        jsonWriter.writeArrayField("bandDescriptions", this.bandDescriptions,
            (writer, element) -> writer.writeArray(element, (writer1, element1) -> writer1.writeString(element1)));
        jsonWriter.writeStringField("dtype", this.dtype);
        jsonWriter.writeStringField("nodataType", this.nodataType == null ? null : this.nodataType.toString());
        jsonWriter.writeArrayField("colorinterp", this.colorinterp, (writer, element) -> writer.writeString(element));
        jsonWriter.writeArrayField("scales", this.scales, (writer, element) -> writer.writeLong(element));
        jsonWriter.writeArrayField("offsets", this.offsets, (writer, element) -> writer.writeLong(element));
        jsonWriter.writeMapField("colormap", this.colormap,
            (writer, element) -> writer.writeArray(element, (writer1, element1) -> writer1.writeString(element1)));
        jsonWriter.writeNumberField("minzoom", this.minzoom);
        jsonWriter.writeNumberField("maxzoom", this.maxzoom);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of TilerInfo from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of TilerInfo if the JsonReader was pointing to an instance of it, or null if it was pointing
     * to JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the TilerInfo.
     */
    @Generated
    public static TilerInfo fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            List<String> bounds = null;
            List<List<String>> bandMetadata = null;
            List<List<String>> bandDescriptions = null;
            String dtype = null;
            NoDataType nodataType = null;
            List<String> colorinterp = null;
            List<Long> scales = null;
            List<Long> offsets = null;
            Map<String, List<String>> colormap = null;
            Long minzoom = null;
            Long maxzoom = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("bounds".equals(fieldName)) {
                    bounds = reader.readArray(reader1 -> reader1.getString());
                } else if ("bandMetadata".equals(fieldName)) {
                    bandMetadata = reader.readArray(reader1 -> reader1.readArray(reader2 -> reader2.getString()));
                } else if ("bandDescriptions".equals(fieldName)) {
                    bandDescriptions = reader.readArray(reader1 -> reader1.readArray(reader2 -> reader2.getString()));
                } else if ("dtype".equals(fieldName)) {
                    dtype = reader.getString();
                } else if ("nodataType".equals(fieldName)) {
                    nodataType = NoDataType.fromString(reader.getString());
                } else if ("colorinterp".equals(fieldName)) {
                    colorinterp = reader.readArray(reader1 -> reader1.getString());
                } else if ("scales".equals(fieldName)) {
                    scales = reader.readArray(reader1 -> reader1.getLong());
                } else if ("offsets".equals(fieldName)) {
                    offsets = reader.readArray(reader1 -> reader1.getLong());
                } else if ("colormap".equals(fieldName)) {
                    colormap = reader.readMap(reader1 -> reader1.readArray(reader2 -> reader2.getString()));
                } else if ("minzoom".equals(fieldName)) {
                    minzoom = reader.getNullable(JsonReader::getLong);
                } else if ("maxzoom".equals(fieldName)) {
                    maxzoom = reader.getNullable(JsonReader::getLong);
                } else {
                    reader.skipChildren();
                }
            }
            TilerInfo deserializedTilerInfo = new TilerInfo(bounds, bandMetadata, bandDescriptions, dtype, nodataType);
            deserializedTilerInfo.colorinterp = colorinterp;
            deserializedTilerInfo.scales = scales;
            deserializedTilerInfo.offsets = offsets;
            deserializedTilerInfo.colormap = colormap;
            deserializedTilerInfo.minzoom = minzoom;
            deserializedTilerInfo.maxzoom = maxzoom;

            return deserializedTilerInfo;
        });
    }
}
