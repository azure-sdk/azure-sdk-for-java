// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// Code generated by Microsoft (R) TypeSpec Code Generator.

package com.azure.spatio.models;

import com.azure.core.annotation.Generated;
import com.azure.core.annotation.Immutable;
import com.azure.core.util.CoreUtils;
import com.azure.json.JsonReader;
import com.azure.json.JsonSerializable;
import com.azure.json.JsonToken;
import com.azure.json.JsonWriter;
import java.io.IOException;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;

/**
 * PgSTAC Search entry.
 * 
 * ref:
 * https://github.com/stac-utils/pgstac/blob/3499daa2bfa700ae7bb07503795c169bf2ebafc7/sql/004_search.sql#L907-L915TODO:
 * add description for Search.
 */
@Immutable
public final class Search implements JsonSerializable<Search> {
    /*
     * HashTODO: add description for hash
     */
    @Generated
    private final String hash;

    /*
     * Search
     */
    @Generated
    private final Map<String, String> search;

    /*
     * WhereTODO: add description for where
     */
    @Generated
    private final String where;

    /*
     * OrderbyTODO: add description for orderby
     */
    @Generated
    private final String orderby;

    /*
     * LastusedTODO: add description for lastused
     */
    @Generated
    private final OffsetDateTime lastused;

    /*
     * UsecountTODO: add description for usecount
     */
    @Generated
    private final int usecount;

    /*
     * Metadata Model.TODO: add description for metadata
     */
    @Generated
    private final Metadata metadata;

    /**
     * Creates an instance of Search class.
     * 
     * @param hash the hash value to set.
     * @param search the search value to set.
     * @param where the where value to set.
     * @param orderby the orderby value to set.
     * @param lastused the lastused value to set.
     * @param usecount the usecount value to set.
     * @param metadata the metadata value to set.
     */
    @Generated
    private Search(String hash, Map<String, String> search, String where, String orderby, OffsetDateTime lastused,
        int usecount, Metadata metadata) {
        this.hash = hash;
        this.search = search;
        this.where = where;
        this.orderby = orderby;
        this.lastused = lastused;
        this.usecount = usecount;
        this.metadata = metadata;
    }

    /**
     * Get the hash property: HashTODO: add description for hash.
     * 
     * @return the hash value.
     */
    @Generated
    public String getHash() {
        return this.hash;
    }

    /**
     * Get the search property: Search.
     * 
     * @return the search value.
     */
    @Generated
    public Map<String, String> getSearch() {
        return this.search;
    }

    /**
     * Get the where property: WhereTODO: add description for where.
     * 
     * @return the where value.
     */
    @Generated
    public String getWhere() {
        return this.where;
    }

    /**
     * Get the orderby property: OrderbyTODO: add description for orderby.
     * 
     * @return the orderby value.
     */
    @Generated
    public String getOrderby() {
        return this.orderby;
    }

    /**
     * Get the lastused property: LastusedTODO: add description for lastused.
     * 
     * @return the lastused value.
     */
    @Generated
    public OffsetDateTime getLastused() {
        return this.lastused;
    }

    /**
     * Get the usecount property: UsecountTODO: add description for usecount.
     * 
     * @return the usecount value.
     */
    @Generated
    public int getUsecount() {
        return this.usecount;
    }

    /**
     * Get the metadata property: Metadata Model.TODO: add description for metadata.
     * 
     * @return the metadata value.
     */
    @Generated
    public Metadata getMetadata() {
        return this.metadata;
    }

    /**
     * {@inheritDoc}
     */
    @Generated
    @Override
    public JsonWriter toJson(JsonWriter jsonWriter) throws IOException {
        jsonWriter.writeStartObject();
        jsonWriter.writeStringField("hash", this.hash);
        jsonWriter.writeMapField("search", this.search, (writer, element) -> writer.writeString(element));
        jsonWriter.writeStringField("_where", this.where);
        jsonWriter.writeStringField("orderby", this.orderby);
        jsonWriter.writeStringField("lastused",
            this.lastused == null ? null : DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(this.lastused));
        jsonWriter.writeIntField("usecount", this.usecount);
        jsonWriter.writeJsonField("metadata", this.metadata);
        return jsonWriter.writeEndObject();
    }

    /**
     * Reads an instance of Search from the JsonReader.
     * 
     * @param jsonReader The JsonReader being read.
     * @return An instance of Search if the JsonReader was pointing to an instance of it, or null if it was pointing to
     * JSON null.
     * @throws IllegalStateException If the deserialized JSON object was missing any required properties.
     * @throws IOException If an error occurs while reading the Search.
     */
    @Generated
    public static Search fromJson(JsonReader jsonReader) throws IOException {
        return jsonReader.readObject(reader -> {
            String hash = null;
            Map<String, String> search = null;
            String where = null;
            String orderby = null;
            OffsetDateTime lastused = null;
            int usecount = 0;
            Metadata metadata = null;
            while (reader.nextToken() != JsonToken.END_OBJECT) {
                String fieldName = reader.getFieldName();
                reader.nextToken();

                if ("hash".equals(fieldName)) {
                    hash = reader.getString();
                } else if ("search".equals(fieldName)) {
                    search = reader.readMap(reader1 -> reader1.getString());
                } else if ("_where".equals(fieldName)) {
                    where = reader.getString();
                } else if ("orderby".equals(fieldName)) {
                    orderby = reader.getString();
                } else if ("lastused".equals(fieldName)) {
                    lastused = reader
                        .getNullable(nonNullReader -> CoreUtils.parseBestOffsetDateTime(nonNullReader.getString()));
                } else if ("usecount".equals(fieldName)) {
                    usecount = reader.getInt();
                } else if ("metadata".equals(fieldName)) {
                    metadata = Metadata.fromJson(reader);
                } else {
                    reader.skipChildren();
                }
            }
            return new Search(hash, search, where, orderby, lastused, usecount, metadata);
        });
    }
}
